<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="【 Interview 】, 愆凡の博客">
    <meta name="description" content="额Java ME    &amp;amp;    Java SE    &amp;amp;    Java EE

Java SE
标准版的 Java 平台，为用户提供一个程序开发环境。
这个程序开发环境提供了开发与运行 Java 软件的编译器等开发工具 ">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>【 Interview 】 | 愆凡の博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">愆凡の博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">愆凡の博客</div>
        <div class="logo-desc">
            
            Was vernünftig ist, das ist wirklich; und was wirklich ist, das ist vernünftig.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/ZGW-GitHub" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/ZGW-GitHub" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = 'cd0262c224ac0370521a2dc5e298c8ab3baea47a4d9909b12345fbd091173ef9';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('文章正在修正，请稍后再来阅读！')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">【 Interview 】</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Interview/" class="post-category">
                                Interview
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-10-09
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-03-21
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    18.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    68 分
                </div>
                
				
                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="额"><a href="#额" class="headerlink" title="额"></a>额</h2><h3 id="Java-ME-amp-Java-SE-amp-Java-EE"><a href="#Java-ME-amp-Java-SE-amp-Java-EE" class="headerlink" title="Java ME    &amp;    Java SE    &amp;    Java EE"></a>Java ME    &amp;    Java SE    &amp;    Java EE</h3><blockquote>
<ul>
<li><p>Java SE</p>
<p>标准版的 Java 平台，为用户提供一个程序开发环境。</p>
<p>这个程序开发环境提供了开发与运行 Java 软件的编译器等开发工具 、软件库及 Java 虚拟机 。</p>
<p>它也是 Java2 平台、企业版本和 Java 网页服务的基础 。</p>
</li>
<li><p>Java EE</p>
<p>Java 平台企业版 </p>
</li>
<li><p>Java ME</p>
<p>是为机顶盒、移动电话 和 PDA 之类嵌入式消费电子设备提供的 Java 语言平台，包括虚拟机和一系列标准化的 Java API。</p>
</li>
</ul>
</blockquote>
<h3 id="JVM-amp-JRE-amp-JDK"><a href="#JVM-amp-JRE-amp-JDK" class="headerlink" title="JVM    &amp;    JRE    &amp;    JDK"></a>JVM    &amp;    JRE    &amp;    JDK</h3><blockquote>
<ul>
<li><p>JVM    <code>Java virtual machine</code></p>
<p>Java 虚拟机 , 是 Java 程序的运行环境 。 </p>
</li>
<li><p>JRE</p>
<p>是 Java 程序的运行时环境，包含 <strong>JVM</strong> 和运行时所需要的 <strong>核心类库</strong> 。 </p>
</li>
<li><p>JDK</p>
<p>是 Java 程序开发工具包，包含  JRE 和开发人员使用的工具 。 </p>
</li>
</ul>
</blockquote>
<h3 id="JIT-Just-In-Time-Compilation"><a href="#JIT-Just-In-Time-Compilation" class="headerlink" title="JIT    Just In Time Compilation"></a>JIT    <code>Just In Time Compilation</code></h3><blockquote>
<p>即时编译 , 当某个方法或代码块运行的特别频繁时 , 就会将这些代码认定为热点代码 , 为了提高这些代码的执行效率 , 在运行时 , 虚拟机会将这些代码编译成与本地平台相关的机器码 , 并进行各种优化 , 做这些的就是 即时编译器 ( JIT ) </p>
</blockquote>
<h2 id="一、Java-基础"><a href="#一、Java-基础" class="headerlink" title="一、Java 基础"></a>一、Java 基础</h2><h3 id="1、常用工具类"><a href="#1、常用工具类" class="headerlink" title="1、常用工具类"></a>1、常用工具类</h3><table>
<thead>
<tr>
<th>工具类</th>
<th>常用方法</th>
</tr>
</thead>
<tbody><tr>
<td>org.apache.commons.io.<code>IOUtils</code></td>
<td><code>closeQuietly</code> 关闭一个IO流、socket、或者selector且不抛出异常。通常放在finally块 <br /><code>toString</code> 转换IO流、 Uri、 byte[] 为 String <br /><code>copy</code> IO流数据复制，从输入流写到输出流中，最大支持2GB <br /><code>toByteArray</code> 从输入流、URI获取byte[]。 <br /><code>write</code> 把字节. 字符等写入输出流。 <br /><code>toInputStream</code> 把字符转换为输入流。 <br /><code>readLines</code> 从输入流中读取多行数据，返回List<String> <br /><code>copyLarge</code> 同copy，支持2GB以上数据的复制。 <br /><code>lineIterator</code> 从输入流返回一个迭代器， 根据参数要求读取的数据量，全部读取，如果数据不够，则失败。</td>
</tr>
<tr>
<td>org.apache.commons.io.<code>FileUtils</code></td>
<td><code>deleteDirectory</code> 删除文件夹<br /><code>readFileToString</code> 以字符形式读取文件内容<br /><code>deleteQueitly</code> 删除文件或文件夹且不会抛出异常<br /> <code>copyFile</code> 复制文件<br /><code>writeStringToFile</code> 把字符写到目标文件，如果文件不存在，则创建<br /><code>forceMkdir</code> 强制创建文件夹，如果该文件夹父级目录不存在，则创建父级<br /><code>write</code> 把字符写到指定文件中<br /><code>listFiles</code> 列举某个目录下的文件(根据过滤器) <br /><code>copyDirectory</code> 复制文件夹 <br /><code>forceDelete</code> 强制删除文件</td>
</tr>
<tr>
<td>org.apache.commons.io.<code>FilenameUtils</code></td>
<td><code>getExtension</code> 返回文件后缀名<br /><code>getBaseName</code> 返回文件名，不包含后缀名 <br /><code>getName</code> 返回文件全名<br /><code>concat</code> 按命令行风格组合文件路径(详见方法注释) <br /><code>removeExtension</code> 删除后缀名<br /><code>normalize</code> 使路径正常化<br /><code>wildcardMatch</code> 匹配通配符<br /><code>seperatorToUnix</code> 路径分隔符改成unix系统格式的，即/<br /><code>getFullPath</code> 获取文件路径，不包括文件名<br /><code>isExtension</code> 检查文件后缀名是不是传入参数 ( List<String> ) 中的一个</td>
</tr>
<tr>
<td>org.apache.commons.lang.<code>StringUtils</code></td>
<td><code>isBlank</code> 字符串是否为空 (trim后判断)<br /><code>isEmpty</code> 字符串是否为空 (不trim并判断)<br /><code>equals</code> 字符串是否相等<br /><code>join</code> 合并数组为单一字符串，可传分隔符<br /><code>split</code> 分割字符串<br /><code>EMPTY</code> 空字符串<br /><code>trimToNull</code> trim后为空字符串则转换为 null <br /><code>replace</code> 替换字符串</td>
</tr>
<tr>
<td>org.apache.commons.lang3.<code>StringUtils</code></td>
<td><code>isBlank</code> 字符串是否为空 (trim后判断)<br /><code>isEmpty</code> 字符串是否为空 (不trim并判断)<br /><code>equals</code> 字符串是否相等<br /><code>join</code> 合并数组为单一字符串，可传分隔符<br /><code>split</code> 分割字符串<br /><code>EMPTY</code> 空字符串<br /><code>replace</code> 替换字符串<br /><code>capitalize</code> 首字符大写</td>
</tr>
<tr>
<td>org.springframework.util.<code>StringUtils</code></td>
<td><code>hasText</code> 检查字符串中是否包含文本<br /><code>hasLength</code> 检测字符串是否长度大于0<br /><code>isEmpty</code> 检测字符串是否为空 ( 若传入为对象，则判断对象是否为 null )<br /><code>commaDelimitedStringToArray</code> 逗号分隔的String转换为数组<br /><code>collectionToDelimitedString</code> 把集合转为CSV格式字符串<br /><code>replace</code> 替换字符串</td>
</tr>
<tr>
<td>org.apache.http.util.<code>EntityUtils</code></td>
<td><code>toString</code> 把Entity转换为字符串<br /><code>consume</code> 确保Entity中的内容全部被消费。可以看到源码里又一次消费了Entity的内容，假如用户没有消费，那调用Entity时候将会把它消费掉。<br /><code>toByteArray</code> 把Entity转换为字节流<br /><code>consumeQuietly</code> 和consume一样，但不抛异常<br /><code>getContentCharset</code> 获取内容的编码</td>
</tr>
<tr>
<td>org.apache.commons.lang.<code>ArrayUtils</code></td>
<td><code>contains</code> 是否包含某字符串<br /><code>addAll</code> 添加所有 clone 克隆一个数组<br /><code>isEmpty</code> 是否空数组 add 向数组添加元素<br /><code>subarray</code> 截取数组<br /><code>indexOf</code> 查找下标<br /><code>isEquals</code> 比较数组是否相等<br /><code>toObject</code> 基础类型数据数组转换为对应的Object数组</td>
</tr>
<tr>
<td>org.apache.commons.lang3.<code>ArrayUtils</code></td>
<td><code>contains</code> 是否包含某字符串<br /><code>addAll</code> 添加所有 clone 克隆一个数组<br /><code>isEmpty</code> 是否空数组 add 向数组添加元素<br /><code>subarray</code> 截取数组<br /><code>indexOf</code> 查找下标<br /><code>isEquals</code> 比较数组是否相等<br /><code>toObject</code> 基础类型数据数组转换为对应的Object数组</td>
</tr>
<tr>
<td>org.apache.commons.collections.<code>CollectionUtils</code></td>
<td><code>isEmpty</code> 是否为空<br /><code>select</code> 根据条件筛选集合元素<br /><code>transform</code> 根据指定方法处理集合元素，类似List的map()<br /><code>filter</code> 过滤元素，类似List的filter()<br /><code>find</code> 基本和select一样<br /><code>collect</code> 和transform 差不多一样，但是返回新数组 <br /><code>forAllDo</code> 调用每个元素的指定方法<br /><code>isEqualCollection</code> 判断两个集合是否一致</td>
</tr>
<tr>
<td>org.apache.commons.lang.<code>StringEscapeUtils</code></td>
<td>支持编码转换<br /><code>escapeJson</code> <code>unEscapeJson</code><br />此外，还支持 html 、java 、JavaScript 、sql 、csv 、xml 等</td>
</tr>
<tr>
<td>org.apache.commons.lang3.<code>StringEscapeUtils</code></td>
<td>支持编码转换<br /><code>escapeJson</code> <code>unEscapeJson</code><br />此外，还支持 html 、java 、JavaScript 、sql 、csv 、xml 等</td>
</tr>
<tr>
<td>org.apache.http.client.utils.<code>URLEncodedUtils</code></td>
<td><code>format</code> 格式化参数，返回一个 HTTP POST 或者 HTTP PUT 可用 <code>application/x-www-form-urlencoded</code> 字符串<br /><code>parse</code> 把 String 或者 URI 等转换为 List<NameValuePair></td>
</tr>
<tr>
<td>org.apache.commons.codec.<code>digestDigestUtils</code></td>
<td><code>md5Hex</code> MD5加密，返回32位<br /><code>sha1Hex</code> SHA-1加密<br /><code>sha256Hex</code> SHA-256加密<br /><code>sha512Hex</code> SHA-512加密<br /><code>md5</code> MD5加密，返回16位</td>
</tr>
<tr>
<td>org.apache.commons.beanutils.<code>PropertyUtils</code></td>
<td><code>getProperty</code> 获取对象属性值<br /><code>setProperty</code> 设置对象属性值<br /><code>getPropertyDiscriptor</code> 获取属性描述器<br /><code>isReadable</code> 检查属性是否可访问<br /><code>copyProperties</code> 复制属性值，从一个对象到另一个对象<br /><code>getPropertyDiscriptors</code> 获取所有属性描述器<br /><code>isWriteable</code> 检查属性是否可写<br /><code>getPropertyType</code> 获取对象属性类型</td>
</tr>
<tr>
<td>org.apache.commons.beanutils.<code>BeanUtils</code></td>
<td><code>copyPeoperties</code> 复制属性值，从一个对象到另一个对象<br /><code>getProperty</code> 获取对象属性值<br /><code>setProperty</code> 设置对象属性值<br /><code>populate</code> 根据Map给属性复制<br /><code>copyPeoperty</code> 复制单个值，从一个对象到另一个对象<br /><code>cloneBean</code> 克隆</td>
</tr>
</tbody></table>
<h3 id="2、面向对象的-7-大设计原则"><a href="#2、面向对象的-7-大设计原则" class="headerlink" title="2、面向对象的 7 大设计原则"></a>2、面向对象的 7 大设计原则</h3><blockquote>
<p><strong>单一职责原则 ( Single-Responsibility Principle) :</strong></p>
<blockquote>
<p>每一个类应该专注于做一件事情。 </p>
</blockquote>
<p>单一职责的含义是：<strong>类的职责单一，引起类变化的原因单一。</strong>解释一下，这也是灵活的前提，如果我们把类拆分成最小的职能单位，那组合与复用就简单的多了，如果一个类做的事情太多，在组合的时候，必然会产生不必要的方法出现，这实际上是一种污染。所谓职责，我们可以理解他为功能，就是设计的这个类功能应该只有一个，而不是两个或更多。也可以理解为引用变化的原因，当你发现有两个不同的变化会要求我们修改这个类，那么你就要考虑撤分这个类了。SRP优点：消除耦合，减小因需求变化引起代码僵化。</p>
<p><strong>开闭原则(Open-Close Principal) :</strong></p>
<blockquote>
<p>面向扩展开放，面向修改关闭。 </p>
</blockquote>
<p>开闭原则的含义是：<strong>对扩展开放，对修改关闭。</strong>就是，我们写完的代码，不能因为需求变化就修改。我们可以通过新增代码的方式来解决变化的需求。当然，这是一种理想的状态，在现实中，我们要尽量的缩小这种修改。 再解释一下这条原则的意义所在，我们采用逆向思维方式来想。如果每次需求变动都去修改原有的代码，那原有的代码就存在被修改错误的风险，当然这其中存在有意和无意的修改，都会导致原有正常运行的功能失效的风险，这样很有可能会展开可怕的蝴蝶效应，使维护工作剧增。</p>
<p><strong>里氏替换原则(Liskov-Substituion Principle) ：</strong></p>
<blockquote>
<p>超类存在的地方，子类是可以替换的。 </p>
</blockquote>
<p>里氏替换原则的含义是：<strong>子类可以在任何地方替换它的父类。</strong>也就是说在程序中将基类替换为子类，程序的行为不会发生任何变化。 Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。 Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。</p>
<p><strong>依赖倒置原则(Dependecy-Inversion Principle) ：</strong></p>
<blockquote>
<p>实现尽量依赖抽象，不依赖具体实现。 </p>
</blockquote>
<p>面相对象的初期的程序，被调用者依赖于调用者。也就是调用者决定被调用者有什么方法，有什么样的实现方式，这种结构在需求变更的时候，会付出很大的代价，甚至推翻重写。 依赖倒置原则就是要求调用者和被调用者都依赖抽象，这样两者没有直接的关联和接触，在变动的时候，一方的变动不会影响另一方的变动,<strong>面向抽象编程，解耦调用和被调用者</strong>。 具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一成不变的。依赖于抽象，就是<strong>对接口编程，不要对实现编程。</strong></p>
<p><strong>接口隔离原则(Interface-Segregation Principle) :</strong></p>
<blockquote>
<p>应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。 </p>
</blockquote>
<p>它的含义是<strong>尽量使用职能单一的接口，而不使用职能复杂、全面的接口。</strong> 很好理解，接口是为了让子类实现的，如果子类想达到职能单一，那么接口也必须满足职能单一。 相反，如果接口融合了多个不相关的方法，那它的子类就被迫要实现所有方法，尽管有些方法是根本用不到的。这就是接口污染。</p>
<p><strong>迪米特法则 ：</strong></p>
<blockquote>
<p>又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。 </p>
</blockquote>
<p>又叫作最少知道原则，迪米特原则要求尽量的封装，尽量的独立，尽量的使用低级别的访问修饰符。就是说<strong>一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。</strong>这是封装特性的典型体现。 一个类如果暴露太多私用的方法和字段，会让调用者很茫然。并且会给类造成不必要的判断代码。所以，我们使用尽量低的访问修饰符，让外界不知道我们的内部。这也是面向对象的基本思路。这是迪米特原则的一个特性，无法了解类更多的私有信息。 迪米特原则要求类之间的直接联系尽量的少，两个类的访问，通过第三个中介类来实现。</p>
<p><strong>组合/聚合复用原则 ：</strong></p>
<blockquote>
<p>尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。 </p>
</blockquote>
<p>组合/聚合复用原则的含义是，<strong>如果只是达到代码复用的目的，尽量使用组合与聚合，而不是继承。</strong>因为继承的耦合性更大，组合聚合只是引用其他的类的方法，而不会受引用的类的继承而改变血统。说白了就是我只用你的方法，但我们并不是同类。</p>
</blockquote>
<h3 id="3、修饰符"><a href="#3、修饰符" class="headerlink" title="3、修饰符"></a>3、修饰符</h3><blockquote>
<p>接口 ( 默认 abstract )</p>
<ul>
<li><p>普</p>
<ul>
<li>public</li>
<li>default</li>
</ul>
</li>
<li><p>内部接口</p>
<ul>
<li>4</li>
<li>static</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><p>static    （ java 8 ）</p>
</li>
<li><p>3 ( 除了 protected ，private 是 java 9 开始的 )</p>
</li>
</ul>
</li>
</ul>
<p>抽象类</p>
<ul>
<li><p>普</p>
<ul>
<li><p>public</p>
<ul>
<li>default</li>
</ul>
</li>
<li><p>内部抽象类</p>
<ul>
<li>4</li>
</ul>
</li>
<li><p>static</p>
</li>
<li><p>方法</p>
<ul>
<li><p>static</p>
</li>
<li><p>所有</p>
<p>protected 是 默认的</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>类</p>
<ul>
<li>普<ul>
<li>public<ul>
<li>default</li>
</ul>
</li>
</ul>
</li>
<li>内部类<ul>
<li>成员内部<ul>
<li>4</li>
<li>static</li>
</ul>
</li>
<li>局部内部<ul>
<li>无</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="4、类的继承"><a href="#4、类的继承" class="headerlink" title="4、类的继承"></a>4、类的继承</h3><h4 id="类的加载顺序"><a href="#类的加载顺序" class="headerlink" title="类的加载顺序 :"></a>类的加载顺序 :</h4><blockquote>
<ol>
<li>父类静态代码块 ( 包括 静态初始块 , 静态属性 , 不包括 静态方法 )</li>
<li>子类静态代码块 ( 包括 静态初始块 , 静态属性 , 不包括 静态方法 )</li>
<li>父类非静态代码块 ( 包括 非静态初始块 , 非静态属性 )</li>
<li>父类构造方法</li>
<li>子类非静态代码块 ( 包括 非静态初始块 , 非静态属性 )</li>
<li>子类构造方法</li>
</ol>
</blockquote>
<h4 id="重写-与-重载"><a href="#重写-与-重载" class="headerlink" title="重写 与 重载 :"></a>重写 与 重载 :</h4><blockquote>
<p>重载发生在一个类中 , 重写发生在类的继承中</p>
<p>重载参数列表不同 , 与返回值无关</p>
<p>重写时子类权限修饰符必须 &gt;= 父类</p>
<p>重写时子类方法返回值必须 &lt;= 父类</p>
</blockquote>
<h3 id="5、注解"><a href="#5、注解" class="headerlink" title="5、注解"></a>5、注解</h3><h4 id="Java-三大注解"><a href="#Java-三大注解" class="headerlink" title="Java 三大注解"></a>Java 三大注解</h4><blockquote>
<ul>
<li><p>Override</p>
</li>
<li><p>Deprecated</p>
<p>表示类 , 方法 , 变量 不推荐使用了</p>
</li>
<li><p>SuppressWarnings</p>
<p>抑制编译器编译时产生的警告</p>
</li>
</ul>
</blockquote>
<h3 id="6、控制语句"><a href="#6、控制语句" class="headerlink" title="6、控制语句"></a>6、控制语句</h3><h4 id="Switch-使用-String"><a href="#Switch-使用-String" class="headerlink" title="Switch 使用 String"></a>Switch 使用 String</h4><blockquote>
<p>Java 7 开始 , 可以在 Case 中使用 String <strong>( 这是一个语法糖 )</strong></p>
<p>内部使用 HashCode 与 equals 比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       String str = <span class="string">"world"</span>;</span><br><span class="line">       String s;</span><br><span class="line">       <span class="keyword">switch</span>( (s = str).hashCode() ) &#123;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">               <span class="keyword">if</span>(s.equals(<span class="string">"hello"</span>))</span><br><span class="line">                   System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">113318802</span>:</span><br><span class="line">               <span class="keyword">if</span>(s.equals(<span class="string">"world"</span>))</span><br><span class="line">                   System.out.println(<span class="string">"world"</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="7、常量"><a href="#7、常量" class="headerlink" title="7、常量"></a>7、常量</h3><blockquote>
<p>分类 :</p>
<ul>
<li><p>编译期常量</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> A = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>

<p> 编译时，所有 A 的引用都将被替换成字面量 ( 即1024 ) , 类型必须是基本类型或 String 。 </p>
</blockquote>
</li>
<li><p>运行时常量</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> len = <span class="string">"Rhine"</span>.length(); </span><br></pre></td></tr></table></figure>

<p> 运行时才能确定它的值 。 </p>
</blockquote>
<p><strong>编译期常量不依赖类，不会引起类的初始化；而运行时常量依赖类，会引起类的初始化 。</strong></p>
</li>
</ul>
</blockquote>
<p><strong>编译时常量使用的风险 :</strong></p>
<blockquote>
<p>由于编译时，常量会被替换为字面量，这是 JVM 提高运行效率优化代码的一种方式，但有时候也会带来一定的麻烦 。</p>
<p>如果我们项目超大，项目整个编译一次特别耗费时间，那么我们有可能会只编译代码修改的部分。而一旦我们修改了常量A，但又未重新编译所有引用A常量的部分（即.java文件），那么就会导致未重新编译的那部分代码继续使用A的旧值。</p>
</blockquote>
<p><strong>示例 :</strong></p>
<p>定义常量的 Book 类 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="comment">//编译期常量，书本价格10元</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> price = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义 Student 类和 mian 方法 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cost = Book.price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"书费"</span>+<span class="keyword">this</span>.cost+<span class="string">"元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        stu.printCost();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印输出:书费10元</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p> 现在<strong>修改 Book.java 文件中的 price=5</strong>，并使用 javac 命令仅仅只重新编译 Book.java 文件 ： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Book.java</span><br></pre></td></tr></table></figure>

<p>执行 java 命令，再次运行 main 方法 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Student</span><br></pre></td></tr></table></figure>

<p> 观察结果：结果与第一次相同，书费10元 :</p>
<p><img src="%E3%80%90%20Interview%20%E3%80%91/%E7%BB%93%E6%9E%9C.png" alt="结果"></p>
<h3 id="8、包装类"><a href="#8、包装类" class="headerlink" title="8、包装类"></a>8、包装类</h3><h4 id="拆装箱"><a href="#拆装箱" class="headerlink" title="拆装箱 :"></a>拆装箱 :</h4><ul>
<li><p>由于Integer变量实际上是对一个Integer对象的引用，所以两个new生成的变量永远都不会相等； </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i= <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer j= <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">System.out.print(i==j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Integer变量和int变量比较时，只要两者的值是相同的，结果就为true； </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i= <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">int</span> j= <span class="number">100</span>;</span><br><span class="line">System.out.print(i==j); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>非new生成的Integer变量和new Integer（）生成的变量也不相等； </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i= <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer j= <span class="number">100</span>;</span><br><span class="line">System.out.print(i==j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于两个非new生成的Integer对象，进行比较时，如果两个变量值在-128到127之间时为true，否则为false；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i= <span class="number">100</span>;</span><br><span class="line">Integer j= <span class="number">100</span>;</span><br><span class="line">System.out.print(i==j); <span class="comment">//true</span></span><br><span class="line">Integer i= <span class="number">128</span>;</span><br><span class="line">Integer j= <span class="number">128</span>;</span><br><span class="line">System.out.print(i==j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="int-和-Integer-区别-："><a href="#int-和-Integer-区别-：" class="headerlink" title="int 和 Integer 区别 ："></a>int 和 Integer 区别 ：</h4><ul>
<li>Integer 是 int 的包装类，int 则是 java 中的一种基本数据类型；</li>
<li>Integer 变量必须实例化后才能使用，而 int 不需要；</li>
<li>Integer 实际是对象的引用，当 new 一个 Integer 时，实际上是生成一个指针指向此对象；而 int 则是直接存储数据值；</li>
<li>Integer 默认的值是 null，而 int 默认值为 0；</li>
</ul>
<h3 id="9、数组"><a href="#9、数组" class="headerlink" title="9、数组"></a>9、数组</h3><h4 id="a、数组下标为何以-0-开始"><a href="#a、数组下标为何以-0-开始" class="headerlink" title="a、数组下标为何以 0 开始"></a>a、数组下标为何以 0 开始</h4><p>方便计算地址偏移</p>
<p>元素 2 地址 = 起始地址 + 下标 * 每个元素所占空间大小</p>
<h4 id="b、怎么打印数组"><a href="#b、怎么打印数组" class="headerlink" title="b、怎么打印数组"></a>b、怎么打印数组</h4><ul>
<li>使用 <code>Arrays.toString()</code></li>
<li>使用 <code>Arrays.deepToString()</code></li>
</ul>
<h3 id="10、a-a-b-与-a-b"><a href="#10、a-a-b-与-a-b" class="headerlink" title="10、a=a+b 与 a+=b"></a>10、<code>a=a+b</code> 与 <code>a+=b</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">a = a + b; <span class="comment">// IDE提示错误</span></span><br><span class="line">a += b;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>a+=b</code> :</p>
<p>隐式的将计算的结果数据类型强转为了 a 的数据类型 , 所以 : 这里 <code>b += a</code> 的结果将发生溢出 ( int 强转为了 byte )</p>
<p><code>a=a+b</code> :</p>
<p>因为 , a 与 b 计算会先转为 int 计算后将 int 值赋给 a , 但 a 是 byte 所以会报错</p>
</blockquote>
<h3 id="11、递归"><a href="#11、递归" class="headerlink" title="11、递归"></a>11、递归</h3><h4 id="普通递归"><a href="#普通递归" class="headerlink" title="普通递归"></a>普通递归</h4><p><strong>两个显著特点 :</strong></p>
<ol>
<li>调用的是同一个方法</li>
<li>在自身中调用自身，是嵌套调用（ 栈帧无法回收，开销巨大 ）</li>
</ol>
<p><strong>可能造成问题 :</strong></p>
<ul>
<li>内存溢出</li>
</ul>
<p><strong>解决 :</strong></p>
<ul>
<li>尾递归优化</li>
</ul>
<h4 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h4><blockquote>
<p> 包括两个东西 :</p>
<ul>
<li>尾递归的形式</li>
<li>编译器对尾递归的优化</li>
</ul>
</blockquote>
<ol>
<li><p>尾递归的形式 :</p>
<ul>
<li><p>方法调用自身这件事，一定是该方法做的最后一件事（ 所以当有需要返回值的时候会是 <code>return f(n)</code> ，没有返回的话就直接是 <code>f(n)</code> 了 ） </p>
</li>
<li><p>但是有一些常见的误区 :</p>
<p>这个 <code>f(n)</code> 外不能加其他东西，因为这就不是最后一件事了，值返回来后还要再干点其他的活，变量空间还需要保留 . ( 比如 : 如果有返回值的，你不能：乘个常数 <code>return 3f(n)</code> ；乘个 n <code>return n*f(n)</code> ；甚至是 <code>f(n)+f(n-1)</code></p>
</li>
<li><p>另外，使用 <code>return</code> 的尾递归还跟函数式编程有一点关系</p>
</li>
</ul>
</li>
<li><p>编译器对尾递归的优化</p>
<ul>
<li><p>上面说了，你光手动写成尾递归的形式，并没有什么用，要实现优化，还需要编译器中加入了对尾递归优化的机制</p>
</li>
<li><p>有了这个机制，编译的时候，就会自动利用上面的特点一来进行优化</p>
</li>
<li><p>具体是怎么优化的 ：</p>
</li>
<li><p>简单说就是重复利用同一个栈帧，不仅不用释放上一个，连下一个新的都不用开，效率非常高（ 有人做实验，这个比递推比迭代都要效率高 ）</p>
</li>
</ul>
</li>
<li><p>为什么写成尾递归的形式，编译器就能优化了？或者说【编译器对尾递归的优化】的一些深层思想 :</p>
<ul>
<li><p>说是深层思想，其实也是因为正好编译器其实在这里没做什么复杂的事，所以很简单</p>
</li>
<li><p>由于以下两方面的原因，尾递归优化得以实现，而且效果很好</p>
<ul>
<li>因为在递归调用自身的时候，这一层函数已经没有要做的事情了，虽然被递归调用的函数是在当前的函数里，但是他们之间的关系已经在传参的时候了断了，也就是这一层函数的所有变量什么的都不会再被用到了，所以当前函数虽然没有执行完，不能弹出栈，但它确实已经可以出栈了，这是一方面</li>
<li>另一方面，正因为调用的是自身，所以需要的存储空间是一毛一样的，那干脆重新刷新这些空间给下一层利用就好了，不用销毁再另开空间</li>
</ul>
</li>
<li><p>有人对写成尾递归形式的说法是【为了告诉编译器这块要尾递归】，这种说法可能会导致误解，因为不是只告诉编译器就行，而是你需要做优化的前半部分，之后编译器做后半部分</p>
</li>
</ul>
</li>
</ol>
<h3 id="12、泛型"><a href="#12、泛型" class="headerlink" title="12、泛型"></a>12、泛型</h3><ul>
<li>是一个 Java 语法糖</li>
<li>Java 1.5 , 引入了泛型 , 此后若在向集合添加元素时添加了其他类型的元素 , 则会在编译期报错 , 避免了运行时的 ClassCastException 异常</li>
<li>泛型也使得代码简洁了 , 我们也不再需要显式类型转换了</li>
<li>运行时也不会产生类型检查的字节码指令</li>
</ul>
<h3 id="13、异常"><a href="#13、异常" class="headerlink" title="13、异常"></a>13、异常</h3><h4 id="a、异常类"><a href="#a、异常类" class="headerlink" title="a、异常类"></a>a、异常类</h4><blockquote>
<ul>
<li>Throwable<ul>
<li>Exception</li>
<li>Error</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="b、Exception-的分类"><a href="#b、Exception-的分类" class="headerlink" title="b、Exception 的分类"></a>b、Exception 的分类</h4><ul>
<li><p>受检查的异常 ( CheckedException )</p>
<ul>
<li><p>IOException</p>
</li>
<li><p>SQLException</p>
<p>SQL异常 , 常见于 SQL 语句错误</p>
</li>
</ul>
</li>
<li><p>运行时异常 ( RuntimeException )</p>
<ul>
<li><p>NullPointerException</p>
<p>空指针异常</p>
</li>
<li><p>ClassNotFoundException</p>
<p>指定的类找不到</p>
</li>
<li><p>NoClassDefFoundException</p>
<p>未找到类定义</p>
</li>
<li><p>ClassCastException</p>
<p>类转换异常</p>
</li>
<li><p>NumberFormatException</p>
<p>字符串转化为数字异常</p>
</li>
<li><p>IndexOutOfBoundsException</p>
<p>数组下标越界</p>
</li>
<li><p>NoSuchMethodException</p>
<p>方法不存在异常</p>
</li>
</ul>
</li>
</ul>
<h4 id="c、处理"><a href="#c、处理" class="headerlink" title="c、处理"></a>c、处理</h4><h5 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h5><blockquote>
<p>一般是虚拟机相关的问题 , 如系统崩溃、内存不足、栈溢出 等</p>
</blockquote>
<h5 id="CheckedException"><a href="#CheckedException" class="headerlink" title="CheckedException"></a>CheckedException</h5><blockquote>
<p>强制要求处理</p>
<p>使用 <code>try cache finally</code> 块处理 , 或 <code>throws</code> 声明</p>
</blockquote>
<h5 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h5><blockquote>
<p>可以使用 <code>try cache finally</code> 块处理 , 或 <code>throws</code> 声明</p>
<p>也可以不处理 , 此时 , 当发生 RuntimeException 程序后 ,  要么是线程中止，要么是主程序终止</p>
</blockquote>
<h4 id="d、Throw-与-Throws-的区别"><a href="#d、Throw-与-Throws-的区别" class="headerlink" title="d、Throw 与 Throws 的区别 ?"></a>d、Throw 与 Throws 的区别 ?</h4><p><strong>Throw</strong></p>
<ul>
<li>throw 用在方法体内</li>
<li>表示抛出异常 , 由方法体内处理该异常</li>
<li>执行了 throw 一定是抛出了某个异常</li>
</ul>
<p><strong>Throws</strong></p>
<ul>
<li>throws 用在方法的声明后面</li>
<li>表示声明一个异常 , 主要是声明该方法可能抛出的异常 , 该异常不一定会产生</li>
</ul>
<h4 id="e、异常处理块执行顺序"><a href="#e、异常处理块执行顺序" class="headerlink" title="e、异常处理块执行顺序"></a>e、异常处理块执行顺序</h4><blockquote>
<p>finally 中有 return :</p>
<ul>
<li>先执行 try 中 return 语句 , 并将要返回的值保存 , 再执行 finally 中的语句 , 执行到 finally 中的 return 时 , 将先前保存的 return 值覆盖并返回 .</li>
</ul>
<p>finally 中无 return :</p>
<ul>
<li>先执行 try 中 return 语句 , 并将要返回的值保存 , 再执行 finally 中的语句 , 执行完后 , 将先前保存的 return 值返回 .</li>
</ul>
</blockquote>
<h3 id="14、容器"><a href="#14、容器" class="headerlink" title="14、容器"></a>14、容器</h3><p><img src="%E3%80%90%20Interview%20%E3%80%91/%E5%AE%B9%E5%99%A8.png" alt="容器"></p>
<blockquote>
<p><strong>List</strong></p>
<ul>
<li>可重复，有索引，有序</li>
</ul>
<p><strong>Set</strong></p>
<ul>
<li>不可重复，无索引，无序（ LinkedHashSet 有序 ）</li>
</ul>
<p><strong>Map</strong></p>
<ul>
<li>不可重复，无序（ LinkedHashMap 有序 ）</li>
</ul>
</blockquote>
<p><strong>细说 Map ：</strong></p>
<ul>
<li><p>HashMap</p>
<ul>
<li>允许 NULL</li>
</ul>
</li>
<li><p>HashTable</p>
<ul>
<li>不允许 NULL</li>
</ul>
</li>
<li><p>TreeMap</p>
<ul>
<li>k 不能为 NULL</li>
<li>v 可为 NULL</li>
</ul>
</li>
</ul>
<h4 id="a、底层结构"><a href="#a、底层结构" class="headerlink" title="a、底层结构"></a>a、底层结构</h4><table>
<thead>
<tr>
<th align="center">容器</th>
<th align="center">1.8</th>
<th align="center">1.6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LinkedList</td>
<td align="center">双向链表</td>
<td align="center">双向循环链表</td>
</tr>
<tr>
<td align="center">ConcurrentHashMap</td>
<td align="center">数组 + 链表 + 红黑树</td>
<td align="center">分段的数组 + 链表</td>
</tr>
</tbody></table>
<h4 id="b、扩容"><a href="#b、扩容" class="headerlink" title="b、扩容"></a>b、扩容</h4><table>
<thead>
<tr>
<th align="center">容器</th>
<th align="center">初始大小</th>
<th align="center">扩容机制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ArrayList</td>
<td align="center">10</td>
<td align="center">1.5 倍</td>
</tr>
<tr>
<td align="center">Vector</td>
<td align="center">10</td>
<td align="center">2 倍</td>
</tr>
<tr>
<td align="center">HashMap</td>
<td align="center">16</td>
<td align="center">2 的 n 次幂</td>
</tr>
<tr>
<td align="center">HashTable</td>
<td align="center">11</td>
<td align="center">2 倍 + 1</td>
</tr>
</tbody></table>
<h4 id="c、线程安全-V-SHE"><a href="#c、线程安全-V-SHE" class="headerlink" title="c、线程安全    V,SHE"></a>c、线程安全    <code>V,SHE</code></h4><blockquote>
<p>Vector , Stack , Hashtable , Enumeration</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">集合</th>
<th align="center">1.8</th>
<th align="center">1.7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ConcurrentHashMap</td>
<td align="center">synchronized + CAS</td>
<td align="center">分段锁</td>
</tr>
<tr>
<td align="center">HashTable</td>
<td align="center">全表锁</td>
<td align="center">全表锁</td>
</tr>
</tbody></table>
<h4 id="d、并发容器"><a href="#d、并发容器" class="headerlink" title="d、并发容器"></a>d、并发容器</h4><h5 id="a、CopyOnWriteArrayList"><a href="#a、CopyOnWriteArrayList" class="headerlink" title="a、CopyOnWriteArrayList"></a>a、CopyOnWriteArrayList</h5><blockquote>
<p>允许并发读，写操作（增删改）时，首先将当前容器拷贝一份，然后在新副本上执行写操作，写操作完成后将原容器的引用指向新容器。CopyOnWriteArrayList 的任何写操作都是加锁的，同时只能有一个线程执行写操作。</p>
<p><strong>优点：</strong></p>
<ul>
<li>读时，无同步措施，性能很高，适合读多写少。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>内存占用：</strong>每次写都要拷贝一份原容器， 数据量大时，对内存压力较大，可能会引起频繁GC 。</li>
<li><strong>无法保证实时性：</strong>因为读写不在同一容器，写时，读读取到的数据是旧容器数据。</li>
</ul>
</blockquote>
<h4 id="N、问题"><a href="#N、问题" class="headerlink" title="N、问题"></a>N、问题</h4><h5 id="comparable-和-Comparator"><a href="#comparable-和-Comparator" class="headerlink" title="comparable 和 Comparator"></a>comparable 和 Comparator</h5><p><strong>comparable 接口：</strong>（ 自己用 ）</p>
<ul>
<li><p><code>java.lang</code> 包，<code>compareTo(Object obj)</code></p>
</li>
<li><p>使用：</p>
<p>使要排序的类实现该接口并重写方法，相当于在自已内部定义了一个比较器供自己使用。</p>
</li>
</ul>
<p><strong>comparator 接口：</strong>（ 别人用 ）</p>
<ul>
<li><p><code>java.util</code> 包，<code>compare(Object obj1, Object obj2)</code></p>
</li>
<li><p>使用：</p>
<p>相当于自定义了一个比较器供别人使用。</p>
</li>
</ul>
<h5 id="为什么集合类没有实现-Cloneable-和-Serializable-接口"><a href="#为什么集合类没有实现-Cloneable-和-Serializable-接口" class="headerlink" title="为什么集合类没有实现 Cloneable 和 Serializable 接口"></a>为什么集合类没有实现 Cloneable 和 Serializable 接口</h5><p>克隆（cloning）或者序列化（serialization）的语义和含义是跟具体的实现相关的。</p>
<p>因此应该由集合类的具体实现类来决定如何被克隆或者序列化</p>
<h5 id="HashMap-的扩容机制-默认大小为何是-2-次幂"><a href="#HashMap-的扩容机制-默认大小为何是-2-次幂" class="headerlink" title="HashMap 的扩容机制 ? 默认大小为何是 2 次幂 ?"></a>HashMap 的扩容机制 ? 默认大小为何是 2 次幂 ?</h5><p><strong>HashMap 的扩容机制 :</strong></p>
<ul>
<li><strong>默认大小 :</strong> 16</li>
<li><strong>扩容 :</strong> 最近的 2 次幂</li>
<li><strong>树化 :</strong> 8</li>
<li><strong>链化 :</strong> 6</li>
</ul>
<p><strong>默认大小是 2 次幂的目的 ?</strong></p>
<ul>
<li><p>降低 Hash 碰撞的几率</p>
</li>
<li><p>对于同一组 hash 值 , 当 hashMap 的大小为 2 次幂时 , 关于元素的位置决定就单纯的与该元素的 Hash 值相关了 , 而消除了 长度(HashMap大小) 的影响 . </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">设 HashMap 的大小为 10 :</span><br><span class="line"></span><br><span class="line">HashCode :			10 1110 0011 1010 1110 1001</span><br><span class="line">Length - 1 :							     1001</span><br><span class="line">Index :									  1001</span><br><span class="line"></span><br><span class="line">HashCode :			10 1110 0011 1010 1110 1101</span><br><span class="line">Length - 1 :							     1001</span><br><span class="line">Index :									  1001</span><br><span class="line"></span><br><span class="line">HashCode :			10 1110 0011 1010 1110 1111</span><br><span class="line">Length - 1 :							     1001</span><br><span class="line">Index :									  1001</span><br></pre></td></tr></table></figure>

<p>如上所示 :</p>
<p>index 的结果等同于 HashCode 与 Length - 1 计算后的值 , index 的取值受到了 Length 的影响 。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">设 HashMap 的大小为 16 :</span><br><span class="line"></span><br><span class="line">HashCode :			10 1110 0011 1010 1110 1001</span><br><span class="line">Length - 1 :							     1111</span><br><span class="line">Index :									  1001</span><br><span class="line"></span><br><span class="line">HashCode :			10 1110 0011 1010 1110 1101</span><br><span class="line">Length - 1 :							     1111</span><br><span class="line">Index :									  1101</span><br><span class="line"></span><br><span class="line">HashCode :			10 1110 0011 1010 1110 1111</span><br><span class="line">Length - 1 :							     1111</span><br><span class="line">Index :									  1001</span><br></pre></td></tr></table></figure>

<p>如上所示 :</p>
<p>index 的结果等同于 HashCode 后几位的值 , 与 Length 无关了 。只要输入的 HashCode 本身分布均匀，Hash 算法的结果就是均匀的 。 </p>
</li>
</ul>
<h5 id="HashMap-与-HashSet"><a href="#HashMap-与-HashSet" class="headerlink" title="HashMap 与 HashSet"></a>HashMap 与 HashSet</h5><ul>
<li>HashSet 比 HashMap 快</li>
</ul>
<p><strong>区别 :</strong></p>
<table>
<thead>
<tr>
<th align="center"><em>HashMap</em></th>
<th align="center"><em>HashSet</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center">HashMap 实现了 Map 接口</td>
<td align="center">HashSet 实现了 Set 接口</td>
</tr>
<tr>
<td align="center">HashMap 储存键值对</td>
<td align="center">HashSet 仅仅存储对象</td>
</tr>
<tr>
<td align="center">使用 <code>put()</code> 方法将元素放入 map 中</td>
<td align="center">使用 <code>add()</code> 方法将元素放入 set 中</td>
</tr>
<tr>
<td align="center">HashMap 中使用键对象来计算 hashcode 值</td>
<td align="center">HashSet 使用成员对象来计算 hashCode 值，对于两个对象来说 hashCode 可能相同，所以 <code>equals()</code> 方法用来判断对象的相等性，如果两个对象不同的话，那么返回 false</td>
</tr>
<tr>
<td align="center">HashMap 比较快，因为是使用唯一的键来获取对象</td>
<td align="center">HashSet 较 HashMap 来说比较慢</td>
</tr>
</tbody></table>
<h5 id="HashMap-与-TreeMap"><a href="#HashMap-与-TreeMap" class="headerlink" title="HashMap 与 TreeMap"></a>HashMap 与 TreeMap</h5><table>
<thead>
<tr>
<th align="center"><em>HashMap</em></th>
<th align="center"><em>TreeMap</em></th>
</tr>
</thead>
<tbody><tr>
<td align="center">适用于 插入 &amp; 删除 &amp; 定位 元素</td>
<td align="center">有序</td>
</tr>
</tbody></table>
<h5 id="ArrayList-与-Vector"><a href="#ArrayList-与-Vector" class="headerlink" title="ArrayList 与 Vector"></a>ArrayList 与 Vector</h5><p><strong>相同点 :</strong></p>
<ul>
<li>底层都是数组</li>
<li>可以维护插入的顺序 , 可以根据插入顺序获取元素</li>
<li>它们的迭代器都是 fail-fast ( 快速失败 ) 的</li>
<li>都允许 Null 值</li>
</ul>
<p><strong>不同点 :</strong></p>
<ul>
<li>ArrayList 线程不安全 , Vector 线程安全</li>
<li>ArrayList 扩容0.5倍，Vector 1 倍</li>
</ul>
<h5 id="LinkedHashMap-与-PriorityQueue"><a href="#LinkedHashMap-与-PriorityQueue" class="headerlink" title="LinkedHashMap    与 PriorityQueue"></a>LinkedHashMap    与 PriorityQueue</h5><p>LinkedHashMap :</p>
<ul>
<li>维持了元素插入的顺序 .</li>
</ul>
<p>PriorityQueue :</p>
<ul>
<li>保证最高 / 最低优先级的元素总是在队列头部</li>
</ul>
<h5 id="优先级队列-PriorityQueue"><a href="#优先级队列-PriorityQueue" class="headerlink" title="优先级队列    PriorityQueue"></a>优先级队列    <code>PriorityQueue</code></h5><ul>
<li>PriorityQueue 类在 Java 1.5 中引入 。</li>
<li>PriorityQueue 是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的<br> Comparator 在队列实例化的时排序 。</li>
<li>PriorityQueue 不允许空值，而且不支持 non-comparable（不可比较）的对象，比如用户自定义的类。优先队列要求使用 Java Comparable 和 Comparator 接口给对象排序，并且在排序时会按照优先级处理其中的元素 。</li>
<li>PriorityQueue 的大小是不受限制的，但在创建时可以指定初始大小。当我们向优先队列增加元素的时候，队列大小会自动增加 。</li>
<li>PriorityQueue 是非线程安全的，所以 Java 提供了 PriorityBlockingQueue（实现 BlockingQueue接口）用于 Java 多线程环境 。</li>
<li>出队 与 入队 的时间复杂度为 log(N) 。</li>
</ul>
<h5 id="几种方式实现集合的排序"><a href="#几种方式实现集合的排序" class="headerlink" title="几种方式实现集合的排序"></a>几种方式实现集合的排序</h5><blockquote>
<ul>
<li>使用有序集合 : TreeSet 、TreeMap</li>
<li>使用 list 集合 , 然后通过 <code>Collections.sort()</code> 进行排序</li>
</ul>
</blockquote>
<h5 id="为何-Map-接口不继承-Collection-接口"><a href="#为何-Map-接口不继承-Collection-接口" class="headerlink" title="为何 Map 接口不继承 Collection 接口 ?"></a>为何 Map 接口不继承 Collection 接口 ?</h5><p>Map 接口和其实现虽然也是集合框架的一部分 , 但 Map 不是集合 , 集合也不是 Map .</p>
<p>因此 , Map 继承 Collection 接口毫无意义 , 反之亦然 .</p>
<p>如果 Map 继承 Collection 接口 , 那么元素存哪 ? Collection 是单列的 , Map 是双列的 .</p>
<h3 id="15、序列化"><a href="#15、序列化" class="headerlink" title="15、序列化"></a>15、序列化</h3><blockquote>
<p>在 Java 中，对象的序列化可以通过实现两种接口来实现 : </p>
<ul>
<li>若实现的是 Serializable 接口，则所有的序列化将会自动进行</li>
<li>若实现的是 Externalizable 接口，则没有任何东西可以自动序列化，需要在 writeExternal 方法中进行手工指定所要序列化的变量，这与是否被 transient 修饰无关</li>
</ul>
</blockquote>
<h3 id="16、ClassLoad"><a href="#16、ClassLoad" class="headerlink" title="16、ClassLoad"></a>16、ClassLoad</h3><p><img src="%E3%80%90%20Interview%20%E3%80%91/ClassLoad.png" alt="ClassLoad"></p>
<h4 id="ClassLoad-有什么用"><a href="#ClassLoad-有什么用" class="headerlink" title="ClassLoad 有什么用 ?"></a>ClassLoad 有什么用 ?</h4><blockquote>
<p>代码保护(加解密)</p>
</blockquote>
<ul>
<li><p>代码保护(加解密) :</p>
<p>自定义加载器重写 findclass 来做到解密后装载</p>
</li>
</ul>
<h3 id="17、Object-类的方法"><a href="#17、Object-类的方法" class="headerlink" title="17、Object 类的方法"></a>17、Object 类的方法</h3><h4 id="Object-类中有哪些方法"><a href="#Object-类中有哪些方法" class="headerlink" title="Object 类中有哪些方法 ?"></a>Object 类中有哪些方法 ?</h4><ul>
<li>toString</li>
<li>HashCode</li>
<li>equals</li>
<li>getClass</li>
<li>clone</li>
<li>notify</li>
<li>notifyAll</li>
<li>wait</li>
<li>finalize</li>
</ul>
<h4 id="与-equals-的区别"><a href="#与-equals-的区别" class="headerlink" title="== 与 equals 的区别 ?"></a>== 与 equals 的区别 ?</h4><blockquote>
<p>== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；</p>
<p>而 equals 默认情况下是引用比较 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String.java :</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">     String anotherString = (String)anObject;</span><br><span class="line">     <span class="keyword">int</span> n = value.length;</span><br><span class="line">     <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">         <span class="keyword">char</span> v1[] = value;</span><br><span class="line">         <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">         <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以一般情况下 equals 比较的是值是否相等 。</p>
</blockquote>
<h4 id="HashCode-方法的作用"><a href="#HashCode-方法的作用" class="headerlink" title="HashCode 方法的作用 ?"></a>HashCode 方法的作用 ?</h4><p>Object 基类的 <code>hashCode</code> 方法默认返回对象的内存地址</p>
<p>而在集合中 HashCode 被重写了 , 这样的的作用是提高集合中元素的查找效率，如 Hashtable，HashMap 等，HashCode 经常用于确定对象在集合中的存储位置 , 若 HashCode 相同再去调用 equals 方法</p>
<h2 id="二、Java-Web"><a href="#二、Java-Web" class="headerlink" title="二、Java Web"></a>二、Java Web</h2><p>描述下网页一个 Http 请求，到后端的整个请求过程</p>
<ol>
<li>利用DNS进行域名解析</li>
<li>发起TCP的3次握手</li>
<li>建立TCP连接后发起http请求</li>
<li>服务器响应http请求，浏览器得到html代码</li>
<li>浏览器解析html代码，并请求html代码中的资源（如：js、css、图片等）</li>
<li>浏览器对页面进行渲染呈现给用户</li>
</ol>
<h2 id="三、数据结构-amp-算法基础"><a href="#三、数据结构-amp-算法基础" class="headerlink" title="三、数据结构 &amp; 算法基础"></a>三、数据结构 &amp; 算法基础</h2><h3 id="1、大-O-表达式"><a href="#1、大-O-表达式" class="headerlink" title="1、大 O 表达式"></a>1、大 O 表达式</h3><p><img src="%E3%80%90%20Interview%20%E3%80%91/%E5%A4%A7O.png" alt="大O"></p>
<p><img src="%E3%80%90%20Interview%20%E3%80%91/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20&%20%E6%93%8D%E4%BD%9C.png" alt="常见数据结构 &amp; 操作"></p>
<p><img src="%E3%80%90%20Interview%20%E3%80%91/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt="数组排序算法"></p>
<h2 id="四、多线程"><a href="#四、多线程" class="headerlink" title="四、多线程"></a>四、多线程</h2><h3 id="1、并发-与-并行"><a href="#1、并发-与-并行" class="headerlink" title="1、并发 与 并行"></a>1、并发 与 并行</h3><blockquote>
<ul>
<li><p>并发 :</p>
<p>  并发的关键是你有处理多个任务的能力，不一定要同时 。</p>
</li>
<li><p>并行 :</p>
<p>  并行的关键是你有同时处理多个任务的能力 。</p>
<p>与并行对立的是串行。</p>
</li>
<li><p>并行与并发最关键的点就是：是否是『同时』。</p>
</li>
</ul>
<p>举例 :</p>
<ul>
<li>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</li>
<li>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</li>
<li>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 </li>
</ul>
</blockquote>
<h3 id="2、状态转换"><a href="#2、状态转换" class="headerlink" title="2、状态转换"></a>2、状态转换</h3><blockquote>
<p>六种状态：</p>
<table>
<thead>
<tr>
<th align="center">NEW</th>
<th align="center">RUNNABLE</th>
<th align="center">运行</th>
<th align="center">BLOCKED</th>
<th align="center">WAITING</th>
<th align="center">TIMED_WAITING</th>
<th align="center">TERMINATED</th>
</tr>
</thead>
<tbody><tr>
<td align="center">新建</td>
<td align="center">就绪</td>
<td align="center"></td>
<td align="center">阻塞</td>
<td align="center">等待</td>
<td align="center">超时等待</td>
<td align="center">终止</td>
</tr>
</tbody></table>
</blockquote>
<p><img src="%E3%80%90%20Interview%20%E3%80%91/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="线程状态转换"></p>
<h3 id="3、锁"><a href="#3、锁" class="headerlink" title="3、锁"></a>3、锁</h3><blockquote>
<ul>
<li><p>自旋锁</p>
</li>
<li><p>阻塞锁</p>
<p>被阻塞的锁不会争夺锁</p>
</li>
<li><p>可重入锁</p>
</li>
<li><p>读写锁</p>
</li>
<li><p>互斥锁</p>
</li>
<li><p>悲观锁</p>
<p>不相信是安全的 , 全部上锁</p>
</li>
<li><p>乐观锁</p>
</li>
<li><p>非公平锁</p>
<p>无优先级的锁</p>
</li>
<li><p>偏向锁</p>
<p>无竞争不锁 , 有竞争挂起 , 转为轻量级锁</p>
</li>
<li><p>对象锁</p>
</li>
<li><p>线程锁</p>
</li>
<li><p>轻量级锁</p>
<p>CAS 实现</p>
</li>
<li><p>锁粗化</p>
<p>多锁变成一个 , 自己处理</p>
</li>
<li><p>锁消除</p>
<p>偏向锁就是锁消除的一种</p>
</li>
<li><p>锁膨胀</p>
<p>JVM 实现 , 锁粗化</p>
</li>
<li><p>信号量</p>
<p>使用阻塞锁实现的一种策略</p>
</li>
</ul>
</blockquote>
<h4 id="a、原生锁"><a href="#a、原生锁" class="headerlink" title="a、原生锁"></a>a、原生锁</h4><h5 id="①、Synchronized"><a href="#①、Synchronized" class="headerlink" title="①、Synchronized"></a>①、Synchronized</h5><blockquote>
<p>实现原理：</p>
<ul>
<li>synchronized 是基于 Java 对象头和 Monitor 机制来实现的。 </li>
<li>Synchronized 保证了操作的原子性、内存可见性、有序性。</li>
</ul>
</blockquote>
<blockquote>
<p>synchronized 加锁：</p>
<ul>
<li>当对代码块进行加锁时，锁是括号中的对象；</li>
<li>当对非静态方法进行加锁，锁是当前实例对象；</li>
<li>当对静态方法进行加锁，锁是当前类的 Class 对象。</li>
</ul>
</blockquote>
<h6 id="锁升级："><a href="#锁升级：" class="headerlink" title="锁升级："></a>锁升级：</h6><p><strong>Synchronized 用的锁保存在 Java 的对象头中，对象头中有一个锁标记，该标记有 4 种状态：</strong></p>
<ul>
<li><p>无锁</p>
</li>
<li><p>偏向锁</p>
</li>
<li><p>轻量级锁</p>
<p>线程 A B 在自己的栈帧中分配用于存储所记录的空间，并去复制锁对象头中的 Mark Word ，然后进行 CAS 修改（将对象头中的 Mark Word 替换为指向自己栈帧中复制的 Mark Word）</p>
<ul>
<li><p>成功：</p>
<p>得到锁</p>
</li>
<li><p>失败：</p>
<p>自旋获取锁</p>
</li>
</ul>
</li>
<li><p>重量级锁</p>
</li>
</ul>
<p><strong>偏向锁 -&gt; 轻量级锁：</strong></p>
<blockquote>
<p>当 B 竞争偏向锁时，首先暂停拥有锁的 A 线程，然后检查 A 是否处于活动：</p>
<ul>
<li><p>否：</p>
<p>将锁对象设置为无锁，然后锁可以偏向 B ；</p>
<ul>
<li><p>是：</p>
<p>遍历线程 A 的栈帧，判断 A 是否需要继续持有锁：</p>
<ul>
<li><p>否：</p>
<p>将锁对象设置为无锁，然后锁可以偏向 B ；</p>
</li>
<li><p>是：</p>
<p>暂停 A 线程，撤销偏向锁，升级为轻量级锁，然后恢复 A 线程。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>轻量级锁 -&gt; 重量级锁：</strong></p>
<blockquote>
<ul>
<li><p>当 B 在自旋获取轻量级锁时自旋次数达到一定次数，锁就会升级为重量级锁。</p>
</li>
<li><p>当 B 在自旋获取轻量级锁时又有 C 过来获取锁，锁就会升级为重量级锁。</p>
</li>
</ul>
</blockquote>
<h6 id="JVM-对-synchronized-的优化："><a href="#JVM-对-synchronized-的优化：" class="headerlink" title="JVM 对 synchronized 的优化："></a>JVM 对 synchronized 的优化：</h6><ul>
<li><p><strong>自旋锁与自适应自旋</strong></p>
</li>
<li><p><strong>锁消除</strong></p>
</li>
<li><p><strong>锁粗化</strong></p>
<p>当虚拟机检测到有一串零碎的操作都对同一个对象加锁时，会把锁扩展到整个操作序列外部。如 StringBuffer 的 append 操作。 </p>
</li>
<li><p><strong>轻量级锁</strong></p>
<p>对绝大部分的锁来说，在整个同步周期内都不存在竞争。如果没有竞争，轻量级锁可以使用 CAS 操作避免使用互斥量的开销。 </p>
</li>
<li><p><strong>偏向锁</strong></p>
<p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时，无需再做任何同步操作，即可获取锁。 </p>
</li>
</ul>
<h5 id="②、显式-Lock"><a href="#②、显式-Lock" class="headerlink" title="②、显式 Lock"></a>②、显式 Lock</h5><blockquote>
<p>Lock 接口的实现类：</p>
<ul>
<li>ReentrantLock（可重入锁）</li>
<li>ReentrantReadWriteLock . ReadLock（可重入读写锁-读锁）</li>
<li>ReentrantReadWriteLock . WriteLock（可重入读写锁-写锁）</li>
</ul>
</blockquote>
<h4 id="b、锁的底层实现方式"><a href="#b、锁的底层实现方式" class="headerlink" title="b、锁的底层实现方式"></a>b、锁的底层实现方式</h4><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><blockquote>
<p>CAS 全拼：compare and swap</p>
</blockquote>
<blockquote>
<p><code>unsafe.compareAndSwapInt(this, valueOffset, expect, update);</code></p>
<p>它需要三个参数，分别是内存位置 V，旧的预期值 A 和新的值 B。操作时，先从内存位置读取到值，然后和预期值 A 比较。如果相等，则将此内存位置的值改为新值 B，返回 true。如果不相等，说明和其他线程冲突了，则不做任何改变，返回 false。 </p>
</blockquote>
<h6 id="用到-CAS-的地方"><a href="#用到-CAS-的地方" class="headerlink" title="用到 CAS 的地方"></a>用到 CAS 的地方</h6><ul>
<li>Atomic 系列类</li>
<li>Lock 系列类</li>
<li>1.6 之后 Synchronized 的 重量级锁</li>
<li>等。。。</li>
</ul>
<h6 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h6><p>有很多文章说，CAS 操作失败后会一直重试直到成功，这种说法很不严谨。</p>
<p>第一，CAS 本身并未实现失败后的处理机制，它只负责返回成功或失败的布尔值，后续由调用者自行处理。只不过我们最常用的处理方式是重试而已。</p>
<p>第二，这句话很容易理解错，被理解成重新比较并交换。实际上失败的时候，原值已经被修改，如果不更改期望值，再怎么比较都会失败。而新值同样需要修改。</p>
<h6 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h6><p> CAS 主要分三步，读取-比较-修改。其中比较是在检测是否有冲突，如果检测到没有冲突后，其他线程还能修改这个值，那么 CAS 还是无法保证正确性。所以最关键的是要保证比较-修改这两步操作的原子性。</p>
<p>CAS 底层是靠调用 CPU 指令集的 cmpxchg 完成的，它是 x86 和 Intel 架构中的 compare and exchange 指令。在多核的情况下，这个指令也不能保证原子性，需要在前面加上  lock 指令。lock 指令可以保证一个 CPU 核心在操作期间独占一片内存区域。那么 这又是如何实现的呢？</p>
<p>在处理器中，一般有两种方式来实现上述效果：总线锁和缓存锁。在多核处理器的结构中，CPU 核心并不能直接访问内存，而是统一通过一条总线访问。总线锁就是锁住这条总线，使其他核心无法访问内存。这种方式代价太大了，会导致其他核心停止工作。而缓存锁并不锁定总线，只是锁定某部分内存区域。当一个 CPU 核心将内存区域的数据读取到自己的缓存区后，它会锁定缓存对应的内存区域。锁住期间，其他核心无法操作这块内存区域。</p>
<p>CAS 就是通过这种方式实现比较和交换操作的原子性的。</p>
<p><strong>值得注意的是， CAS 只是保证了操作的原子性，并不保证变量的可见性，因此变量需要加上 volatile 关键字。</strong> </p>
<h6 id="CAS-的缺点"><a href="#CAS-的缺点" class="headerlink" title="CAS 的缺点"></a>CAS 的缺点</h6><p><strong>1、CPU 开销大</strong></p>
<p>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给 CPU 带来很大的压力。</p>
<p><strong>2、不能保证代码块的原子性</strong></p>
<p>CAS 机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如：需要保证3个变量共同进行原子性的更新，就不得不使用 Synchronized 了。 </p>
<p><strong>3、ABA 问题</strong></p>
<p>上面提到，CAS 保证了比较和交换的原子性。但是从读取到开始比较这段期间，其他核心仍然是可以修改这个值的。如果核心将 A 修改为 B，CAS 可以判断出来。但是如果核心将 A 修改为 B 再修改回 A。那么 CAS 会认为这个值并没有被改变，从而继续操作。这是和实际情况不符的。解决方案是加一个版本号。</p>
<p>ABA 问题的解决：</p>
<ul>
<li><p>使用 AtomicStampedReference 解决  AtomicInteger 的 ABA 问题。</p>
</li>
<li><p>因为 AtomicStampedReference 内部维护了一个 int 值作为版本号。</p>
<p>（ 还有一个 AtomicMarkableReference ，维护了一个 Boolean 值，它并不能解决 ABA 的问题 ，因为它本质就是只有 true 和 false 两种版本来回切换，只能降低 ABA 问题发生的几率 ）</p>
</li>
</ul>
<h5 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h5><blockquote>
<p>AQS 全拼：AbstractQueuedSynchronizer，即：排队同步器 。</p>
</blockquote>
<h4 id="c、volatile"><a href="#c、volatile" class="headerlink" title="c、volatile"></a>c、volatile</h4><p><strong>功能：</strong></p>
<ul>
<li><p>保证内存可见性</p>
</li>
<li><p>防止指令重排</p>
<p>通过<code>“内存屏障”</code>来防止指令被重排序。</p>
</li>
</ul>
<h4 id="d、悲观锁与乐观锁"><a href="#d、悲观锁与乐观锁" class="headerlink" title="d、悲观锁与乐观锁"></a>d、悲观锁与乐观锁</h4><h5 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a>悲观锁：</h5><ul>
<li><p>Synchronized</p>
</li>
<li><p>Lock</p>
</li>
</ul>
<h5 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h5><blockquote>
<p>在“写（增删改）”时，会判断数据是否被“写”过：</p>
<ul>
<li><p>是：</p>
<p>再次尝试写</p>
</li>
<li><p>否：</p>
<p>写完成</p>
</li>
</ul>
</blockquote>
<p><strong>底层实现：</strong></p>
<ul>
<li><p>第一种：版本号</p>
<p>当写时，若版本号比自己要写进去的版本号小，则将数据和新的版本号写进去。</p>
</li>
<li><p>第二种：CAS</p>
<p>当写时，判断数据是否与预期一样，一样则进行写，否则重试再写</p>
</li>
</ul>
<h3 id="4、死锁"><a href="#4、死锁" class="headerlink" title="4、死锁"></a>4、死锁</h3><blockquote>
<p>多个进程因竞争资源，而造成的互相等待现象 。</p>
</blockquote>
<p><strong>死锁的产生 :</strong></p>
<ul>
<li>资源分配不当</li>
<li>进程推进顺序不当</li>
</ul>
<p><strong>死锁的预防 :</strong></p>
<blockquote>
<p>破坏死锁产生的四个必要条件</p>
</blockquote>
<ul>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不可抢占条件</li>
<li>循环等待条件</li>
</ul>
<p><strong>避免死锁 :</strong></p>
<ul>
<li>银行家算法</li>
<li>安全序列</li>
</ul>
<p><strong>解除死锁 :</strong></p>
<ul>
<li>重启</li>
<li>终止死锁进程</li>
</ul>
<h3 id="5、线程同步"><a href="#5、线程同步" class="headerlink" title="5、线程同步"></a>5、线程同步</h3><h2 id="五、Java-虚拟机"><a href="#五、Java-虚拟机" class="headerlink" title="五、Java 虚拟机"></a>五、Java 虚拟机</h2><h3 id="1、JVM-运行时数据区"><a href="#1、JVM-运行时数据区" class="headerlink" title="1、JVM 运行时数据区"></a>1、JVM 运行时数据区</h3><blockquote>
<p>整个堆大小 = 年轻代大小 + 年老代大小 + 持久代大小</p>
</blockquote>
<p><img src="%E3%80%90%20Interview%20%E3%80%91/JVM%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="JVM 运行时数据区"></p>
<h3 id="2、方法区-与-永久代"><a href="#2、方法区-与-永久代" class="headerlink" title="2、方法区 与 永久代"></a>2、方法区 与 永久代</h3><blockquote>
<p>方法区是 JVM 规范概念，而 永久代 则是 Hotspot 虚拟机特有的概念 。 是方法区的一种实现，别的 JVM 都没有这个东西 。</p>
</blockquote>
<p>在 JDK1.8 后，永久代被移除，永久代中的信息存放在了元空间 ( 元数据区 ) 。</p>
<p><strong>两者最大的区别：</strong></p>
<ul>
<li>元空间并不在虚拟机中，而是使用本地内存。</li>
</ul>
<p>因此，默认情况下元空间是不受虚拟机内存大小的限制的，只受到系统内存的限制。</p>
<p><strong>但可以通过以下参数来指定元空间的大小：</strong></p>
<ul>
<li><p><code>-XX:MetaspaceSize</code> :</p>
<p>初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值 。</p>
</li>
<li><p><code>-XX:MaxMetaspaceSize</code> :</p>
<p>最大空间，默认是没有限制的 。</p>
</li>
</ul>
<p>除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：</p>
<ul>
<li><p><code>-XX:MinMetaspaceFreeRatio</code> :</p>
<p>在GC之后，最小的 Metaspace 剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 。</p>
</li>
<li><p><code>-XX:MaxMetaspaceFreeRatio</code> :</p>
<p>在GC之后，最大的 Metaspace 剩余空间容量的百分比，减少为释放空间所导致的垃圾收集 。</p>
</li>
</ul>
<p><strong>采用元空间而不用永久代的几点原因：</strong> </p>
<ul>
<li><p>字符串存在永久代中，容易出现性能问题和内存溢出</p>
</li>
<li><p>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出（ 因为堆空间有限，此消彼长 ）</p>
</li>
<li><p>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低</p>
</li>
<li><p>Oracle 可能会将 HotSpot 与 JRockit 合二为一</p>
</li>
</ul>
<h3 id="3、JVM-参数"><a href="#3、JVM-参数" class="headerlink" title="3、JVM 参数"></a>3、JVM 参数</h3><blockquote>
<ul>
<li><p>Xms            起始内存</p>
</li>
<li><p>Xmx            最大内存</p>
</li>
<li><p>Xmn            新生代内存</p>
</li>
<li><p>Xss              每个线程的栈大小</p>
</li>
</ul>
<ul>
<li><p>-XX : NewRatio = n</p>
<p>  设置年轻代和年老代的比值。如 : 为3，表示年轻代与年老代比值为 1 : 3，年轻代占整个年轻代年老代和的 1/4</p>
</li>
<li><p>-XX : SurvivorRatio = n</p>
<p>  年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。如 : 3，表示 Eden : Survivor = 3 : 2，一个 Survivor 区占整个年轻代的 1/5</p>
</li>
<li><p>-XX : MaxPermSize = n</p>
<p>  设置永久代大小</p>
</li>
</ul>
<p>收集器设置</p>
<ul>
<li><p>-XX : +UseSerialGC                                设置串行收集器</p>
</li>
<li><p>-XX : +UseParallelGC                             设置并行收集器</p>
</li>
<li><p>-XX : +UseParalledlOldGC                    设置并行年老代收集器</p>
</li>
<li><p>-XX : +UseConcMarkSweepGC            设置并发收集器</p>
</li>
</ul>
<p>垃圾回收统计信息</p>
<ul>
<li>-XX : +PrintGC</li>
<li>-XX : +PrintGCDetails</li>
<li>-XX : +PrintGCTimeStamps</li>
<li>-Xloggc : filename</li>
</ul>
<p>并行收集器设置</p>
<ul>
<li>-XX : ParallelGCThreads=n            设置并行收集器收集时使用的CPU数。并行收集线程数。</li>
<li>-XX : MaxGCPauseMillis=n            设置并行收集最大暂停时间</li>
<li>-XX : GCTimeRatio=n                      设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</li>
</ul>
<p>并发收集器设置</p>
<ul>
<li>-XX : +CMSIncrementalMode            设置为增量模式。适用于单CPU情况。</li>
<li>-XX : ParallelGCThreads=n                 设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</li>
</ul>
<p>选项 :</p>
<ul>
<li><p>-XX : +UseCompressedOops</p>
<blockquote>
<p>所谓 Oops 是指 “ordinary object pointers“ ，就是原始指针。</p>
<p>Java Runtime 可以用这个指 针直接访问指针对应的内存，做相应的操作 ( 比如发起 GC 时做 copy and sweep ）。</p>
<p><strong>Compressed 是啥意思 ？</strong></p>
<p>64bit 的 JVM 出现后，OOPS 的尺寸也变成了 64bit，比之前的大了一倍。这会引入性能损耗 —— 占的内存 double 了，并且同尺寸的 CPU Cache 要少存一倍的 OOPS 。</p>
<p>于是就有了 UseCompressedOops 这个选项。打开后，OOPS 变成了 32bit。但 32bit 的 base 是8，所以能引用的空间是 32GB —— 这远大于目前经常给 jvm 进程内存分配的空间 。</p>
<blockquote>
<p>一般建议不要给 JVM 太大的内存，因为 Heap 太大，GC 停顿实在是太久了。所以很多开发者喜欢在大内存机器上开多个 JVM 进程，每个给比如最大 8G 以下的内存 。</p>
</blockquote>
<p>从 JDK6_u23 开始 UseCompressedOops 被默认打开了。因此既能享受 64bit 带来的好处，又避免了 64bit 带来的性能损耗 。</p>
<p>当然，如果你有机会使用超过 32G 的堆内存，记得把这个选项关了。</p>
<p>到了 Java8，永久代被干掉了，有了 “ meta space ” 的概念，存储 jvm 中的元数据，包括 byte code，class 等信息 。</p>
<p>Java8 在 UseCompressedOops 之外，额外增加了一个新选项叫做UseCompressedClassPointer 。这个选项打开后，class 信息中的指针也用 32bit 的 Compressed 版本。而这些指针指向的空间被称作 “ Compressed Class Space ” 。默认大小是1G，但可以通过 “ CompressedClassSpaceSize ” 调整 。</p>
<p>如果你的 java 程序引用了太多的包，有可能会造成这个空间不够用，于是会看到</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Compressed class space</span><br></pre></td></tr></table></figure>

<p>这时，一般调大 CompreseedClassSpaceSize 就可以了 。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="4、对象内存申请"><a href="#4、对象内存申请" class="headerlink" title="4、对象内存申请"></a>4、对象内存申请</h3><p><img src="%E3%80%90%20Interview%20%E3%80%91/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7.png" alt="对象内存申请"></p>
<h3 id="5、内存泄漏-与-内存溢出"><a href="#5、内存泄漏-与-内存溢出" class="headerlink" title="5、内存泄漏 与 内存溢出"></a>5、内存泄漏 与 内存溢出</h3><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><blockquote>
<p>是指程序在申请内存后，无法释放已申请的内存空间 .</p>
<p>一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光</p>
</blockquote>
<p><strong>内存泄漏可以分为四类 :</strong></p>
<ul>
<li><p>常发性内存泄漏</p>
<p>发生内存泄漏的代码会被多次执行到，每次执行都会导致内存泄漏</p>
</li>
<li><p>偶发性内存泄漏</p>
<p>发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生，</p>
</li>
<li><p>一次性内存泄漏</p>
<p>发生内存泄漏的代码只会被执行一-次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏</p>
</li>
<li><p>隐式内存泄漏</p>
<p>程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存</p>
</li>
</ul>
<p><strong>内存泄漏问题调查定位 :</strong></p>
<ul>
<li><a href="https://www.jianshu.com/p/e0bae5d40bc1" target="_blank" rel="noopener">Jmap 与 Jstack 的使用</a></li>
</ul>
<h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><blockquote>
<p>是指程序在申请内存时，没有足够的内存空间供其使用，出现 <code>out of memory</code></p>
<p>比如申请了一个 integer，但给它存了 long 才能存下的数，那就是内存溢出</p>
</blockquote>
<p>内存溢出分为三种情况 :</p>
<ul>
<li><p><code>OutOfMemoryError : PermGen space</code></p>
<blockquote>
<p>Permanent Generation space 这个区域主要用来保存加来的 Class 的一些信息，在程序运行期间属于永久占用的，Java 的 GC 不会对他进行释放，所以如果启动的程序加载的信息比较大，超出了这个空间的大小，就会发生溢出错误</p>
</blockquote>
<p>解决办法 :</p>
<p>增加空间分配了 , 即增加 java 虚拟机中的 <code>XX:PermSize</code> ( 初始永久保存区域大小 ) 和 <code>XX:MaxPermSize</code> 参数的大小</p>
</li>
<li><p><code>OutOfMemoryError : Java heap space</code></p>
<blockquote>
<p>heap 是 Java 内存中的堆区，主要用来存放对象，当对象太多超出了空间大小，GC 又来不及释放的时候，就会发生溢出错误 .</p>
<p>Java 中对象的创建是可控的，但是对象的回收是由 GC 自动的，一般来说，当已存在对象没有引用(即不可达)的时候，GC 就会定时的来回收对象，释放空间。但是因为程序的设计问题，导致对象可达但是又没有用 ( 即前文提到的内存泄露 )，当这种情况越来越多的时候，就会发生内存溢出 .</p>
</blockquote>
<p>解决办法 :</p>
<ul>
<li>增加 Java 虚拟机中 Xms ( 初始堆大小 ) 和 Xmx ( 最大堆大小 ) 参数的大小</li>
<li>检查程序，减少大量重复创建对象的死循环，减少内存泄露</li>
</ul>
</li>
<li><p><code>StackOverFlowError</code></p>
<blockquote>
<p>stack 是 Java 内存中的栈空间，主要用来存放方法中的变量，参数等临时性的数据的，发生溢出一般是因为分配空间太小，或是执行的方法递归层数太多创建了占用了太多栈帧导致溢出</p>
</blockquote>
<p>解决办法 :</p>
<p>针对这个问题，除了修改配置参数 -Xss 参数增加线程栈大小之外，优化程序是尤其重要</p>
</li>
</ul>
<h3 id="6、获取-Java-程序使用的内存"><a href="#6、获取-Java-程序使用的内存" class="headerlink" title="6、获取 Java 程序使用的内存"></a>6、获取 Java 程序使用的内存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().maxMemory(); <span class="comment">// 当前虚拟机进程从操作系统可申请的最大内存容量</span></span><br><span class="line">Runtime.getRuntime().freeMemory(); <span class="comment">// 当前虚拟机进程从操作系统申请的内存空余量</span></span><br><span class="line">Runtime.getRuntime().totalMemory(); <span class="comment">// 当前虚拟机进程从操作系统申请的内存大小</span></span><br></pre></td></tr></table></figure>

<h3 id="7、GC"><a href="#7、GC" class="headerlink" title="7、GC"></a>7、GC</h3><blockquote>
<p><code>System.gc()</code> 只是 <code>Runtime.getRuntime().gc()</code> 的简写</p>
<ul>
<li><code>System.gc()</code></li>
<li><code>Runtime.getRuntime().gc()</code></li>
</ul>
</blockquote>
<h4 id="a、GC-分类"><a href="#a、GC-分类" class="headerlink" title="a、GC 分类"></a>a、GC 分类</h4><blockquote>
<p><strong>Minor GC</strong></p>
<ul>
<li>年轻代 GC</li>
</ul>
<p><strong>Major GC</strong></p>
<ul>
<li>老年代 GC</li>
</ul>
<p><strong>Full GC</strong></p>
<ul>
<li>清理整个堆空间</li>
</ul>
</blockquote>
<p>Full GC 经常会伴随至少一次 Minor GC ( 但并非绝对 , 在 Parallel Scavenge 收集器的收集策略中就有直接进行 Full GC 的策略选择过程 )</p>
<p>Full GC 一般会比 Minor GC 慢 10 倍以上</p>
<h4 id="b、GC-过程"><a href="#b、GC-过程" class="headerlink" title="b、GC 过程"></a>b、GC 过程</h4><p><img src="%E3%80%90%20Interview%20%E3%80%91/GC%20%E8%BF%87%E7%A8%8B.png" alt="GC 过程"></p>
<h4 id="c、GC-Roots"><a href="#c、GC-Roots" class="headerlink" title="c、GC Roots"></a>c、GC Roots</h4><p>可作为 GC Roots 的对象 :</p>
<ul>
<li>虚拟机栈 ( 栈帧中的本地变量表 ) 中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI ( 即一般所说的 Native 方法 ) 引用的对象</li>
</ul>
<h4 id="d、引用"><a href="#d、引用" class="headerlink" title="d、引用"></a>d、引用</h4><h5 id="强引用-StrongReference"><a href="#强引用-StrongReference" class="headerlink" title="强引用    StrongReference"></a>强引用    <code>StrongReference</code></h5><blockquote>
<p>强引用还存在对象就不会被回收</p>
</blockquote>
<p><code>Objectobj = new Object()</code> </p>
<h5 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用    SoftReference"></a>软引用    <code>SoftReference</code></h5><blockquote>
<p>被软引用关联的对象当内存不足时会回收</p>
</blockquote>
<p><strong>实现 :</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">sf.get(); <span class="comment">// 有时候会返回 null</span></span><br></pre></td></tr></table></figure>

<p>这时候 sf 是对 obj 的一个软引用，通过 <code>sf.get()</code> 方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回 null ；</p>
<p><strong>主要作用 :</strong></p>
<p>软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据 。</p>
<h5 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用    WeakReference"></a>弱引用    <code>WeakReference</code></h5><blockquote>
<p>被弱引用关联的对象只能生存到下一次垃圾收集发生之前</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">wf.get(); <span class="comment">// 有时候会返回 null</span></span><br><span class="line"></span><br><span class="line">wf.isEnQueued(); <span class="comment">// 返回是否被垃圾回收器标记为即将回收的垃圾</span></span><br></pre></td></tr></table></figure>

<p><strong>主要作用 :</strong></p>
<p>弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的 isEnQueued 方法返回对象是否被垃圾回收器 。</p>
<h5 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用    PhantomReference"></a>虚引用    <code>PhantomReference</code></h5><blockquote>
<p>为一个对象设置虚引用关联的唯一目的 : 能在该对象回收时收到一个系统通知</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj);</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">pf.get(); <span class="comment">// 永远返回 null</span></span><br><span class="line"></span><br><span class="line">pf.isEnQueued(); <span class="comment">// 返回从内存中已经删除</span></span><br></pre></td></tr></table></figure>

<p>通过虚引用的 get 方法永远获取到的数据为 null，因此也被成为幽灵引用 。</p>
<p><strong>主要作用 :</strong></p>
<p>虚引用主要用于检测对象是否已经从内存中删除 。</p>
<h4 id="e、垃圾收集器"><a href="#e、垃圾收集器" class="headerlink" title="e、垃圾收集器"></a>e、垃圾收集器</h4><blockquote>
<ul>
<li><p>用户交互 :</p>
<p>缩短 GC 停顿</p>
</li>
<li><p>吞吐量 :</p>
<p>吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )</p>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>收集器</th>
<th>运行模式</th>
<th>常用区</th>
<th>垃圾收集算法</th>
<th>适用场景</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>单线程<br />阻塞</td>
<td>新生代</td>
<td>复制</td>
<td>运行在 Client 模式下的默认新生代收集器</td>
<td></td>
</tr>
<tr>
<td>ParNew<br />( Serial 的多线程版 )</td>
<td>多线程<br />阻塞</td>
<td>新生代</td>
<td>复制</td>
<td>运行在 Server 模式下的首选新生代收集器<br />线程数 = CPU 数</td>
<td></td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>多线程<br />阻塞</td>
<td>新生代</td>
<td>复制</td>
<td>Parallel Scavenge 的 GC自适应调节策略 是其与 ParNew 的重要区别</td>
<td>吞吐量优先</td>
</tr>
<tr>
<td>Serial Old</td>
<td>单线程<br />阻塞</td>
<td>老年代</td>
<td>标记 - 整理</td>
<td>主要意义是给运行在 Client 模式下的虚拟机使用<br />或作为 CMS 收集器的后备预案 , 在并发收集发生 Concurrent Mode Failure ( 并发模式故障 ) 时使用</td>
<td></td>
</tr>
<tr>
<td>Parallel Old</td>
<td>多线程<br />阻塞</td>
<td>老年代</td>
<td>标记 - 整理</td>
<td></td>
<td>吞吐量优先</td>
</tr>
<tr>
<td>CMS<br />( Concurrent Mark Sweep )</td>
<td>多线程<br />并行</td>
<td>老年代</td>
<td>标记 - 清除</td>
<td>集中在互联网站或 B/S 系统服务端上的 Java 应用</td>
<td></td>
</tr>
<tr>
<td>G1<br />( Garbage-First )</td>
<td>多线程<br />并行</td>
<td>both</td>
<td>标记 - 整理 + 复制算法</td>
<td>面向服务端应用，将来替换 CMS</td>
<td></td>
</tr>
</tbody></table>
<p><img src="%E3%80%90%20Interview%20%E3%80%91/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="垃圾收集器"></p>
<p><img src="%E3%80%90%20Interview%20%E3%80%91/CMS%20%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="CMS 收集器"></p>
<p><img src="%E3%80%90%20Interview%20%E3%80%91/G1%20%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="G1 收集器"></p>
<h4 id="f、JVM-垃圾回收算法"><a href="#f、JVM-垃圾回收算法" class="headerlink" title="f、JVM 垃圾回收算法"></a>f、JVM 垃圾回收算法</h4><ul>
<li><p><strong>标记 - 清除</strong></p>
<ul>
<li><p>它的不足之处在于：</p>
<p>1、标记、清除的效率都不高。</p>
<p>2、清除后产生大量的内存碎片，空间碎片太多会导致在分配大对象时无法找到足够大的连续内存，从而不得不触发另一次垃圾回收动作。</p>
</li>
</ul>
</li>
<li><p><strong>复制</strong></p>
<ul>
<li><p>优点：</p>
<p>因为是对整个半区进行内存回收，内存分配时不用考虑内存碎片等情况。实现简单，效率较高。</p>
</li>
<li><p>不足之处：</p>
<p>既然要复制，需要提前预留内存空间，有一定的浪费。</p>
<p>在对象存活率较高时，需要复制的对象较多，效率将会变低。</p>
</li>
</ul>
</li>
<li><p><strong>标记 - 整理</strong></p>
<ul>
<li><p>优点：</p>
<p>消除了标记清除导致的内存分散问题，也消除了复制算法中内存减半的高额代价。</p>
</li>
<li><p>不足之处：</p>
<p>效率低下，需要标记所有存活对象，还要标记所有存活对象的引用地址。效率上低于复制算法。</p>
</li>
</ul>
</li>
<li><p><strong>分代</strong></p>
<ul>
<li>新生代 : 复制</li>
<li>老年代 : 标记 - 清除    /    标记 - 整理</li>
</ul>
</li>
</ul>
<h4 id="g、一个对象的回收"><a href="#g、一个对象的回收" class="headerlink" title="g、一个对象的回收"></a>g、一个对象的回收</h4><p><img src="%E3%80%90%20Interview%20%E3%80%91/%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%20GC.png" alt="一个对象的 GC"></p>
<h4 id="N、问题-1"><a href="#N、问题-1" class="headerlink" title="N、问题"></a>N、问题</h4><h5 id="GC-对程序的影响："><a href="#GC-对程序的影响：" class="headerlink" title="GC 对程序的影响："></a>GC 对程序的影响：</h5><p>会导致应用程序变慢，吞吐量降低</p>
<h5 id="频繁-Full-GC-怎么办："><a href="#频繁-Full-GC-怎么办：" class="headerlink" title="频繁 Full GC 怎么办："></a>频繁 Full GC 怎么办：</h5><p>首先用命令查看触发 GC 的原因是什么：jstat –gccause 进程id</p>
<ul>
<li>如果是 System.gc()，则看下代码哪里调用了这个方法</li>
<li>如果是 heap inspection ( 内存检查 )，可能是哪里执行 <code>jmap –histo[:live]</code> 命令</li>
<li>如果是 GC locker，可能是程序依赖的 JNI 库的原因</li>
</ul>
<h2 id="六、数据库"><a href="#六、数据库" class="headerlink" title="六、数据库"></a>六、数据库</h2><h3 id="1、范式"><a href="#1、范式" class="headerlink" title="1、范式"></a>1、范式</h3><table>
<thead>
<tr>
<th align="center">范式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">第一范式（ 1NF ）</td>
<td>每一列都是不可分割的原子数据项</td>
</tr>
<tr>
<td align="center">第二范式（ 2NF ）</td>
<td>在 1NF 的基础上，非码属性必须完全依赖于码（在 1NF 基础上消除非主属性对主码的部分函数依赖）</td>
</tr>
<tr>
<td align="center">第三范式（ 3NF ）</td>
<td>在 2NF 基础上，任何非主属性不依赖于其它非主属性（在 2NF 基础上消除传递依赖）</td>
</tr>
<tr>
<td align="center">巴斯—科德范式（ BCNF ）</td>
<td></td>
</tr>
<tr>
<td align="center">第四范式（ 4NF ）</td>
<td></td>
</tr>
<tr>
<td align="center">第五范式（ 5NF ）（又称完美范式）</td>
<td></td>
</tr>
</tbody></table>
<h3 id="2、索引"><a href="#2、索引" class="headerlink" title="2、索引"></a>2、索引</h3><blockquote>
<p>索引是对数据库表中一列或多列的值进行排序的结构 , 是帮助数据库高速获取数据的数据结构 , 简单理解为数据库中加快检索表中数据的方法</p>
</blockquote>
<h3 id="3、隔离级别"><a href="#3、隔离级别" class="headerlink" title="3、隔离级别"></a>3、隔离级别</h3><p><img src="%E3%80%90%20Interview%20%E3%80%91/%E4%B8%8D%E5%90%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="不同隔离级别可能导致的问题"></p>
<h3 id="4、Drop-、delete-、truncate"><a href="#4、Drop-、delete-、truncate" class="headerlink" title="4、Drop 、delete 、truncate"></a>4、Drop 、delete 、truncate</h3><blockquote>
<p>速度 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop &gt; truncate &gt; delete</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Drop</p>
<p>drop 语句将删除表的结构 , 以及被依赖的约束 ( constrain) , 触发器 ( trigger ) , 索引 ( index ) ;</p>
<p>依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid</p>
</li>
<li><p>delete <code>可恢复</code></p>
<p>表中记录一条一条删 , 并记录日志以便恢复 , 不删除表结构</p>
</li>
<li><p>truncate</p>
<p>直接删除表中所有记录 , 不删除表结构 , 并且不会激活与表有关的删除触发器</p>
</li>
</ul>
</blockquote>
<h3 id="5、varchar-与-char-的区别"><a href="#5、varchar-与-char-的区别" class="headerlink" title="5、varchar 与 char 的区别 :"></a>5、varchar 与 char 的区别 :</h3><blockquote>
<p><em>char(1) 和 varchar(1) 的区别 ？</em></p>
<p>两个都只能保存单个字符，但是 varchar 要多占一个或两个存储位置用来记录存储长度信息 。</p>
</blockquote>
<ol>
<li><p>char 是固定长度 , varchar 长度可变 ;</p>
</li>
<li><p>char 的存储方式是：英文字符占1个字节，汉字占用2个字节；</p>
<p>varchar 的存储方式是：英文和汉字都占用2个字节；</p>
<p>两者的存储数据都非 unicode 的字符数据 。 </p>
</li>
</ol>
<h3 id="6、varchar-50-中-50-的涵义"><a href="#6、varchar-50-中-50-的涵义" class="headerlink" title="6、varchar(50) 中 50 的涵义 :"></a>6、varchar(50) 中 50 的涵义 :</h3><p>最多存放50个字符，varchar(50) 和 (200) 存储 hello 所占空间一样，但后者在排序时会消耗更多内存，因为order by col 采用 fixed_length 计算 col 长度 ( memory 引擎也一样 )</p>
<h2 id="七、网络编程"><a href="#七、网络编程" class="headerlink" title="七、网络编程"></a>七、网络编程</h2><h3 id="1、负载均衡算法"><a href="#1、负载均衡算法" class="headerlink" title="1、负载均衡算法"></a>1、负载均衡算法</h3><h4 id="a、轮询法"><a href="#a、轮询法" class="headerlink" title="a、轮询法"></a>a、轮询法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">轮询法,很好理解,将请求按照顺序轮流的分配到服务器上,他均衡的对待每一台后端的服务器,</span><br><span class="line">不关心服务器的的连接数和负载情况.以下代码演示了这种算法.</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalanceServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; servers = Arrays.asList(<span class="string">"192.168.0.1"</span>, <span class="string">"192.168.0.2"</span>, <span class="string">"192.168.0.3"</span>, <span class="string">"192.168.0.4"</span>, <span class="string">"192.168.0.5"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String server = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= servers.size()) &#123;</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server = servers.get(pos);</span><br><span class="line">        pos++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(BalanceServer.getServer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">轮询的策略目的在于请求的绝对均衡,但是在实际的情况下,可能服务器并不是完全一样.</span><br><span class="line">导致有些性能高的服务器不能完全发挥出来.</span><br></pre></td></tr></table></figure>

<h4 id="b、随机法"><a href="#b、随机法" class="headerlink" title="b、随机法"></a>b、随机法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">通过系统的随机函数,根据后端服务器列表的大小来随机获取其中的一台来访问,随着调用量的增大,</span><br><span class="line">实际效果越来越近似于平均分配到没一台服务器.和轮询的效果类似.</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalanceServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; servers = Arrays.asList(<span class="string">"192.168.0.1"</span>, <span class="string">"192.168.0.2"</span>, <span class="string">"192.168.0.3"</span>, <span class="string">"192.168.0.4"</span>, <span class="string">"192.168.0.5"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String server = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> randomPos = random.nextInt(servers.size());</span><br><span class="line">        </span><br><span class="line">        server = servers.get(randomPos);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">和轮询算法比较,在并发的场景下,轮询需要加锁,随机法想比而言性能好点.</span><br></pre></td></tr></table></figure>

<h4 id="c、源地址-hash-法"><a href="#c、源地址-hash-法" class="headerlink" title="c、源地址 hash 法"></a>c、源地址 hash 法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">源地址hash法的思想是获取客户端访问的ip地址,通过hash函数计算出一个hash值,用该hash值对服</span><br><span class="line">务器列表的大小进行取模运算,得到的值就是要访问的服务器的序号.</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalanceServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; servers = Arrays.asList(<span class="string">"192.168.0.1"</span>, <span class="string">"192.168.0.2"</span>, <span class="string">"192.168.0.3"</span>, <span class="string">"192.168.0.4"</span>, <span class="string">"192.168.0.5"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">(String ip)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String server = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> hashCode = ip.hashCode();</span><br><span class="line">        pos = hashCode % servers.size();</span><br><span class="line">        </span><br><span class="line">        server = servers.get(pos);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hash法的好处是,在服务器列表不变的情况下,每次客户端访问的服务器都是同一个服务器.利用这个</span><br><span class="line">特性可以有状态的session会话.无需额外的操作就可以实现粘性会话.</span><br></pre></td></tr></table></figure>

<h4 id="d、加权轮询法"><a href="#d、加权轮询法" class="headerlink" title="d、加权轮询法"></a>d、加权轮询法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">刚刚有说道过,不同的服务器性能不同,所以不能一概而论,</span><br><span class="line">需要给性能低的服务器给比较低的权重,性能高的给跟高的权重.</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalanceServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; serverMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        serverMap.put(<span class="string">"192.168.0.1"</span>, <span class="number">1</span>);</span><br><span class="line">        serverMap.put(<span class="string">"192.168.0.2"</span>, <span class="number">1</span>);</span><br><span class="line">        serverMap.put(<span class="string">"192.168.0.3"</span>, <span class="number">4</span>);</span><br><span class="line">        serverMap.put(<span class="string">"192.168.0.4"</span>, <span class="number">3</span>);</span><br><span class="line">        serverMap.put(<span class="string">"192.168.0.5"</span>, <span class="number">3</span>);</span><br><span class="line">        serverMap.put(<span class="string">"192.168.0.6"</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; keySet = serverMap.keySet();</span><br><span class="line">        Iterator&lt;String&gt; it = keySet.iterator();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; servers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            String server = it.next();</span><br><span class="line">            Integer weight = serverMap.get(server);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight; i++) &#123;</span><br><span class="line">                servers.add(server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String server = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= servers.size()) &#123;</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server = servers.get(pos);</span><br><span class="line">        pos++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">14</span>;i++)&#123;</span><br><span class="line">            System.out.println(BalanceServer.getServer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="e、加权随机法"><a href="#e、加权随机法" class="headerlink" title="e、加权随机法"></a>e、加权随机法</h4><blockquote>
<p>加权随机法算法和加权轮询法类似.就不多说了. </p>
</blockquote>
<h4 id="f-、有关hash算法的一些补充说明"><a href="#f-、有关hash算法的一些补充说明" class="headerlink" title="f 、有关hash算法的一些补充说明"></a>f 、有关hash算法的一些补充说明</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在上面的<span class="built_in">hash</span>算法中,存在以下的几个问题 ：</span><br><span class="line">1.	当一台服务器宕机了或者新添加一台机器之后,这个时候hashCode % servers.size()</span><br><span class="line"> 	需要重新计算<span class="built_in">hash</span>值, 如果在缓存的环境中,所有的请求都会涌向数据库服务器,</span><br><span class="line"> 	给数据库服务器带来巨大的压力,可能导致整个系统不可用,形成雪崩效应.</span><br><span class="line"></span><br><span class="line">2.	当新增了一台性能强的机器后,利用上述的<span class="built_in">hash</span>算法无法让新增的性能强的服务器多承担压力.</span><br><span class="line"></span><br><span class="line">基于上面的几个问题,提出了<span class="built_in">hash</span>算法的改进,consistent <span class="built_in">hash</span>算法,</span><br><span class="line">consistent <span class="built_in">hash</span> 也是一种 <span class="built_in">hash</span> 算法，简单的说，在移除/添加操作，它能够尽可能小的改变已存在 key 映射关系.</span><br><span class="line"></span><br><span class="line">consistent <span class="built_in">hash</span> 算法的原理是它将 <span class="built_in">hash</span> 函数的值域组织成一个环形,</span><br><span class="line">整个空间按照顺时针的方式进行组织,将对应的服务器节点进行<span class="built_in">hash</span>,将他们映射到<span class="built_in">hash</span>环上,</span><br><span class="line">假设有四台机器node1-4,<span class="built_in">hash</span>之后如图所示 ：</span><br></pre></td></tr></table></figure>

<p><img src="%E3%80%90%20Interview%20%E3%80%91/consistent%20hash.png" alt="consistent hash"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接下来使用相同的 <span class="built_in">hash</span> 函数,计算出对应的 key 值和 <span class="built_in">hash</span> 值,按照顺时针的方式,分布在 node1 和 node2 </span><br><span class="line">的 key,访问时被定位在 node2,分布在 node2 和 node4 的 key 被定位在 node4 上.</span><br><span class="line">以此类推,假设现在新增一个 node5,假设 <span class="built_in">hash</span> 之后在 node2 和 node4 之间,如图所示:</span><br></pre></td></tr></table></figure>

<p><img src="%E3%80%90%20Interview%20%E3%80%91/%E6%96%B0%E5%A2%9Enode.png" alt="新增node"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">那么受影响的节点只有 node2 和 node5,他们将会从新 <span class="built_in">hash</span>,而其他的 key 的映射将不会变化.</span><br><span class="line">当然,上面描绘了一种很理想的情况,各个节点在环上分布的十分均匀.</span><br><span class="line">正常情况下,当节点数量少的时候,节点分布并不均匀,这时需要引入虚拟节点机制.</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/sparkliang/article/details/5279393" target="_blank" rel="noopener">关于 consistent hash 算法</a></p>
<h2 id="八、框架"><a href="#八、框架" class="headerlink" title="八、框架"></a>八、框架</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="1、什么是-Spring"><a href="#1、什么是-Spring" class="headerlink" title="1、什么是 Spring"></a>1、什么是 Spring</h4><p>Spring 是一个轻量级开发框架，使用它可以提高开发人员的开发效率以及系统的可维护性，我们一般所说的 Spring 框架指的是 Spring Framework ，它是基于模块化设计的，比较常用的模块有：Spring Core、Spring AOP、Spring JDBC、Spring ORM、Spring Web、Spring Test 等。</p>
<p><img src="%E3%80%90%20Interview%20%E3%80%91/Spring5%20%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png" alt="Spring5 系统架构"></p>
<p><strong>Spring Core</strong> 与 <strong>Spring Beans</strong>：</p>
<ul>
<li>提供了框架的基础功能，包括 IOC 和 DI（依赖注入）功能。</li>
</ul>
<p><strong>Spring Context</strong>：</p>
<ul>
<li>建立在 Core 和 Beans 提供的基础上，并添加了更多的功能，如：国际化、事件传播、等。</li>
</ul>
<p>Spring Expression：</p>
<ul>
<li>提供了强大的表达式语言去执行查询和操作运行时对象图。这是对 JSP 2.1 规范中规定的统一表达式语言（unified EL）的扩展。 </li>
</ul>
<p><strong>Spring AOP</strong>：</p>
<ul>
<li>提供了面向切面编程的功能。</li>
</ul>
<p><strong>Spring Aspects</strong>：</p>
<ul>
<li>提供了与 AspectJ 的集成。</li>
</ul>
<p>Spring Instrument：</p>
<ul>
<li>提供了类植入(instrumentation)支持和类加载器的实现，可以应用在特定的应用服务器中。该 spring-instrument-tomcat 模块包含了支持 Tomcat 的植入代理。 </li>
</ul>
<p>Spring Messageing：</p>
<ul>
<li>包含来自 Spring Integration 的项目，例如：Message，MessageChannel，MessageHandler，和其他用来传输消息的基础应用。 </li>
</ul>
<p><strong>Spring JDBC</strong>：</p>
<ul>
<li>提供了一个 JDBC 抽象层。</li>
</ul>
<p><strong>Spring ORM</strong>： </p>
<ul>
<li>为流行的对象关系映射 API 提供集成层，包括 JPA 和 Hibernate。（ 用于支持 Hibernate、JPA 等 ORM 工具。）</li>
</ul>
<p>Spring OXM： </p>
<ul>
<li>提供了一个支持对象/ XML映射实现的抽象层，如：JAXB，Castor，JiBX 和 XStream。 </li>
</ul>
<p><strong>Spring JMS</strong>：</p>
<ul>
<li>Java 消息服务，提供了与 spring-messaging 模块的集成。 。</li>
</ul>
<p><strong>Spring Web</strong>：</p>
<ul>
<li>为创建 web 应用程序提供了支持。提供基本的面向 Web 的集成功能，例如：多部分文件上传功能、以及初始化一个使用了 Servlet 侦听器和面向 Web 的应用程序上下文的 IoC 容器。 </li>
</ul>
<p><strong>Spring WebMVC</strong>：</p>
<ul>
<li>包含用于 Web 应用程序的 Spring 的模型-视图-控制器(MVC)和 REST Web Services 实现。 </li>
</ul>
<p><strong>Spring Test</strong>：</p>
<ul>
<li>提供了 JUnit 和 TestNG 测试的支持。</li>
</ul>
<h4 id="2、IOC"><a href="#2、IOC" class="headerlink" title="2、IOC"></a>2、IOC</h4><blockquote>
<p>IOC：控制反转，是一种设计思想，这种思想将创建对象的控制权交由了 Spring 框架来管理，而不是在程序中由程序员进行手动 new 了。</p>
<p>IOC 在其它语言中也有应用，并非是 Spring 所特有的。</p>
</blockquote>
<h5 id="IOC-的实现原理："><a href="#IOC-的实现原理：" class="headerlink" title="IOC 的实现原理："></a>IOC 的实现原理：</h5><p>工厂模式 + 反射机制</p>
<h4 id="3、AOP"><a href="#3、AOP" class="headerlink" title="3、AOP"></a>3、AOP</h4><blockquote>
<p>AOP：面向切面编程，它是对 OOP 的补充，在 OOP 编程中会产生一些问题，如日志功能，统一异常处理等与业务逻辑无关的代码散落在代码各处，导致了大量代码的重复，也降低了程序的可维护性，而使用 AOP 技术可以将这些功能与业务逻辑解耦，从而提高代码的重用性和开发效率。</p>
</blockquote>
<h5 id="a、原理："><a href="#a、原理：" class="headerlink" title="a、原理："></a>a、<strong>原理：</strong></h5><p>代理模式</p>
<h5 id="b、方式："><a href="#b、方式：" class="headerlink" title="b、方式："></a>b、<strong>方式：</strong></h5><ul>
<li><p>Spring AOP</p>
<p><code>基于接口</code>：Spring AOP 会使用 JDK Proxy（基于反射机制实现）</p>
<p><code>基于类</code>：Spring AOP 会使用 Cglib（基于类继承机制实现）</p>
</li>
<li><p>AspectJ AOP</p>
</li>
</ul>
<p><strong>Spring AOP 与 AspectJ AOP 的区别：</strong></p>
<ul>
<li><p>Spring AOP 是运行时增强，AspectJ AOP 是编译时增强。</p>
</li>
<li><p>Spring AOP 基于代理，AspectJ AOP 基于字节码操作。</p>
</li>
</ul>
<h5 id="c、AOP-相关概念："><a href="#c、AOP-相关概念：" class="headerlink" title="c、AOP 相关概念："></a>c、AOP 相关概念：</h5><ul>
<li><p>Aspect（切面）：</p>
<p>一个关注点的模块化，这个关注点可能会横切多个对象。 </p>
</li>
<li><p>Joint point（连接点）：</p>
<p>程序执行过程中的一个点，如：方法的执行或异常的处理。在 Spring AOP 中，连接点始终表示方法执行。 </p>
</li>
<li><p>Pointcut（切点）：</p>
<p>表示一组连接点，这些连接点由切入点表达式来匹配。</p>
</li>
<li><p>Advice（通知）：</p>
<p>在切面上的某个特定的连接点上执行的代码。</p>
</li>
<li><p>Target（目标对象）：</p>
<p>要增强的对象。</p>
</li>
<li><p>Weaving（织入）：</p>
<p>将切面作用到目标对象，产生一个代理对象的过程。</p>
</li>
</ul>
<p><strong>通知：</strong></p>
<ul>
<li><p>前置通知（Before advice）：</p>
<p>在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。</p>
</li>
<li><p>后置通知（After returning advice）：</p>
<p>在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</p>
</li>
<li><p>异常通知（After throwing advice）：</p>
<p>在方法抛出异常退出时执行的通知。</p>
</li>
<li><p>最终通知（After (finally) advice）：</p>
<p>当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p>
</li>
<li><p>环绕通知（Around Advice）：</p>
<p>包围一个连接点的通知，如：方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</p>
</li>
</ul>
<h4 id="4、DI"><a href="#4、DI" class="headerlink" title="4、DI"></a>4、DI</h4><blockquote>
<p>DI：依赖注入，</p>
</blockquote>
<p><strong>三种方式：</strong></p>
<ul>
<li>构造方法</li>
<li>工厂方法</li>
<li>set 方法</li>
</ul>
<p><strong>注解：</strong></p>
<ul>
<li><p>@Autowired</p>
<p>注入 Bean</p>
</li>
<li><p>@Qualifier</p>
<p>注入 Bean ，给类成员注入时要搭配 @Autowired ，在自动的基础上再根据名称注入，给方法注入时，可单独使用</p>
</li>
<li><p>@Resource</p>
<p>根据 Bean ID 注入 Bean</p>
</li>
<li><p>@Value</p>
<p>注入基本数据类型</p>
</li>
<li><p><strong>注意：</strong></p>
<p>处理 @Autowired（ AutowiredAnnotationBeanPostProcessor ）与处理 @Resource（ CommonAnnotationBeanPostProcessor ）的后置处理器不同。</p>
</li>
</ul>
<h4 id="5、设计模式"><a href="#5、设计模式" class="headerlink" title="5、设计模式"></a>5、设计模式</h4><ul>
<li><p>单例模式</p>
</li>
<li><p>代理模式</p>
</li>
<li><p>工厂模式</p>
</li>
<li><p>模板方法</p>
</li>
</ul>
<h4 id="6、循环依赖"><a href="#6、循环依赖" class="headerlink" title="6、循环依赖"></a>6、循环依赖</h4><blockquote>
<p>在 Spring 构建单例 Bean 的过程中有一段代码会根据一个配置属性来判断 Spring 是否开启了循环依赖的支持，该属性默认为 True，所以 Spring 默认支持循环依赖。</p>
<p>Spring 只支持属性的循环依赖。</p>
<p>Spring 为了解决单例的循环依赖问题，使用了 <strong>三级缓存</strong> ，递归调用时发现 Bean 还在创建中即为循环依赖。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一级缓存：用于存放完全初始化好的 bean </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二级缓存：存放 bean 工厂对象，用于解决循环依赖</span></span><br><span class="line"><span class="comment"> * 		   单例工厂的缓存：从 bean name到 ObjectFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三级缓存：存放原始的 bean 对象（尚未填充属性），用于解决循环依赖（早期的单例对象） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前正在创建的 bean 的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bean 的获取过程：先从一级获取，失败再从三级，失败再从二级里面获取</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建中状态：是指对象已经 new 出来了但是所有的属性均为 null 等待被 init</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>Bean 初始过程：</strong></p>
<ul>
<li>一系列验证。</li>
<li>尝试从一级缓存中根据 BeanName 获取该对象。<ul>
<li>如果获取到，返回。</li>
<li>没获取到：则判断该类是否在创建过程中</li>
</ul>
</li>
<li>填充属性（也就是常说的自动注入）</li>
</ul>
<p><strong>Spring 对循环依赖的解决：</strong></p>
<ul>
<li><p><strong>一个概念：</strong></p>
<p>Bean 是经历了完整生命周期的对象，而 A 在初始化过程中会先创建一个没有填充属性，没有被 AOP 处理等等的一个普通 A 对象（instanceWrapper 实例包装器），当其经历完生命周期才能称为一个 Bean。</p>
</li>
<li><p><strong>解决过程：</strong></p>
<p>当 A 被扫描到，会调用 <code>getSingleton()</code> 从单例池(一级缓存)中获取 A ，获取不到且判断出 A 并不是正在创建中，之后进行了第二次 <code>getSingleton()</code> 的调用，在调用中会将 A 标识为正在创建中（将 A 的 BeanName 放入上面代码中的 set 集合中）并开始创建 A，之后在填充属性时发现需要依赖 B ，于是 <code>getSingleton(B)</code> 从单例池(一级缓存)中尝试获取 B ，获取不到且判断到 B 没有正在创建，于是通过第二次调用 <code>getSingleton()</code> 将 B 标识为正在创建中，并开始创建 B ，之后 B 在填充属性时发现需要依赖 A ，于是 <code>getSingleton(A)</code> ，获取不到但判断出 A 正在创建中，于是将正在创建中的 A 从三级缓存中取出来。</p>
<ul>
<li><p>能取出：</p>
<p>注入 B 中，然后 B 继续生命周期，完成后返回给 A ，此时 A 就可以注入 B 继续生命周期。</p>
</li>
<li><p>取不出：</p>
<p>从三级缓存中取不到，就判断是否允许循环引用，这里是 True ，是支持的，然后从二级缓存中取。</p>
<p>从二级缓存中取出后，将其存入三级缓存，并将其从二级缓存中移除。</p>
</li>
</ul>
</li>
<li><p>为什么需要第二级缓存？</p>
<p>在解决过程的最后，B 在取正在创建的 A 时，若 A 创建的后续需要改变（如：AOP 的处理），则不能直接将 A 取出注入，因为 A 还没有进行 AOP 的处理，此时，第二级缓存的意义就出来了，它会对 A 进行 AOP 的处理，之后就可以注入了。</p>
</li>
</ul>
<h4 id="7、BeanFactory-与-ApplicationContext"><a href="#7、BeanFactory-与-ApplicationContext" class="headerlink" title="7、BeanFactory 与 ApplicationContext"></a>7、BeanFactory 与 ApplicationContext</h4><blockquote>
<p>BeanFacotry 是 Spring 用来实例化、配置和管理 Bean 的， 它定义了 IOC 的基本功能。XMLBeanFactory 就是一种典型的 BeanFactory。BeanFactory 无法支持 Spring 的许多插件，如：AOP 功能、Web 应用等。它面向的是 Spring 本身。</p>
<p>ApplicationContext 接口，它由 BeanFactory 接口派生而来，因而提供 BeanFactory 所有的功能。而且 ApplicationContext 还在功能上做了扩展，相较于 BeanFactorty，ApplicationContext 还提供了以下的功能： </p>
<ul>
<li>MessageSource, 提供国际化的消息访问 </li>
<li>资源访问，如 URL 和文件 </li>
<li>事件传播特性，即支持 aop 特性</li>
<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如：应用的 web 层</li>
</ul>
<p>ApplicationContext 的三个实现类：</p>
<ul>
<li>ClassPathXmlApplication：把上下文文件当成类路径资源</li>
<li>FileSystemXmlApplication：从文件系统中的XML文件载入上下文定义信息</li>
<li>XmlWebApplicationContext：从Web系统中的XML文件载入上下文定义信息</li>
</ul>
</blockquote>
<p><img src="%E3%80%90%20Interview%20%E3%80%91/BeanFactory%20%E4%B8%8E%20ApplicationContext.jpg" alt="BeanFactory 与 ApplicationContext"></p>
<p><strong>区别：</strong></p>
<ul>
<li>BeanFactroy 采用的是延迟加载形式来注入 Bean 的， 这样，我们就不能发现一些存在的 Spring 的配置问题。而 ApplicationContext 则相反，它是在容器启动时，一次性创建了所有的 Bean。这样，在容器启动时，我们就可以发现 Spring 中存在的配置错误。</li>
<li>BeanFactory 和 ApplicationContext 都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但两者之间的区别是：BeanFactory 需要手动注册，而 ApplicationContext 则是自动注册。 </li>
<li>BeanFactory 主要是面对与 Spring 框架的基础设施，面对 Spring 自己。而 Applicationcontex 主要面对与 Spring 使用的开发者。</li>
</ul>
<h4 id="8、BeanFactory-与-FactoryBean"><a href="#8、BeanFactory-与-FactoryBean" class="headerlink" title="8、BeanFactory 与 FactoryBean"></a>8、BeanFactory 与 FactoryBean</h4><h4 id="9、Bean"><a href="#9、Bean" class="headerlink" title="9、Bean"></a>9、Bean</h4><h5 id="a、作用域"><a href="#a、作用域" class="headerlink" title="a、作用域"></a>a、作用域</h5><ul>
<li><p>singleton：</p>
<p>单例 Bean 。</p>
</li>
<li><p>prototype：</p>
<p>每次请求都会创建一个新的 bean 实例。</p>
</li>
<li><p>request：</p>
<p>每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效 。</p>
</li>
<li><p>session： </p>
<p>每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效 。</p>
</li>
<li><p>global-session：</p>
<p>全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经移除了。</p>
<p>Portlet 是基于 Java 的 Web 组件，由 Portlet 容器管理，并由容器处理请求，生产动态内容。但是，与 servlet 不同，每个 Portlet 都有不同的会话</p>
</li>
</ul>
<h5 id="b、-Component-和-Bean-的区别"><a href="#b、-Component-和-Bean-的区别" class="headerlink" title="b、@Component 和 @Bean 的区别"></a>b、@Component 和 @Bean 的区别</h5><ul>
<li><p>@Component 作用于类，@Bean 作用于方法。</p>
</li>
<li><p>@Bean 比 @Component 更灵活，很多地方只能使用 @Bean 注解来注册 Bean ，比如：当引入的第三方库中的类需要装配到 Spring 容器中时，只能通过 @Bean 来实现。</p>
</li>
</ul>
<h5 id="c、Bean-生命周期"><a href="#c、Bean-生命周期" class="headerlink" title="c、Bean 生命周期"></a>c、Bean 生命周期</h5><ul>
<li>Bean 容器找到配置文件中的 Spring Bean 的定义；</li>
<li>Bean 容器利用 Java 反射 API 创建一个 Bean 的实例；</li>
<li>如果涉及到一些属性值，利用 <code>set()</code> 方法设置一些属性值；</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanClassLoader()</code> 方法，传入 <code>ClassLoader</code> 对象的实例；</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法；</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行 <code>postProcessBeforeInitialization()</code> 方法；</li>
<li>如果 Bean 实现了 <code>InitializingBean</code> 接口，执行 <code>afterPropertiesSet()</code> 方法；</li>
<li>如果 Bean 在配置文件中的定义包含 <code>init-method</code> 属性，执行指定的方法；</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行 <code>postProcessAfterInitialization()</code> 方法；</li>
<li>初始化完成，执行正常调用，之后开始销毁；</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法；</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 <code>destroy-method</code> 属性，执行指定的方法。</li>
</ul>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><h4 id="1、SpringBoot-的自动配置原理"><a href="#1、SpringBoot-的自动配置原理" class="headerlink" title="1、SpringBoot 的自动配置原理"></a>1、SpringBoot 的自动配置原理</h4><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><h2 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h2><blockquote>
<p>24 种设计模式 , </p>
</blockquote>
<ul>
<li>创建型模式： gof23 + 1 <ol>
<li>简单工厂模式（ 不包含在 gof23 中 ）</li>
<li>工厂模式</li>
<li>抽象工厂模式</li>
<li>单例模式</li>
<li>原型模式</li>
</ol>
</li>
<li>创建者模式<ol>
<li>结构型模式：</li>
<li>组合模式</li>
<li>装饰者模式</li>
<li>外观模式</li>
<li>适配器模式</li>
<li>代理模式</li>
<li>享元模式</li>
<li>桥接模式</li>
</ol>
</li>
<li>行为型模式：<ol>
<li>观察者模式</li>
<li>策略模式</li>
<li>状态模式</li>
<li>中介模式</li>
<li>模板方法</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>访问者模式</li>
<li>解释器模式</li>
<li>迭代器模式</li>
<li>职责链模式</li>
</ol>
</li>
</ul>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://yoursite.com" rel="external nofollow noreferrer">愆凡</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://yoursite.com/2019/10/09/%E3%80%90%20Interview%20%E3%80%91/">http://yoursite.com/2019/10/09/%E3%80%90%20Interview%20%E3%80%91/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="http://yoursite.com" target="_blank">愆凡</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/10/09/%E3%80%90%20Java%20%E7%B3%BB%E5%88%97%20%E3%80%91%EF%BC%9A%E8%BF%9B%E5%87%BB%E7%9A%84%20Java/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="【 Java 系列 】：进击的 Java">
                        
                        <span class="card-title">【 Java 系列 】：进击的 Java</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            一、Java 7 新特性
Java 7 新特性

二进制面值
数字变量对下滑线的支持
switch 对 String 的支持
try-with-resource
捕获多种异常并用改进后的类型检查来重新抛出异常
创建泛型时类型推断
全新的集合
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-10-09
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/09/22/%E3%80%90%20Spring%20%E7%B3%BB%E5%88%97%2003%20%E3%80%91%EF%BC%9ASpring%20Data/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.png" class="responsive-img" alt="【 Spring 系列 03 】：Spring Data">
                        
                        <span class="card-title">【 Spring 系列 03 】：Spring Data</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Spring Data

Spring Data 项目是从 2010 年发展起来的，从创立之初 Spring Data 就想提供一个大家熟悉的、一致的、基于 Spring 的数据访问编程模型，同时仍然保留底层数据存储的特殊特性。它可以轻松地
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-09-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/" class="post-category">
                                    常用框架
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Spring-%E5%85%A8%E5%AE%B6%E6%A1%B6/">
                        <span class="chip bg-color">Spring 全家桶</span>
                    </a>
                    
                    <a href="/tags/Spring/">
                        <span class="chip bg-color">Spring</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4, h5, h6'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5, h6').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="http://yoursite.com" target="_blank">愆凡</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">160.8k</span>&nbsp;字
            


            <br>
            <span id="sitetime"></span>

            <div class="BbeiAn-info">
                <a target="_blank" href="http://www.beian.miit.gov.cn/" style="color:#dbdbdb" rel="nofollow">豫ICP备19032957号</a>
                <!--a标签中增加nofollow属性，避免爬虫出站。-->
                &nbsp;|&nbsp;
                <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41012202000302"
                    style="color:#dbdbdb;text-decoration:none;padding-left:30px;background:url(https://blog.notuptoyou.site/medias/beian.png) no-repeat left center"
                    rel="nofollow">豫公网安备41012202000302号</a>
                <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->
            </div>


            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "6";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/ZGW-GitHub" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:zgwmail@icloud.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=864127700" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 864127700" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
