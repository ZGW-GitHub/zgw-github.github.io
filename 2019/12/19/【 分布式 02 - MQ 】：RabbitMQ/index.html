<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【 分布式 02 - MQ 】：RabbitMQ | 愆凡の博客</title><meta name="description" content="【 分布式 02 - MQ 】：RabbitMQ"><meta name="keywords" content="MQ"><meta name="author" content="愆凡"><meta name="copyright" content="愆凡"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="【 分布式 02 - MQ 】：RabbitMQ"><meta name="twitter:description" content="【 分布式 02 - MQ 】：RabbitMQ"><meta name="twitter:image" content="http://yoursite.com/img/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="【 分布式 02 - MQ 】：RabbitMQ"><meta property="og:url" content="http://yoursite.com/2019/12/19/%E3%80%90%20%E5%88%86%E5%B8%83%E5%BC%8F%2002%20-%20MQ%20%E3%80%91%EF%BC%9ARabbitMQ/"><meta property="og:site_name" content="愆凡の博客"><meta property="og:description" content="【 分布式 02 - MQ 】：RabbitMQ"><meta property="og:image" content="http://yoursite.com/img/avatar.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      now = new Date();
      hour = now.getHours();
      isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2019/12/19/%E3%80%90%20%E5%88%86%E5%B8%83%E5%BC%8F%2002%20-%20MQ%20%E3%80%91%EF%BC%9ARabbitMQ/"><link rel="prev" title="【 分布式 03 】：Kafka" href="http://yoursite.com/2019/12/21/%E3%80%90%20%E5%88%86%E5%B8%83%E5%BC%8F%2002%20-%20MQ%20%E3%80%91%EF%BC%9AKafka/"><link rel="next" title="【 Dubbo 系列 01 】：Dubbo" href="http://yoursite.com/2019/12/17/%E3%80%90%20Dubbo%20%E7%B3%BB%E5%88%97%2001%20%E3%80%91%EF%BC%9ADubbo/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://blog.notuptoyou.site","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: false,
  isFontAwesomeV5: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">50</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、相关概念"><span class="toc-number">1.</span> <span class="toc-text">一、相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、RabbitMQ"><span class="toc-number">1.1.</span> <span class="toc-text">1、RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RabbitMQ-的运行流程"><span class="toc-number">1.1.1.</span> <span class="toc-text">RabbitMQ 的运行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exchange-的类型"><span class="toc-number">1.1.2.</span> <span class="toc-text">Exchange 的类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、AMQP-协议"><span class="toc-number">1.2.</span> <span class="toc-text">2、AMQP 协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、入门"><span class="toc-number">2.</span> <span class="toc-text">二、入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、连接-RabbitMQ"><span class="toc-number">2.1.</span> <span class="toc-text">1、连接 RabbitMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、交换器、队列"><span class="toc-number">2.2.</span> <span class="toc-text">2、交换器、队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a、交换器-API"><span class="toc-number">2.2.1.</span> <span class="toc-text">a、交换器 API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#声明交换器"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">声明交换器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#声明交换器-无需返回"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">声明交换器 ( 无需返回 )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#检测交换器是否存在"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">检测交换器是否存在</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#删除交换器"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">删除交换器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b、队列-API"><span class="toc-number">2.2.2.</span> <span class="toc-text">b、队列 API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#声明队列"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">声明队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#声明队列-无需返回"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">声明队列 ( 无需返回 )</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#检测队列是否存在"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">检测队列是否存在</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#删除队列"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">删除队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#清空队列中的内容"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">清空队列中的内容</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c、queueBind-与-queueUnbind"><span class="toc-number">2.2.3.</span> <span class="toc-text">c、queueBind() 与 queueUnbind()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d、exchangeBind-与-exchangeUnbind"><span class="toc-number">2.2.4.</span> <span class="toc-text">d、exchangeBind() 与 exchangeUnbind()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e、何时创建"><span class="toc-number">2.2.5.</span> <span class="toc-text">e、何时创建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、发送消息"><span class="toc-number">2.3.</span> <span class="toc-text">3、发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、消费消息"><span class="toc-number">2.4.</span> <span class="toc-text">4、消费消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a、推模式"><span class="toc-number">2.4.1.</span> <span class="toc-text">a、推模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b、拉模式"><span class="toc-number">2.4.2.</span> <span class="toc-text">b、拉模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c、注意"><span class="toc-number">2.4.3.</span> <span class="toc-text">c、注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、消费端的确认与拒绝"><span class="toc-number">2.5.</span> <span class="toc-text">5、消费端的确认与拒绝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a、确认消息"><span class="toc-number">2.5.1.</span> <span class="toc-text">a、确认消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b、拒绝消息"><span class="toc-number">2.5.2.</span> <span class="toc-text">b、拒绝消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c、重新入队"><span class="toc-number">2.5.3.</span> <span class="toc-text">c、重新入队</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、关闭连接"><span class="toc-number">2.6.</span> <span class="toc-text">6、关闭连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、入门-进阶"><span class="toc-number">3.</span> <span class="toc-text">三、入门 ( 进阶 )</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、消息何去何从"><span class="toc-number">3.1.</span> <span class="toc-text">1、消息何去何从</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a、mandatory-参数"><span class="toc-number">3.1.1.</span> <span class="toc-text">a、mandatory 参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b、immediate-参数"><span class="toc-number">3.1.2.</span> <span class="toc-text">b、immediate 参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c、备份交换器"><span class="toc-number">3.1.3.</span> <span class="toc-text">c、备份交换器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、过期时间-TTL"><span class="toc-number">3.2.</span> <span class="toc-text">2、过期时间        TTL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、死信队列"><span class="toc-number">3.3.</span> <span class="toc-text">3、死信队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、延迟队列"><span class="toc-number">3.4.</span> <span class="toc-text">4、延迟队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、优先级队列"><span class="toc-number">3.5.</span> <span class="toc-text">5、优先级队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、RPC-实现"><span class="toc-number">3.6.</span> <span class="toc-text">6、RPC 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、持久化"><span class="toc-number">3.7.</span> <span class="toc-text">7、持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、生产者确认"><span class="toc-number">3.8.</span> <span class="toc-text">8、生产者确认</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、消费端要点"><span class="toc-number">3.9.</span> <span class="toc-text">9、消费端要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、消息传输保障"><span class="toc-number">3.10.</span> <span class="toc-text">10、消息传输保障</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#N、参考资料"><span class="toc-number">4.</span> <span class="toc-text">N、参考资料</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">愆凡の博客</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div><div id="post-info"><div id="post-title"><div class="posttitle">【 分布式 02 - MQ 】：RabbitMQ</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2019-12-19<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-03-21</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h2><h3 id="1、RabbitMQ"><a href="#1、RabbitMQ" class="headerlink" title="1、RabbitMQ"></a>1、RabbitMQ</h3><blockquote>
<ul>
<li><p><code>Broker</code>：</p>
<p>消息中间件的服务节点。</p>
<p>对于 RabbitMQ 来说， 一个 RabbitMQ Broker 可 以简单地看作一个 RabbitMQ 服务节点 ， 或者 RabbitMQ 服务实例 。 大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。</p>
</li>
<li><p><code>交换器</code>：</p>
<p>Exchange，在下图中我们暂时可以理解成生产者将消息投递到队列中，实际上这个在 RabbitMQ 中不会发生。</p>
<p>真实情况是：生产者将消息发送到 Exchange ，由交换器将消息路由到一个或者多个队列中。如果路由不到，或许会返回给生产者，或许直接丢弃。</p>
</li>
<li><p><code>路由键</code>：</p>
<p>RoutingKey，生产者将消息发给交换器的时候， 一般会指定一个 RoutingKey，用来指定这个消息的路由规则，而这个 RoutingKey 需要与交换器类型和绑定键 ( BindingKey ) 联合使用才能最终生效。</p>
<p>在交换器类型和绑定键 ( BindingKey ) 固定的情况下，生产者可以在发送消息给交换器时，通过指定 RoutingKey 来决定消息流向哪里。（ 当 BindingKey 和 RoutingKey 相匹配时， 消息会被路由到对应的队列中。 ）</p>
</li>
<li><p><code>绑定</code>：</p>
<p>Binding，RabbitMQ 中通过绑定将<code>交换器</code>与<code>队列</code>关联起来，在绑定的时候一般会指定一个绑定键 ( <code>BindingKey</code> )，这样 RabbitMQ 就知道如何正确地将消息路由到队列了。</p>
<p>BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型， 比 如 fanout 类型的交换器就会无视 BindingKey， 而是将消息路由到所有绑定到该交换器的队列中。</p>
</li>
<li><p><code>队列</code>：</p>
<p>Queue，是 RabbitMQ 的内部对象，用于存储消息。</p>
<p>RabbitMQ 中消息都只能存储在队列中，这一点和 Katka 这种消息中间件相反。Katka 将消息存储在 topic ( 主题 ) 这个逻辑层面，而相对应的队列逻辑只是 topic 实际存储文件中的位移标识。RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。</p>
<p>多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊 ( Round-Robin，即：轮询 ) 给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p>
<p>RabbitMQ 不支持队列层面的广播消费，如果需要广播消费，需要在其上进行二次开发，处理逻辑会变得异常复杂，同时也不建议这么做。</p>
</li>
<li><p><code>消息</code>：</p>
<p>消息一般可以包含 2 个部分：消息体（ payload ）和标签（ Label ）。</p>
<p>消息的标签用来表述这条消息 ， 比如：一个交换器的名称和一个路由键。 生产者把消息交由 RabbitMQ， RabbitMQ 之后会根据标签把消息发送给感兴趣的消费者。</p>
<p>当消费者消费一条消息时， 只是消费消息的消息体 ( Cpayload )。在消息路由的过程中，消息的标签会丢弃，存入到队列中的消息只有消息体，消费者也只会消费到消息体， 也就不知道消息的生产者是谁，当然消费者也不需要知道。</p>
</li>
<li><p><code>生产者</code>：</p>
<p>投递消息的一方</p>
</li>
<li><p><code>消费者</code>：</p>
<p>接收消息的一方</p>
</li>
<li><p><code>连接 ( Connection )</code> 与 <code>通道 ( Channel )</code></p>
<p>无论是生产者还是消费者，都需要和 RabbitMQ Broker 建立连接，这个连接就是一条 TCP 连接，也就是 Connection 。 一旦 TCP 连接建立起来，客户端紧接着可以创建一个 AMQP <code>信道 ( Channel )</code>，每个信道都会被指派一个唯一的 ID。信道是建立在 Connection 之上的虚拟连接， RabbitMQ 处理的每条 AMQP 指令都是通过信道完成的。</p>
</li>
</ul>
</blockquote>
<p><img src="/" alt="RabbitMQ 的模型架构" class="lazyload" data-src="%E3%80%90%20%E5%88%86%E5%B8%83%E5%BC%8F%2002%20-%20MQ%20%E3%80%91%EF%BC%9ARabbitMQ/RabbitMQ%20%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84.png"></p>
<h4 id="RabbitMQ-的运行流程"><a href="#RabbitMQ-的运行流程" class="headerlink" title="RabbitMQ 的运行流程"></a>RabbitMQ 的运行流程</h4><p><code>生产者发送消息：</code></p>
<ol>
<li>生产者连接到 RabbitMQ Broker， 建立一个连接 ( Connection ) ，开启一个信道 ( Channel ) ；</li>
<li>生产者声明一个交换器，并设置相关属性，比如：交换机类型、是否持久化等 ；</li>
<li>生产者声明一个队列井设置相关属性，比如：是否排他、是否持久化、是否自动删除等 ；</li>
<li>生产者通过路由键将交换器和队列绑定起来 ；</li>
<li>生产者发送消息至 RabbitMQ Broker，其中包含：路由键、交换器、等信息 ；</li>
<li>相应的交换器根据接收到的路由键查找相匹配的队列 ；<ul>
<li>如果找到，则将从生产者发送过来的消息存入相应的队列中 ；</li>
<li>如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者 ；</li>
</ul>
</li>
<li>关闭信道 ；</li>
<li>关闭连接 。</li>
</ol>
<p><code>消费者消费消息：</code></p>
<ol>
<li>消费者连接到 RabbitMQ Broker，建立一个连接 ( Connection )，开启一个信道 ( Channel ) ；</li>
<li>消费者向 RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数， 以及做一些准备工作 ；</li>
<li>等待 RabbitMQ Broker 回应并投递相应队列中的消息， 消费者接收消息 ；</li>
<li>消费者确认 ( ack ) 接收到的消息 ；</li>
<li>RabbitMQ 从队列中删除相应己经被确认的消息 ；</li>
<li>关闭信道 ；</li>
<li>关闭连接 。</li>
</ol>
<h4 id="Exchange-的类型"><a href="#Exchange-的类型" class="headerlink" title="Exchange 的类型"></a>Exchange 的类型</h4><blockquote>
<p>RabbitMQ 常用的交换器类型有 fanout、 direct、 topic、 headers 这四种。 AMQP 协议里还提到另外两种类型：System 和自定义，这里不予描述。</p>
</blockquote>
<p><code>fanout</code></p>
<ul>
<li>把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</li>
</ul>
<p><code>direct</code></p>
<ul>
<li>将消息路由到那些 BindingKey 和 RoutingKey 完全匹配的队列中。</li>
</ul>
<p><code>topic</code></p>
<ul>
<li><p>将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，其匹配规则：</p>
<p>BindingKey 和 RoutingKey 是点号<code>&quot;.&quot;</code>分隔的字符串；</p>
<p>RoutingKey 存在两种特殊字符串<code>&quot;*&quot;</code>和<code>&quot;#&quot;</code>，用于做模糊匹配，其中<code>&quot;#&quot;</code>用于匹配一个单词，<code>&quot;*&quot;</code>用于匹配多个单词 ( 可以是零个 ) 。</p>
</li>
</ul>
<p><code>headers</code></p>
<ul>
<li>不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时制定一组键值对， 当发送消息到交换器时， RabbitMQ 会获取到该消息的 headers (也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。 headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</li>
</ul>
<h3 id="2、AMQP-协议"><a href="#2、AMQP-协议" class="headerlink" title="2、AMQP 协议"></a>2、AMQP 协议</h3><h2 id="二、入门"><a href="#二、入门" class="headerlink" title="二、入门"></a>二、入门</h2><h3 id="1、连接-RabbitMQ"><a href="#1、连接-RabbitMQ" class="headerlink" title="1、连接 RabbitMQ"></a>1、连接 RabbitMQ</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// factory.setUri("amqp://username:password@ipAddress:portNumber/virtualHost");</span></span><br><span class="line">factory.setHost(<span class="string">"192.168.56.1"</span>);</span><br><span class="line">factory.setPort(AMQP.PROTOCOL.PORT);</span><br><span class="line">factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line">factory.setVirtualHost(<span class="string">"snow"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建连接</span></span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    <span class="comment">// 使用连接创建通道</span></span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、交换器、队列"><a href="#2、交换器、队列" class="headerlink" title="2、交换器、队列"></a>2、交换器、队列</h3><h4 id="a、交换器-API"><a href="#a、交换器-API" class="headerlink" title="a、交换器 API"></a>a、交换器 API</h4><h5 id="声明交换器"><a href="#声明交换器" class="headerlink" title="声明交换器"></a>声明交换器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String exchange, 					// 交换器名称</span></span></span><br><span class="line"><span class="function"><span class="params">    String type, 						// 交换器类型</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> durable, 					// 是否持久化（<span class="keyword">true</span>：持久化）</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> autoDelete, 				// 是否自动删除（<span class="keyword">true</span>：自动删除）</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> internal, 					// 是否是内置的（<span class="keyword">true</span>：内置的）</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt; argument		// 其它的一些结构化参数</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p><strong>关于自动删除：</strong></p>
<ul>
<li>自动删除的前提是至少有一个队列或者交换器与这个交换器绑定， 之后所有与这个交换器绑定的队列或者交换器都与此解绑。注意不能错误地把这个参数理解为: “当与此交换器连接的客户端都断开时， RabbitMQ 会自动删除本交换器”。</li>
</ul>
<p><strong>关于内置：</strong></p>
<ul>
<li>对于内置的交换器，客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式。</li>
</ul>
<p><strong>关于其它的一些结构化参数：</strong></p>
<ul>
<li>比如：<code>alternate-exchange</code></li>
</ul>
<h5 id="声明交换器-无需返回"><a href="#声明交换器-无需返回" class="headerlink" title="声明交换器 ( 无需返回 )"></a>声明交换器 ( 无需返回 )</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchangeDeclareNoWait</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	String exchange, 					// 交换器名称</span></span></span><br><span class="line"><span class="function"><span class="params">    String type, 						// 交换器类型</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> durable, 					// 是否持久化（<span class="keyword">true</span>：持久化）</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> autoDelete, 				// 是否自动删除（<span class="keyword">true</span>：自动删除）</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> internal, 					// 是否是内置的（<span class="keyword">true</span>：内置的）</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt; argument		// 其它的一些结构化参数</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>该方法的调用是不需要服务器返回的，注意这个方法的返回值是 void ，而普通的 exchangeDeclare 方法的返回值是 <code>Exchange.DeclareOk</code> ，意思是在客户端声明了一个交换器之后，需要等待服务器的返回 ( 服务器会返回 <code>Exchange.Declare-Ok</code> 这个 AMQP 命令 ) 。</p>
<p>针对 “<code>exchangeDeclareNoWait()</code> 方法不需要服务器任何返回值” 这一点，考虑这样一种情况，在声明完一个交换器之后(实际服务器还并未完成交换器的创建)， 那么此时客户端紧接着使用这个交换器，必然会发生异常。如果没有特殊的缘由和应用场景，并不建议使用这个方法。</p>
<h5 id="检测交换器是否存在"><a href="#检测交换器是否存在" class="headerlink" title="检测交换器是否存在"></a>检测交换器是否存在</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclarePassive</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>检测相应的交换器是否存在。</p>
<ul>
<li>如果存在则正常返回 。</li>
<li>如果不存在则抛出异常：404 channel exception，同时 Channel 也会被关闭。</li>
</ul>
<h5 id="删除交换器"><a href="#删除交换器" class="headerlink" title="删除交换器"></a>删除交换器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 isUnused 设置为 true，则只有在此交换器没有被使用的情况下才会被删除。</span></span><br><span class="line"></span><br><span class="line">Exchange.<span class="function">DeleteOk <span class="title">exchangeDelete</span><span class="params">(String exchange)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">Exchange.<span class="function">DeleteOk <span class="title">exchangeDelete</span><span class="params">(String exchange, <span class="keyword">boolean</span> ifUnused)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchangeDeleteNoWait</span><span class="params">(String exchange, <span class="keyword">boolean</span> ifUnused)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<h4 id="b、队列-API"><a href="#b、队列-API" class="headerlink" title="b、队列 API"></a>b、队列 API</h4><blockquote>
<p>生产者和消费者都能够使用 queueDeclare 来声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，然后将信道直为”传输”模式，之后才能声明队列。</p>
</blockquote>
<h5 id="声明队列"><a href="#声明队列" class="headerlink" title="声明队列"></a>声明队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带任何参数的 queueDeclare 方法</span></span><br><span class="line"><span class="comment">// 默认创建一个由 RabbitMQ 命名的(类似这种 amq.gen-LhQzlgv3GhDOv8PIDabOXA 名称，这种队列也称之为匿名队列)队列</span></span><br><span class="line"><span class="comment">// 且该队列是排他的、自动删除的、非持久化的</span></span><br><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String queue, 						// 队列的名称</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> durable, 					// 是否持久化（<span class="keyword">true</span>：持久化）</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> exclusive, 					// 是否排它（<span class="keyword">true</span>：排它）</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> autoDelete,					// 是否自动删除（<span class="keyword">true</span>：自动删除）</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt; arguments		// 设置队列的一些其它参数</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p><strong>关于排它：</strong></p>
<ul>
<li><p>如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。</p>
</li>
<li><p>这里需要注意三点：</p>
<ol>
<li>排他队列是基于连接 ( Connection ) 可见的，同一个连接的不同信道 ( Channel ) 可以同时访问同一连接创建的排他队列 ；</li>
<li>“首次”是指如果一个连接己经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同 ；</li>
<li>即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列就会被自动删除 。</li>
</ol>
</li>
<li><p>这种队列适用于一个客户端同时发送和读取消息的应用场景。</p>
</li>
</ul>
<p><strong>关于自动删除：</strong></p>
<ul>
<li>自动删除的前提是：至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。</li>
<li>不能把这个参数错误地理解为：”当连接到此队列的所有客户端断开时，这个队列自动删除”，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列。</li>
</ul>
<p><strong>关于队列的一些其它参数：</strong></p>
<ul>
<li>如：</li>
<li><code>x-rnessage-ttl</code></li>
<li><code>x-expires</code></li>
<li><code>x-rnax-length</code></li>
<li><code>x-rnax-length-bytes</code></li>
<li><code>x-dead-letter-exchange</code></li>
<li><code>x-dead-letter-routing-key</code></li>
<li><code>x-rnax-priority</code></li>
<li>等</li>
</ul>
<h5 id="声明队列-无需返回"><a href="#声明队列-无需返回" class="headerlink" title="声明队列 ( 无需返回 )"></a>声明队列 ( 无需返回 )</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueDeclareNoWait</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String queue, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> durable, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> exclusive, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt; arguments</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>意义类似<strong>声明交换器 ( 无需返回 )</strong></p>
<h5 id="检测队列是否存在"><a href="#检测队列是否存在" class="headerlink" title="检测队列是否存在"></a>检测队列是否存在</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclarePassive</span><span class="params">(String queue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>检测相应的队列是否存在。</p>
<ul>
<li>如果存在则正常返回 。</li>
<li>如果不存在则抛出异常：404 channel exception，同时 Channel 也会被关闭。</li>
</ul>
<h5 id="删除队列"><a href="#删除队列" class="headerlink" title="删除队列"></a>删除队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 isUnused 设置为 true，则只有在此队列没有被使用的情况下才会被删除。</span></span><br><span class="line"><span class="comment">// 如果 ifEmpty 设置为 true，表示在队列为空(队列里面没有任何消息堆积)的情况下才能够删除。</span></span><br><span class="line"></span><br><span class="line">Queue.<span class="function">DeleteOk <span class="title">queueDelete</span><span class="params">(String queue)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">Queue.<span class="function">DeleteOk <span class="title">queueDelete</span><span class="params">(String queue, <span class="keyword">boolean</span> ifUnused, <span class="keyword">boolean</span> ifEmpty)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueDeleteNoWait</span><span class="params">(String queue, <span class="keyword">boolean</span> ifUnused, <span class="keyword">boolean</span> ifEmpty)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<h5 id="清空队列中的内容"><a href="#清空队列中的内容" class="headerlink" title="清空队列中的内容"></a>清空队列中的内容</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue.<span class="function">PurgeOk <span class="title">queuePurge</span><span class="params">(String queue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<h4 id="c、queueBind-与-queueUnbind"><a href="#c、queueBind-与-queueUnbind" class="headerlink" title="c、queueBind() 与 queueUnbind()"></a>c、<code>queueBind()</code> 与 <code>queueUnbind()</code></h4><blockquote>
<p>将队列与交换机进行绑定 / 解绑 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"></span><br><span class="line">Queue.<span class="function">BindOk <span class="title">queueBind</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String queue, </span></span></span><br><span class="line"><span class="function"><span class="params">    String exchange, </span></span></span><br><span class="line"><span class="function"><span class="params">    String routingKey</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">Queue.<span class="function">BindOk <span class="title">queueBind</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String queue, 						// 队列名称</span></span></span><br><span class="line"><span class="function"><span class="params">    String exchange, 					// 交换器名称</span></span></span><br><span class="line"><span class="function"><span class="params">    String routingKey, 					// 绑定队列和交换器的路由键</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt; arguments		// 定义绑定的一些参数</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueBindNoWait</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String queue, </span></span></span><br><span class="line"><span class="function"><span class="params">    String exchange, </span></span></span><br><span class="line"><span class="function"><span class="params">    String routingKey, </span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt; arguments</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解绑</span></span><br><span class="line"></span><br><span class="line">Queue.<span class="function">UnbindOk <span class="title">queueUnbind</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String queue, </span></span></span><br><span class="line"><span class="function"><span class="params">    String exchange, </span></span></span><br><span class="line"><span class="function"><span class="params">    String routingKey</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">Queue.<span class="function">UnbindOk <span class="title">queueUnbind</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String queue, </span></span></span><br><span class="line"><span class="function"><span class="params">    String exchange, </span></span></span><br><span class="line"><span class="function"><span class="params">    String routingKey, </span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt; arguments</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<h4 id="d、exchangeBind-与-exchangeUnbind"><a href="#d、exchangeBind-与-exchangeUnbind" class="headerlink" title="d、exchangeBind() 与 exchangeUnbind()"></a>d、<code>exchangeBind()</code> 与 <code>exchangeUnbind()</code></h4><blockquote>
<p>将交换器与交换器进行绑定 / 解绑 。</p>
</blockquote>
<blockquote>
<p>关于交换器与交换器绑定后的工作原理：</p>
<ul>
<li><p>生产者发送消息至交换器 source 中，交换器 source 根据路由键找到与其匹配的另一个交换器 destination， 井把消息转发到 destination 中 ， 进而存储在 destination 绑定的队列 queue 中，如下图所示：</p>
<p><img src="/" alt="交换器与交换器绑定" class="lazyload" data-src="%E3%80%90%20%E5%88%86%E5%B8%83%E5%BC%8F%2002%20-%20MQ%20%E3%80%91%EF%BC%9ARabbitMQ/%E4%BA%A4%E6%8D%A2%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E5%99%A8%E7%BB%91%E5%AE%9A.png"></p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定</span></span><br><span class="line"></span><br><span class="line">Exchange.<span class="function">BindOk <span class="title">exchangeBind</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String destination, </span></span></span><br><span class="line"><span class="function"><span class="params">    String source, </span></span></span><br><span class="line"><span class="function"><span class="params">    String routingKey)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">Exchange.<span class="function">BindOk <span class="title">exchangeBind</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String destination, 				// 目的交换器名称</span></span></span><br><span class="line"><span class="function"><span class="params">    String source, 						// 源交换器名称</span></span></span><br><span class="line"><span class="function"><span class="params">    String routingKey, 					// 绑定交换器和交换器的路由键</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt; arguments		// 定义绑定的一些参数</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchangeBindNoWait</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String destination, </span></span></span><br><span class="line"><span class="function"><span class="params">    String source, </span></span></span><br><span class="line"><span class="function"><span class="params">    String routingKey, </span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt; arguments</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解绑</span></span><br><span class="line"></span><br><span class="line">Exchange.<span class="function">UnbindOk <span class="title">exchangeUnbind</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String destination, </span></span></span><br><span class="line"><span class="function"><span class="params">    String source, </span></span></span><br><span class="line"><span class="function"><span class="params">    String routingKey</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">Exchange.<span class="function">UnbindOk <span class="title">exchangeUnbind</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String destination, </span></span></span><br><span class="line"><span class="function"><span class="params">    String source, </span></span></span><br><span class="line"><span class="function"><span class="params">    String routingKey, </span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt; arguments</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchangeUnbindNoWait</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String destination, </span></span></span><br><span class="line"><span class="function"><span class="params">    String source, </span></span></span><br><span class="line"><span class="function"><span class="params">    String routingKey, </span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt; arguments</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<h4 id="e、何时创建"><a href="#e、何时创建" class="headerlink" title="e、何时创建"></a>e、何时创建</h4><p>RabbitMQ 的消息存储在队列中，交换器的使用并不真正耗费服务器的性能，而队列会。 如果要衡量 RabbitMQ 当前的 QPS 只需看队列的即可。在实际业务应用中，需要对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值，以便在固定硬件资源的情况下能够进行合理有效的分配。</p>
<h3 id="3、发送消息"><a href="#3、发送消息" class="headerlink" title="3、发送消息"></a>3、发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String exchange, 			// 交换器名称。若为空字符串，则消息会被发送到 RabbitMQ 默认的交换器中。</span></span></span><br><span class="line"><span class="function"><span class="params">    String routingKey, 			// 路由键</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> mandatory, 			// </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> immediate, 			// </span></span></span><br><span class="line"><span class="function"><span class="params">    BasicProperties props, 		// 消息的基本属性集</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">byte</span>[] body					// 消息体 (pay1oad)</span>，真正需要发送的消息。</span></span><br><span class="line"><span class="function">) <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String exchange, </span></span></span><br><span class="line"><span class="function"><span class="params">    String routingKey, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> mandatory, </span></span></span><br><span class="line"><span class="function"><span class="params">    BasicProperties props, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">byte</span>[] body</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String exchange, </span></span></span><br><span class="line"><span class="function"><span class="params">    String routingKey, </span></span></span><br><span class="line"><span class="function"><span class="params">    BasicProperties props, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">byte</span>[] body</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p><strong>关于消息的基本属性集：</strong></p>
<ul>
<li>其 ( BasicProperties ) 包含 14 个属性成员，分别有：</li>
<li>contentType</li>
<li>contentEncoding</li>
<li>headers (Map&lt;String ， Object&gt;)</li>
<li>deliveryMode</li>
<li>priority</li>
<li>correlationld</li>
<li>replyTo</li>
<li>expiration</li>
<li>messageld</li>
<li>timestamp</li>
<li>type</li>
<li>userld</li>
<li>appld</li>
<li>clusterld</li>
</ul>
<h3 id="4、消费消息"><a href="#4、消费消息" class="headerlink" title="4、消费消息"></a>4、消费消息</h3><blockquote>
<p>RabbitMQ 的消费模式分两种：</p>
<ul>
<li><p>推 ( Push ) 模式</p>
<p>使用 <code>basicConsume()</code> 来获取 ( 订阅 ) 消息</p>
</li>
<li><p>拉 ( Pull )模式</p>
<p>使用 <code>basicGet()</code> 来获取消息</p>
</li>
</ul>
</blockquote>
<h4 id="a、推模式"><a href="#a、推模式" class="headerlink" title="a、推模式"></a>a、推模式</h4><blockquote>
<p>在推模式中，可以通过持续订阅的方式来消费消息。</p>
<p>使用到的相关类：</p>
<ul>
<li><code>com.rabbitmq.client.Consumer</code></li>
<li><code>com.rabbitmq.client.DefaultConsumer</code></li>
</ul>
<p>如上所示，推模式中对消息的处理一般是通过实现 Consumer 接口或者继承 DefaultConsumer 类来实现的。</p>
<p>在调用与 Consumer 相关的 API 方法对消息进行处理时， 不同的订阅采用不同的消费者标签 ( consumerTag ) 来区分彼此，在同一个 Channel 中的消费者也需要通过唯一的消费者标签以作区分。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">basicConsume</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String queue, 						// 队列名称</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> autoAck, 					// 是否自动确认（<span class="keyword">true</span>：是）</span></span></span><br><span class="line"><span class="function"><span class="params">    String consumerTag, 				// 消费者标签（用来区分多个消费者）</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> noLocal, 					// 设置为 <span class="keyword">true</span> 则表示不能将同一个 Connection 中生产者发送的消息传送给这个 Connection 中的消费者</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> exclusive,					// 是否排它（<span class="keyword">true</span>：是）</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt;	arguments,		// 设置消费者的其他参数</span></span></span><br><span class="line"><span class="function"><span class="params">    DeliverCallback	deliverCallback, 	// 交付回调函数</span></span></span><br><span class="line"><span class="function"><span class="params">    CancelCallback cancelCallback,		// 取消回调函数</span></span></span><br><span class="line"><span class="function"><span class="params">    ConsumerShutdownSignalCallback shutdownSignalCallback	// shutdown signal 回调函数</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">basicConsume</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String queue, 						// 队列名称</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> autoAck, 					// 是否自动确认（<span class="keyword">true</span>：是）</span></span></span><br><span class="line"><span class="function"><span class="params">    String consumerTag, 				// 消费者标签（用来区分多个消费者）</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> noLocal, 					// 设置为 <span class="keyword">true</span> 则表示不能将同一个 Connection 中生产者发送的消息传送给这个 Connection 中的消费者</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> exclusive,					// 是否排它（<span class="keyword">true</span>：是）</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt;	arguments,		// 设置消费者的其他参数</span></span></span><br><span class="line"><span class="function"><span class="params">    Consumer callback					// 设置消费者的回调函数，用来处理 RabbitMQ 推送过来的消息。</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>关于参数中的 <code>Consumer callback</code>：</p>
<ul>
<li><p>就像前面说的推模式中对消息的处理一般是通过实现 Consumer 接口或者继承 DefaultConsumer 类来实现的。</p>
</li>
<li><p>而实现 Consumer 接口或者继承 DefaultConsumer 类后就要重写其方法来对消息进行定制化处理，其方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleConsumeOk</span> <span class="params">( String consumerTag )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleCancelOk</span> <span class="params">( String consumerTag )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleCancel</span> <span class="params">( String consumerTag )</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleShutdownSignal</span> <span class="params">( String consumerTag, ShutdownSignalException sig )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleRecoverOk</span> <span class="params">( String consumerTag )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleDelivery</span> <span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    String consumerTag,    </span></span></span><br><span class="line"><span class="function"><span class="params">    Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">    AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">byte</span>[] body </span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p><code>handleShutdownSignal()</code> </p>
<ul>
<li>当 Channel 或者 Connection 关闭的时候会调用。 </li>
</ul>
<p><code>handleConsumeOk()</code> </p>
<ul>
<li>会在其他方法之前调用，返回消费者标签。</li>
</ul>
<p><code>handleCancelOk()</code> 和 <code>handleCancel()</code> </p>
<ul>
<li>消费端显式或者隐式地取消订阅时调用。</li>
</ul>
<p><code>channel.basicCancel()</code></p>
<ul>
<li><p>显式地取消一个消费者的订阅：<code>channel.basicCancel(consumerTag);</code></p>
</li>
<li><p>注意：上面这行代码会首先触发 <code>handleConsumerOk()</code> 方法，之后触发 <code>handleDelivery()</code> 方法，最后才触发 <code>handleCancelOk()</code> 方法。</p>
</li>
</ul>
</li>
</ul>
<h4 id="b、拉模式"><a href="#b、拉模式" class="headerlink" title="b、拉模式"></a>b、拉模式</h4><blockquote>
<p>在拉模式中，可以通过 <code>channel.basicGet()</code> 方法单条地获取消息，其返回值是 GetRespone 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GetResponse <span class="title">basicGet</span><span class="params">(String queue, <span class="keyword">boolean</span> autoAck)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<h4 id="c、注意"><a href="#c、注意" class="headerlink" title="c、注意"></a>c、注意</h4><blockquote>
<p><code>basicConsume()</code> 将信道 ( Channel ) 置为接收模式，直到取消队列的订阅为止。在接收模式期间， RabbitMQ 会不断地推送消息给消费者，当然推送消息的个数还是会受到 Basic.Qos 的限制。</p>
<p>如果只想从队列获得单条消息而不是持续订阅，建议还是使用 <code>basicGet()</code> 进行消费。</p>
<p>但是不能将 <code>basicGet()</code> 放在一个循环里来代替 <code>basicConsume()</code> ，这样做会严重影响 RabbitMQ 的性能。</p>
<p>如果要实现高吞吐量，消费者理应使用 <code>basicConsume()</code> 方法。</p>
</blockquote>
<h3 id="5、消费端的确认与拒绝"><a href="#5、消费端的确认与拒绝" class="headerlink" title="5、消费端的确认与拒绝"></a>5、消费端的<code>确认</code>与<code>拒绝</code></h3><h4 id="a、确认消息"><a href="#a、确认消息" class="headerlink" title="a、确认消息"></a>a、确认消息</h4><blockquote>
<p>消费者在订阅队列时，可以指定 autoAck 参数，来配置消息的自动确认。</p>
<ul>
<li>当 autoAck 等于 false 时， RabbitMQ 会等待消费者显式地回复确认信号后才从内存 ( 或者磁盘 ) 中移去消息 ( 实质上<br>是先打上删除标记，之后再删除 ) 。</li>
<li>当 autoAck 等于 true 时， RabbitMQ 会自动把发送出去的消息置为确认，然后从内存 ( 或者磁盘 ) 中删除，而不管消费者是否真正地消费到了这些消息 。</li>
</ul>
</blockquote>
<p>当 autoAck 参数置为 false，对于 RabbitMQ 服务端而言，队列中的消息分成了两个部分：</p>
<ul>
<li><p>一部分是等待投递给消费者的消息 ；</p>
</li>
<li><p>一部分是己经投递给消费者，但是还没有收到消费者确认信号的消息：</p>
<p>如果 RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者己经断开连接，则 RabbitMQ 会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。</p>
<p>RabbitMQ 不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否己经断开，这么设计的原因是 RabbitMQ 允许消费者消费一条消息的时间可以很久很久。</p>
</li>
</ul>
<h4 id="b、拒绝消息"><a href="#b、拒绝消息" class="headerlink" title="b、拒绝消息"></a>b、拒绝消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拒绝一条消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicReject</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> deliveryTag, 	// 可以看作消息的编号 ，它是一个 <span class="number">64</span> 位的长整型值，最大值是 <span class="number">9223372036854775807</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> requeue		// <span class="keyword">true</span>：RabbitMQ 会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者。</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量拒绝消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicNack</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> deliveryTag, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> multiple, 	// <span class="keyword">false</span> 表示拒绝编号为 deliveryTag 的这一条消息，这时候 basicNack 和 basicReject 方法一样; </span></span></span><br><span class="line"><span class="function"><span class="params">    					// multiple 参数设置为 <span class="keyword">true</span> 则表示拒绝 deliveryTag 编号之前所有未被当前消费者确认的消息。</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> requeue</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：</span></span><br><span class="line"><span class="comment">// 将 channel.basicReject 或者 channel.basicNack 中的 requeue 设直为 false，可以启用"死信队列"的功能。</span></span><br><span class="line"><span class="comment">// 死信队列可以通过检测被拒绝或者未送达的消息来追踪问题。</span></span><br></pre></td></tr></table></figure>

<h4 id="c、重新入队"><a href="#c、重新入队" class="headerlink" title="c、重新入队"></a>c、重新入队</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Basic.<span class="function">RecoverOk <span class="title">basicRecover</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Basic.<span class="function">RecoverOk <span class="title">basicRecover</span><span class="params">(<span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p><code>channel.basicRecover()</code> 方法用来请求 RabbitMQ 重新发送还未被确认的消息。</p>
<ul>
<li>如果 requeue 参数设置为 true，则未被确认的消息会被重新加入到队列中，这样对于同一条消息来说，可能会被分配给与之前不同的消费者。</li>
<li>如果 requeue 参数设置为 false，那么同一条消息会被分配给与之前相同的消费者。</li>
<li>默认情况下，如果不设置 requeue 这个参数，相当于 <code>channel.basicRecover(true)</code> ，即 requeue 默认为 true 。</li>
</ul>
<h3 id="6、关闭连接"><a href="#6、关闭连接" class="headerlink" title="6、关闭连接"></a>6、关闭连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br><span class="line">connection.close(); <span class="comment">// 在 Connection 关闭的时候，Channel 也会自动关闭。</span></span><br></pre></td></tr></table></figure>

<p>AMQP 协议中的 Connection 和 Channel 采用同样的方式来管理网络失败、内部错误和显式地关闭连接。Connection 和 Channel 所具备的生命周期如下所述：</p>
<ul>
<li><p>Open</p>
<p>开启状态，代表当前对象可以使用。</p>
</li>
<li><p>Closing</p>
<p>正在关闭状态。当前对象被显式地通知调用关闭方法 ( shutdown )，这样就产生了一个关闭请求让其内部对象进行相应的操作， 并等待这些关闭操作的完成。</p>
</li>
<li><p>Closed</p>
<p>已经关闭状态。当前对象己经接收到所有的内部对象己完成关闭动作的通知，并且其也关闭了自身。</p>
</li>
</ul>
<p><strong>在 Connection 和 Channel 中，与关闭相关的方法还有：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当 Connection 或者 Channel 的状态转变为 Closed 的时候会调用 ShutdownListener。</span></span><br><span class="line"><span class="comment"> * 而且如果将一个 ShutdownListener 注册到一个己经处于 Closed 状态的对象(这里特指 Connection 和 Channel 对象)时，会立刻调用 ShutdownListener。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addShutdownListener</span><span class="params">(ShutdownListener listener)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeShutdownListener</span><span class="params">(ShutdownListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以让你知道对象关闭的原因 </span></span><br><span class="line"><span class="function">ShutdownSignalException <span class="title">getCloseReason</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测对象当前是否处于开启状态</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式地通知当前对象执行关闭操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> closeCode, String closeMessage)</span> <span class="keyword">throws</span> IOException, TimeoutException</span>;</span><br></pre></td></tr></table></figure>

<h2 id="三、入门-进阶"><a href="#三、入门-进阶" class="headerlink" title="三、入门 ( 进阶 )"></a>三、入门 ( 进阶 )</h2><h3 id="1、消息何去何从"><a href="#1、消息何去何从" class="headerlink" title="1、消息何去何从"></a>1、消息何去何从</h3><blockquote>
<p>mandatory 和 immediate 是 channel.basicPublish 方法中的两个参数：</p>
<ul>
<li>它们都有当消息传递过程中不可达目的地时将消息返回给生产者的功能。</li>
</ul>
<p>RabbitMQ 提供的备份交换器 ( Altemate Exchange ) ：</p>
<ul>
<li>可以将未能被交换器路由的消息 ( 没有绑定队列或者没有匹配的绑定 ) 存储起来，而不用返回给客户端。</li>
</ul>
</blockquote>
<h4 id="a、mandatory-参数"><a href="#a、mandatory-参数" class="headerlink" title="a、mandatory 参数"></a>a、mandatory 参数</h4><blockquote>
<p>当 mandatory 参数设为 true 时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么 RabbitMQ 会调用 Basic.Return 命令将消息返回给生产者。</p>
<p>当 mandatory 参 数设置为 false 时，出现上述情形，则消息直接被丢弃。</p>
</blockquote>
<p>生产者可以通过调用 channel.addReturnListener 来添加 ReturnListener 监昕器获取没有被正确路由到合适队列的消息。</p>
<h4 id="b、immediate-参数"><a href="#b、immediate-参数" class="headerlink" title="b、immediate 参数"></a>b、immediate 参数</h4><h4 id="c、备份交换器"><a href="#c、备份交换器" class="headerlink" title="c、备份交换器"></a>c、备份交换器</h4><h3 id="2、过期时间-TTL"><a href="#2、过期时间-TTL" class="headerlink" title="2、过期时间        TTL"></a>2、过期时间        <code>TTL</code></h3><h3 id="3、死信队列"><a href="#3、死信队列" class="headerlink" title="3、死信队列"></a>3、死信队列</h3><h3 id="4、延迟队列"><a href="#4、延迟队列" class="headerlink" title="4、延迟队列"></a>4、延迟队列</h3><h3 id="5、优先级队列"><a href="#5、优先级队列" class="headerlink" title="5、优先级队列"></a>5、优先级队列</h3><h3 id="6、RPC-实现"><a href="#6、RPC-实现" class="headerlink" title="6、RPC 实现"></a>6、RPC 实现</h3><h3 id="7、持久化"><a href="#7、持久化" class="headerlink" title="7、持久化"></a>7、持久化</h3><h3 id="8、生产者确认"><a href="#8、生产者确认" class="headerlink" title="8、生产者确认"></a>8、生产者确认</h3><h3 id="9、消费端要点"><a href="#9、消费端要点" class="headerlink" title="9、消费端要点"></a>9、消费端要点</h3><h3 id="10、消息传输保障"><a href="#10、消息传输保障" class="headerlink" title="10、消息传输保障"></a>10、消息传输保障</h3><h2 id="N、参考资料"><a href="#N、参考资料" class="headerlink" title="N、参考资料"></a>N、参考资料</h2><p><a href="https://juejin.im/entry/5cbc8e0ef265da03b446104f" target="_blank" rel="noopener">Ubuntu 安装 RabbitMQ</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">愆凡</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/12/19/%E3%80%90%20%E5%88%86%E5%B8%83%E5%BC%8F%2002%20-%20MQ%20%E3%80%91%EF%BC%9ARabbitMQ/">http://yoursite.com/2019/12/19/%E3%80%90%20%E5%88%86%E5%B8%83%E5%BC%8F%2002%20-%20MQ%20%E3%80%91%EF%BC%9ARabbitMQ/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">愆凡の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MQ/">MQ    </a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/12/21/%E3%80%90%20%E5%88%86%E5%B8%83%E5%BC%8F%2002%20-%20MQ%20%E3%80%91%EF%BC%9AKafka/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【 分布式 03 】：Kafka</div></div></a></div><div class="next-post pull_right"><a href="/2019/12/17/%E3%80%90%20Dubbo%20%E7%B3%BB%E5%88%97%2001%20%E3%80%91%EF%BC%9ADubbo/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【 Dubbo 系列 01 】：Dubbo</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/12/21/【 分布式 02 - MQ 】：Kafka/" title="【 分布式 03 】：Kafka"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-12-21</div><div class="relatedPosts_title">【 分布式 03 】：Kafka</div></div></a></div><div class="relatedPosts_item"><a href="/2019/11/08/【 分布式 02 - MQ 】：RocketMQ/" title="【 分布式 02 - MQ 】：RocketMQ"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-11-08</div><div class="relatedPosts_title">【 分布式 02 - MQ 】：RocketMQ</div></div></a></div><div class="relatedPosts_item"><a href="/2019/11/10/【 分布式 02 - MQ 】：总结/" title="【 分布式 02 - MQ 】：总结"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-11-10</div><div class="relatedPosts_title">【 分布式 02 - MQ 】：总结</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 愆凡</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">簡</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>