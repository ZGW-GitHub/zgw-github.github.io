<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="【 网络编程 04 】：Netty, 愆凡の博客">
    <meta name="description" content="一、概念
Netty 是一款用于创建高性能网络应用程序的高级框架。
Netty 的异步编程模型是建立在 Future 和回调的概念之上的，而将事件派发到 ChannelHandler 的方法则发生在更深的层次上。


二、可用的传输


零">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>【 网络编程 04 】：Netty | 愆凡の博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">愆凡の博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">愆凡の博客</div>
        <div class="logo-desc">
            
            Was vernünftig ist, das ist wirklich; und was wirklich ist, das ist vernünftig.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/ZGW-GitHub" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/ZGW-GitHub" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('文章正在修正，请稍后再来阅读！')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">【 网络编程 04 】：Netty</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-category">
                                网络编程
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-11-09
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-03-21
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    14.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    56 分
                </div>
                
				
                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><blockquote>
<p>Netty 是一款用于创建高性能网络应用程序的高级框架。</p>
<p>Netty 的异步编程模型是建立在 Future 和回调的概念之上的，而将事件派发到 ChannelHandler 的方法则发生在更深的层次上。</p>
</blockquote>
<p><img src="/" alt="Netty 概念" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/Netty%20%E6%A6%82%E5%BF%B5.png"></p>
<h2 id="二、可用的传输"><a href="#二、可用的传输" class="headerlink" title="二、可用的传输"></a>二、可用的传输</h2><p><img src="/" alt="Netty 所提供的传输" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/Netty%20%E6%89%80%E6%8F%90%E4%BE%9B%E7%9A%84%E4%BC%A0%E8%BE%93.png"></p>
<p><img src="/" alt="Netty 支持的传输和网络协议" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/Netty%20%E6%94%AF%E6%8C%81%E7%9A%84%E4%BC%A0%E8%BE%93%E5%92%8C%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.png"></p>
<ul>
<li><p><strong>零拷贝：</strong></p>
<p>即：可以快速高效的将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间再复制到内核空间。</p>
<p>只有 NIO 和 Epoll 才可以使用零拷贝这一特性。</p>
</li>
</ul>
<h2 id="三、处理流程"><a href="#三、处理流程" class="headerlink" title="三、处理流程"></a>三、处理流程</h2><h3 id="1、Netty-运行时处理请求的流程"><a href="#1、Netty-运行时处理请求的流程" class="headerlink" title="1、Netty 运行时处理请求的流程"></a>1、Netty 运行时处理请求的流程</h3><blockquote>
<p>说明：</p>
<ol>
<li>每个 Eventloop 都有自己的一个 Selector，我为了画图方便，改为共用一个 Selector</li>
<li>Boss Eventloop 负责 ACCEPT 事件，他在启动的时候向 Selector 注册 ACCPET 事件和 ServerChannel，并且绑定端口</li>
<li>Work EventloopGroup 是一组 Work Eventloop 的集合，数量默认为 CPU 核心数 *2</li>
<li>Work Eventloop 本质上是一个线程，他有一个死循环，执行两种事件：READ 事件和自己任务队列上面的事件</li>
<li>Work Eventloop 的任务队列上面的事件是可以在任何地方提交加入（通过 Future/Promise 的 addListener 方法提交任务）</li>
<li>Pipeline 是在我们启动的 Netty 的时候指定的，是我们的任务代码</li>
<li>Buffer 是缓冲区，缓冲我们的数据，并且一次写入。</li>
<li>Channel 是和用户连接的桥梁，往 Channel 写数据就是往用户电脑写数据</li>
<li>Pipeline 处理时可以选择同步模式还是异步模式，但无论如何最终都要刷写 Buffer ，最后要结束数据流。</li>
</ol>
</blockquote>
<p><img src="/" alt="Netty运行时处理请求的流程" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/Netty%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B.png"></p>
<h3 id="2、Netty-Pipeline-流程"><a href="#2、Netty-Pipeline-流程" class="headerlink" title="2、Netty Pipeline 流程"></a>2、Netty Pipeline 流程</h3><h4 id="a、InBound-操作的流水线"><a href="#a、InBound-操作的流水线" class="headerlink" title="a、InBound 操作的流水线"></a>a、InBound 操作的流水线</h4><blockquote>
<p>Inbound 的方法一般由系统 Netty 帮我们调用</p>
<ul>
<li><p>ChannelRegister ：</p>
<p>客户 Channel 注册到 Eventloop 里面会发送事件 （第一次连接）</p>
</li>
<li><p>ChannelActive ：</p>
<p>客户 Channel 连接的时候 Channel 会发送事件 （从未连接到已连接）</p>
</li>
<li><p>ChannelRead ：</p>
<p>客户的数据已经存了一部分到系统缓冲区的时候会发送事件 （从未发送数据到已发送数据）</p>
</li>
<li><p>ChannelReadComplete ：</p>
<p>缓冲区里面已经没有数据会发送事件（从发送数据到发送数据完成）</p>
</li>
</ul>
<p>调用的流程是一致的，主要用到的是 ChannelRead</p>
</blockquote>
<p><img src="/" alt="InBound 操作的流水线" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/InBound%20%E6%93%8D%E4%BD%9C%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF.png"></p>
<h4 id="b、OutBound-操作流水线"><a href="#b、OutBound-操作流水线" class="headerlink" title="b、OutBound 操作流水线"></a>b、OutBound 操作流水线</h4><blockquote>
<p>一般是主动调用，而不是Netty自动调用</p>
<p>bind 操作</p>
<p>connect 操作</p>
<p>disconnect 操作</p>
<p>read 操作 （ 一般不用，用 Inbound 的自动 Read ）</p>
<p>write 操作</p>
<p>deregister 操作</p>
</blockquote>
<p><img src="/" alt="OutBound 操作流水线" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/OutBound%20%E6%93%8D%E4%BD%9C%E6%B5%81%E6%B0%B4%E7%BA%BF.png"></p>
<h4 id="c、异常处理流水线"><a href="#c、异常处理流水线" class="headerlink" title="c、异常处理流水线"></a>c、异常处理流水线</h4><p><img src="/" alt="异常处理流水线" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E6%B0%B4%E7%BA%BF.png"></p>
<h4 id="d、业务中的流水线-参考"><a href="#d、业务中的流水线-参考" class="headerlink" title="d、业务中的流水线 ( 参考 )"></a>d、业务中的流水线 ( 参考 )</h4><p><img src="/" alt="业务中的流水线 ( 参考 )" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%20(%20%E5%8F%82%E8%80%83%20).png"></p>
<h2 id="四、常用类"><a href="#四、常用类" class="headerlink" title="四、常用类"></a>四、常用类</h2><h3 id="1、Channel"><a href="#1、Channel" class="headerlink" title="1、Channel"></a>1、<code>Channel</code></h3><blockquote>
<p>Channel 是 Netty 传输 API 的核心，它被用于所有的 I/O 操作。</p>
<p>基本的 I/O 操作（ bind() 、connect() 、read() 和 write() ）依赖于底层网络传输所提供的原语。在基于 Java 的网络编程中，其基本的构造是 class Socket 。Netty 的 Channel 接口所提供的 API，大大地降低了直接使用 Socket 类的复杂性。</p>
<p>Channel 实现是线程安全的，因此可以存储一个到 Channel 的引用，并且每当需要向远程节点写数据时，都可以使用它，即使当时许多线程都在使用它。需要注意的是，消息将会被保证按顺序发送。</p>
</blockquote>
<p><img src="/" alt="Channel 接口的层次结构" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/Channel%20%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png"></p>
<p>如图所示，每个 Channel 都将会被分配一个 ChannelPipeline 和 ChannelConfig 。ChannelConfig 包含了该 Channel 的所有配置设置，并且支持热更新。</p>
<h4 id="a、API"><a href="#a、API" class="headerlink" title="a、API"></a>a、API</h4><p><img src="/" alt="Channel API" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/Channel%20API.png"></p>
<h4 id="b、Channel-的生命周期"><a href="#b、Channel-的生命周期" class="headerlink" title="b、Channel 的生命周期"></a>b、Channel 的生命周期</h4><p><img src="/" alt="Channel 的生命周期状态" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/Channel%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%8A%B6%E6%80%81.png"></p>
<p><img src="/" alt="Channel 的状态模型" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/Channel%20%E7%9A%84%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png"></p>
<h4 id="c、ChannelOption"><a href="#c、ChannelOption" class="headerlink" title="c、ChannelOption"></a>c、ChannelOption</h4><blockquote>
<p>Netty 在创建 Channel 实例后，一般都需要设置 ChannelOption 参数。ChannelOption 是 Socket 的标准参数，而非 Netty 独创。 </p>
</blockquote>
<p><strong>API ：</strong></p>
<ul>
<li><strong>option</strong> ( ChannelOption  option , [ value ] )</li>
<li><strong>childOption</strong> ( ChannelOption  option , [ value ] )</li>
</ul>
<p><strong>配置参数 ：</strong></p>
<ul>
<li><p>SO_BACKLOG</p>
<p>对应 <code>TCP/IP</code> 协议 <code>listen</code> 函数中的 <code>backlog</code> 参数，用来初始化服务器等待队列的大小 。 </p>
</li>
<li><p>SO_KEEPALIVE</p>
<p>一直保持连接活动状态 。</p>
</li>
<li><p>SO_REUSEADDR</p>
<p>可控制是否将处于 Time-wait 状态的端口分配给其它连接</p>
<p>关于 Time-wait 问题，查看《TCP/IP 网络编程》147 页知识。</p>
</li>
<li><p>SO_SNDBUF 与 SO_RCVBUF</p>
<p>用于操作接收缓冲区和发送缓冲区的大小</p>
</li>
<li><p>SO_LINGER</p>
<p>当调用 close() 后，不是立即返回，而是可以阻塞 close() 的调用，直到数据完全发送</p>
</li>
<li><p>TCP_NODELAY</p>
<p>不管数据量多小，来一个发一个，与下面的 <strong>TCP_CORK</strong> 正好相反</p>
</li>
<li><p>TCP_CORK</p>
<p>等待要发送的数据量更大后，一次性发送，适用于文件传输，提高了网络的有效负载，但造成了延时</p>
</li>
</ul>
<h4 id="d、ChannelFuture"><a href="#d、ChannelFuture" class="headerlink" title="d、ChannelFuture"></a>d、ChannelFuture</h4><blockquote>
<p>Channel 中异步 I/O 操作的结果 。</p>
</blockquote>
<p><strong>API ：</strong></p>
<ul>
<li><p>Channel  channel ( )</p>
<p>返回当前正在进行 IO 操作的通道</p>
</li>
<li><p>ChannelFuture  sync ( )</p>
<p>等待异步操作执行完毕</p>
</li>
</ul>
<h3 id="2、ChannelHandler"><a href="#2、ChannelHandler" class="headerlink" title="2、ChannelHandler"></a>2、<code>ChannelHandler</code></h3><blockquote>
<p>通过继承 Channelhandler 的具体实现类来定义对 Channel 的处理。</p>
<p>ChannelHandler 还能动态的修改 ChannelHandlerPipeline ，ChannelHandler 可以通过添加、删除或者替换其他的 ChannelHandler 来实时地修改 ChannelPipeline 的布局。（它也可以将它自己从 ChannelPipeline中移除。）这是 ChannelHandler 最重要的能力之一。具体请查看 ChannelPipeline 章节。</p>
</blockquote>
<blockquote>
<p>ChannelHandler的典型用途包括：</p>
<ul>
<li><p>将数据从一种格式转换为另一种格式 ；</p>
</li>
<li><p>提供异常的通知 ；</p>
</li>
<li><p>提供 Channel 变为活动的或者非活动的通知 ；</p>
</li>
<li><p>提供当 Channel 注册到 EventLoop 或者从 EventLoop 注销时的通知 ；</p>
</li>
<li><p>提供有关用户自定义事件的通知</p>
</li>
</ul>
</blockquote>
<p><img src="/" alt="Channelhandler" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/Channelhandler.png"></p>
<h4 id="a、ChannelHandler-的生命周期方法"><a href="#a、ChannelHandler-的生命周期方法" class="headerlink" title="a、ChannelHandler 的生命周期方法"></a>a、ChannelHandler 的生命周期方法</h4><p><img src="/" alt="ChannelHandler 的生命周期方法" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ChannelHandler%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95.png"></p>
<h4 id="b、常用实现类："><a href="#b、常用实现类：" class="headerlink" title="b、常用实现类："></a>b、常用实现类：</h4><h5 id="ChannelInboundHandler"><a href="#ChannelInboundHandler" class="headerlink" title="ChannelInboundHandler"></a>ChannelInboundHandler</h5><p><img src="/" alt="ChannelInboundHandler 的方法" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ChannelInboundHandler%20%E7%9A%84%E6%96%B9%E6%B3%95.png"></p>
<h5 id="ChannelOutboundHandler"><a href="#ChannelOutboundHandler" class="headerlink" title="ChannelOutboundHandler"></a>ChannelOutboundHandler</h5><blockquote>
<p>ChannelOutboundHandler 的一个强大的功能是可以按需推迟操作或者事件，这使得可以通过一些复杂的方法来处理请求。例如，如果到远程节点的写入被暂停了，那么你可以推迟冲刷操作并在稍后继续。</p>
<p>每个出站操作都基于以下的通知机制：</p>
<ul>
<li>每个出站操作都将返回一个 ChannelFuture。注册到 ChannelFuture 的 ChannelFutureListener 将在操作完成时被通知该操作是成功了还是出错了。</li>
<li>几乎所有的 ChannelOutboundHandler 上的方法都会传入一个 ChannelPromise 的实例。作为 ChannelFuture 的子类，ChannelPromise 也可以被分配用于异步通知的监听器。但是，ChannelPromise 还具有提供立即通知的可写方法： <ul>
<li>ChannelPromise setSuccess ( )</li>
<li>ChannelPromise setFailure ( Throwable  cause )</li>
</ul>
</li>
</ul>
<p>添加 ChannelFutureListener 只需要调用 ChannelFuture 实例上的 addListener ( ChannelFutureListener ) 方法，并且有两种不同的方式可以做到这一点。</p>
<p>其中最常用的方式是，调用出站操作（ 如 write() 方法 ）所返回的 ChannelFuture 上的 addListener() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future = channel.write(someMessage);</span><br><span class="line">future.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!f.isSuccess()) &#123;</span><br><span class="line">            f.cause().printStackTrace();</span><br><span class="line">            f.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>第二种方式是将 ChannelFutureListener 添加到即将作为参数传递给 ChannelOutboundHandler 的方法的 ChannelPromise。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过调用 ChannelPromise 上的 setSuccess() 和 setFailure() 方法，</span></span><br><span class="line"><span class="comment">// 可以使一个操作的状态在 ChannelHandler 的方法执行完成后即刻被感知到。 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutboundExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        promise.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!f.isSuccess()) &#123;</span><br><span class="line">                    f.cause().printStackTrace();</span><br><span class="line">                    f.channel().close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这两种方式：</p>
<ul>
<li><p>对于细致的异常处理，在调用出站操作时添加 ChannelFutureListener 更合适。</p>
</li>
<li><p>而对于一般的异常处理，自定义的 ChannelOutboundHandler 实现的方式更加的简单。</p>
</li>
</ul>
</blockquote>
<p><img src="/" alt="ChannelOutboundHandler 的方法" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ChannelOutboundHandler%20%E7%9A%84%E6%96%B9%E6%B3%95.png"></p>
<p><strong>ChannelPromise 与 ChannelFuture：</strong></p>
<p>ChannelOutboundHandler 中的大部分方法都需要一个 ChannelPromise 参数，以便在操作完成时得到通知。ChannelPromise 是 ChannelFuture 的一个 子类，其定义了一些可写的方法，如：setSuccess() 和 setFailure()，从而使 ChannelFuture 不可变。</p>
<h5 id="SimpleChannelInboundHandler"><a href="#SimpleChannelInboundHandler" class="headerlink" title="SimpleChannelInboundHandler"></a>SimpleChannelInboundHandler</h5><p>它与 ChannelInboundHandler 的区别：</p>
<p>当 <code>ChannelRead0()</code> 方法完成时，SimpleChannelInboundHandler 将释放消息的 ByteBuf 的内存引用。而 ChannelInboundHandler 并不会在 <code>ChannelRead()</code> 方法完成时释放 ByteBuf 。( Netty 实战  P22 )</p>
<h4 id="c、ChannelHandler-适配器"><a href="#c、ChannelHandler-适配器" class="headerlink" title="c、ChannelHandler 适配器"></a>c、ChannelHandler 适配器</h4><blockquote>
<p>简化了 ChannelHandler 的编写</p>
</blockquote>
<p><img src="/" alt="ChannelHandlerAdapter 类的层次结构" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ChannelHandlerAdapter%20%E7%B1%BB%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png"></p>
<p>ChannelHandlerAdapter 还提供了实用方法 <code>isSharable()</code>。如果其对应的实现被标注为 Sharable，那么这个方法将返回 true，表示它可以被添加到多个 ChannelPipeline 中。在多个 ChannelPipeline 中安装同一个ChannelHandler 的一个常见的原因是用于收集跨越多个 Channel 的统计信息。 </p>
<h4 id="d、ChannelHandler-的执行和阻塞"><a href="#d、ChannelHandler-的执行和阻塞" class="headerlink" title="d、ChannelHandler 的执行和阻塞"></a>d、ChannelHandler 的执行和阻塞</h4><p>通常 ChannelPipeline 中的每一个 ChannelHandler 都是通过它的 EventLoop（I/O 线程）来处理传递给它的事件的。所以至关重要的是不要阻塞这个线程，因为这会对整体的 I/O 处理产生负面的影响。</p>
<p>但有时可能需要与那些使用阻塞 API 的遗留代码进行交互。对于这种情况，ChannelPipeline 有一些接受一个 EventExecutorGroup 的 add() 方法。如果一个事件被传递给一个自定义的 EventExecutorGroup，它将被包含在这个 EventExecutorGroup 中的某个 EventExecutor 所处理，从而被从该 Channel 本身的 EventLoop 中移除。对于这种用例，Netty 提供了一个叫 DefaultEventExecutorGroup 的默认实现。</p>
<h4 id="e、异常处理"><a href="#e、异常处理" class="headerlink" title="e、异常处理"></a>e、异常处理</h4><h5 id="处理入站异常"><a href="#处理入站异常" class="headerlink" title="处理入站异常"></a>处理入站异常</h5><blockquote>
<p>如果在处理入站事件的过程中有异常被抛出，那么它将从它在 ChannelInboundHandler 里被触发的那一点开始流经 ChannelPipeline 。要想处理这种类型的入站异常，需要在 ChannelInboundHandler 中重写 exceptionCaught() 方法。</p>
<p>因为异常将会继续按照入站方向流动（就像所有的入站事件一样），所以实现了前面所示逻辑的 ChannelInboundHandler 通常位于 ChannelPipeline 的最后。这确保了所有的入站异常都总是会被处理，无论这些异常发生在 ChannelPipeline 中的什么位置。</p>
<p>如果你不实现任何处理入站异常的逻辑（或者没有消费该异常）， 那么 Netty 将会记录该异常没有被处理的事实：即 Netty 将会通过 Warning 级别的日志记录该异常到达了 ChannelPipeline 的尾端，但没有被处理，并尝试释放该异常。</p>
</blockquote>
<p><strong>总结：</strong></p>
<ul>
<li>ChannelHandler.exceptionCaught() 的默认实现是简单地将当前异常转发给 ChannelPipeline 中的下一个 ChannelHandler；</li>
<li>如果异常到达了 ChannelPipeline 的尾端，它将会被记录为未被处理；</li>
<li>要想定义自定义的处理逻辑，需要重写 exceptionCaught() 方法。然后决定是否需要将该异常传播出去。</li>
</ul>
<h5 id="处理出站异常"><a href="#处理出站异常" class="headerlink" title="处理出站异常"></a>处理出站异常</h5><blockquote>
<p>参考 ChannelHandler 的 常用实现类 的 ChannelOutBoundHandler</p>
</blockquote>
<ul>
<li><p>对于细致的异常处理，在调用出站操作时添加 ChannelFutureListener 更合适。</p>
</li>
<li><p>而对于一般的异常处理，自定义的 ChannelOutboundHandler 实现的方式更加的简单。</p>
</li>
</ul>
<p>如果你的 ChannelOutboundHandler 本身抛出了异常会发生什么呢？在这种情况下， Netty本身会通知任何已经注册到对应ChannelPromise的监听器。</p>
<h3 id="3、ChannelPipeline"><a href="#3、ChannelPipeline" class="headerlink" title="3、ChannelPipeline"></a>3、<code>ChannelPipeline</code></h3><blockquote>
<p>记录了处理流程中用到的 <code>ChannelHandler</code> 和 <code>ChannelHandlerContext</code> 。</p>
<p>每一个新创建的 Channel 都将会被分配一个新的 ChannelPipeline。这项关联是永久性的；Channel 既不能附加另外一个 ChannelPipeline，也不能分离其当前的。在 Netty 组件的生命周期中，这是一项固定的操作，不需要开发人员的任何干预。</p>
<p>根据事件的起源，事件将会被 ChannelInboundHandler 或者 ChannelOutboundHandler 处理。随后，通过调用 ChannelHandlerContext 实现，它将被转发给同一超类型的下一个 ChannelHandler。  </p>
</blockquote>
<p>ChannelHandler 安装到 ChannelPipeline 中的过程如下所示：</p>
<ol>
<li>一个 ChannelInitializer 的实现被注册到了 ServerBootstrap 中 ；</li>
<li>当 ChannelInitializer.initChannel() 方法被调用时，ChannelInitializer 将在 ChannelPipeline 中安装一组自定义的 ChannelHandler；</li>
<li>ChannelInitializer 将它自己从 ChannelPipeline 中移除。 </li>
</ol>
<p><img src="/" alt="Channel、ChannelPipeline、ChannelHandler 以及 ChannelHandlerContext 之间的关系" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/Channel%E3%80%81ChannelPipeline%E3%80%81ChannelHandler%20%E4%BB%A5%E5%8F%8A%20ChannelHandlerContext%20%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p>
<h4 id="a、常用-API"><a href="#a、常用-API" class="headerlink" title="a、常用 API"></a>a、常用 API</h4><p><img src="/" alt="ChannelPipeline 的用于访问 ChannelHandler 的操作" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ChannelPipeline%20%E7%9A%84%E7%94%A8%E4%BA%8E%E8%AE%BF%E9%97%AE%20ChannelHandler%20%E7%9A%84%E6%93%8D%E4%BD%9C.png"></p>
<p><img src="/" alt="ChannelHandler 的入站操作" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ChannelHandler%20%E7%9A%84%E5%85%A5%E7%AB%99%E6%93%8D%E4%BD%9C.png"></p>
<p><img src="/" alt="ChannelHandler 的出站操作" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ChannelHandler%20%E7%9A%84%E5%87%BA%E7%AB%99%E6%93%8D%E4%BD%9C.png"></p>
<h4 id="b、ChannelPipeline-的修改"><a href="#b、ChannelPipeline-的修改" class="headerlink" title="b、ChannelPipeline 的修改"></a>b、ChannelPipeline 的修改</h4><p><img src="/" alt="ChannelHandler 的用于修改 ChannelPipeline 的方法" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ChannelHandler%20%E7%9A%84%E7%94%A8%E4%BA%8E%E4%BF%AE%E6%94%B9%20ChannelPipeline%20%E7%9A%84%E6%96%B9%E6%B3%95.png"></p>
<h3 id="4、ChannelHandlerContext"><a href="#4、ChannelHandlerContext" class="headerlink" title="4、ChannelHandlerContext"></a>4、<code>ChannelHandlerContext</code></h3><blockquote>
<p>ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandlerContext。</p>
<p>ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。</p>
<p>ChannelHandlerContext 有很多的方法，其中一些方法也存在于 Channel 和 ChannelPipeline 本身上，但是有一点重要的不同。如果调用 Channel 或者 ChannelPipeline 上的这些方法，它们将沿着整个 ChannelPipeline 进行传播。而调用位于 ChannelHandlerContext 上的相同方法，则将从当前所关联的 ChannelHandler 开始，并传播给位于该 ChannelPipeline 中的下一个能够处理该事件的 ChannelHandler 。</p>
</blockquote>
<p>调用的 Channel 或 ChannelPipeline 上的 write() 方法将一直传播事件通过整个 ChannelPipeline，但是在 ChannelHandler 的级别上，事件从一个 ChannelHandler 到下一个 ChannelHandler 的移动是由 ChannelHandlerContext 上的调用完成的。 </p>
<p><img src="/" alt="通过 Channel 或者 ChannelPipeline 进行的事件传播" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E9%80%9A%E8%BF%87%20Channel%20%E6%88%96%E8%80%85%20ChannelPipeline%20%E8%BF%9B%E8%A1%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD.png"></p>
<p>调用 ChannelHandlerContext 的 write() 方法，消息将从下一个 ChannelHandler 开始流经 ChannelPipeline，绕过了所有前面的 ChannelHandler 。</p>
<p><img src="/" alt="通过 ChannelHandlerContext 触发的操作的事件流" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E9%80%9A%E8%BF%87%20ChannelHandlerContext%20%E8%A7%A6%E5%8F%91%E7%9A%84%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81.png"></p>
<h4 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h4><blockquote>
<p>当使用 ChannelHandlerContext 的 API 的时候，要牢记以下两点：</p>
<ul>
<li>ChannelHandlerContext 和 ChannelHandler 之间的关联（绑定）是永远不会改变的，所以缓存对它的引用是安全的；</li>
<li>相对于其他类的同名方法，ChannelHandlerContext 的方法将产生更短的事件流，应该尽可能地利用这个特性来获得最大的性能。</li>
</ul>
</blockquote>
<p><img src="/" alt="ChannelHandlerContext 的 API" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ChannelHandlerContext%20%E7%9A%84%20API.png"></p>
<h3 id="5、EventLoop"><a href="#5、EventLoop" class="headerlink" title="5、EventLoop"></a>5、<code>EventLoop</code></h3><blockquote>
<p>EventLoop 定义了 Netty 的核心抽象，它用于处理连接的生命周期中所发生的事件。</p>
<p><strong>EventLoopGroup</strong> 是一组 <strong>EventLoop</strong> 的抽象。</p>
<p><strong>EventLoopGroup</strong> 提供 <strong>next</strong> 接口，可以从组里面按照一定规则获取其中一个 <strong>EventLoop</strong> 来处理任务。</p>
<p>在 Netty 编程中，需要为服务端提供两个 <strong>EventLoopGroup</strong>。</p>
</blockquote>
<h4 id="a、EventLoop-流程概览"><a href="#a、EventLoop-流程概览" class="headerlink" title="a、EventLoop 流程概览"></a>a、EventLoop 流程概览</h4><p>在这里我们将服务端的两个 EventLoopGroup，分别命名为：BossEventLoopGroup 和 WorkerEventLoopGroup 。</p>
<p>通常一个服务端口（即：一个 ServerSocketChannel ）对应一个 Selector 和一个 EventLoop ( BossEventLoop ) 线程。</p>
<p>BossEventLoop 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理，如下图所示：</p>
<p><img src="/" alt="服务端 EventLoopGroup 原理" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E6%9C%8D%E5%8A%A1%E7%AB%AF%20EventLoopGroup%20%E5%8E%9F%E7%90%86.jpg"></p>
<p>BossEventLoopGroup 通常是一个单线程的 EventLoop，该 EventLoop 维护着一个注册了 ServerSocketChannel 的 Selector 实例，BossEventLoop 不断轮询 Selector 将连接事件分离出来， 通常是 OP_ACCEPT 事件，然后将接收到的 SocketChannel 交给 WorkerEventLoopGroup， WorkerEventLoopGroup 会由 next 选择其中一个 EventLoop 来将这个 SocketChannel 注册到其维护的 Selector 并对其后续的 IO 事件进行处理。 </p>
<h4 id="b、Netty-的线程模型"><a href="#b、Netty-的线程模型" class="headerlink" title="b、Netty 的线程模型"></a>b、Netty 的线程模型</h4><p>如图所示：<code>io.netty.util.concurrent</code> 包构建在 JDK 的 <code>java.util.concurrent</code> 包上，用来提供线程执行器。其次，<code>io.netty.channel</code> 包中的类，为了与 Channel 的事件进行交互， 扩展了这些接口/类。</p>
<p><img src="/" alt="EventLoop 的类层次结构" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/EventLoop%20%E7%9A%84%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png"></p>
<p>在这个模型中，一个 EventLoop 将由一个永远都不会改变的 Thread 驱动，同时任务（ Runnable 或者 Callable ）可以直接提交给 EventLoop 实现，以立即执行或者调度执行。根据配置和可用核心的不同，可能会创建多个 EventLoop 实例用以优化资源的使用，并且单个 EventLoop 可能会被指派用于服务多个 Channel。</p>
<p>需要注意的是，Netty 的 EventLoop 在继承了 ScheduledExecutorService 的同时，只定义了一个方法， parent() 。这个方法，用于返回到当前 EventLoop 实现的实例所属的 EventLoopGroup 的引用。</p>
<h4 id="c、Netty-4-中的-I-O-和事件处理"><a href="#c、Netty-4-中的-I-O-和事件处理" class="headerlink" title="c、Netty 4 中的 I/O 和事件处理"></a>c、Netty 4 中的 I/O 和事件处理</h4><p>正如前面所详细描述的，由 I/O 操作触发的事件将流经安装了一个或者多个 ChannelHandler 的 ChannelPipeline 。传播这些事件的方法调用可以随后被 ChannelHandler 所拦截，并且可以按需地处理事件。 </p>
<p>事件的性质通常决定了它将被如何处理；它可能将数据从网络栈中传递到你的应用程序中，或者进行逆向操作，或者执行一些截然不同的操作。但是事件的处理逻辑必须足够的通用和灵活，以处理所有可能的用例。</p>
<p>因此，在 Netty 4 中，所有的 I/O 操作和事件都由分配给 EventLoop 的那个 Thread 来处理。这不同于 Netty 3 中所使用的模型。( 这里使用的是“来处理”而不是“来触发”，其中写操作是可以从外部的任意线程触发的。)</p>
<h4 id="d、EventLoop-的任务调度"><a href="#d、EventLoop-的任务调度" class="headerlink" title="d、EventLoop 的任务调度"></a>d、EventLoop 的任务调度</h4><h5 id="Java-的任务调度-API"><a href="#Java-的任务调度-API" class="headerlink" title="Java 的任务调度 API"></a>Java 的任务调度 API</h5><p><img src="/" alt="java.util.concurrent.Executors 类的工厂方法" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/java.util.concurrent.Executors%E7%B1%BB%E7%9A%84%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.png"></p>
<p><strong>代码示例：</strong></p>
<p>使用 ScheduledExecutorService 来在 60 秒的延迟之后执行一个任务：</p>
<p><img src="/" alt="ScheduledExecutorService 代码示例" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ScheduledExecutorService%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B.png"></p>
<p>虽然 ScheduledExecutorService API 是直截了当的，但是在高负载下它将带来性能上的负担。</p>
<h5 id="使用-EventLoop-调度任务"><a href="#使用-EventLoop-调度任务" class="headerlink" title="使用 EventLoop 调度任务"></a>使用 EventLoop 调度任务</h5><p>ScheduledExecutorService 的实现具有局限性，例如，事实上作为线程池管理的一部分，将会有额外的线程创建。如果有大量任务被紧凑地调度，那么这将成为一个瓶颈。Netty 通过 Channel 的 EventLoop 实现任务调度解决了这一问题。</p>
<p><img src="/" alt="EventLoop 调度任务" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/EventLoop%20%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1.png"></p>
<p>经过 60 秒之后，Runnable 实例将由分配给 Channel 的 EventLoop 执行。如果要调度任务以每隔 60 秒执行一次，可以使用 scheduleAtFixedRate() 方法：</p>
<p><img src="/" alt="使用 EventLoop 调度周期性的任务" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E4%BD%BF%E7%94%A8%20EventLoop%20%E8%B0%83%E5%BA%A6%E5%91%A8%E6%9C%9F%E6%80%A7%E7%9A%84%E4%BB%BB%E5%8A%A1.png"></p>
<p>如前面图中所显示的，Netty 的 EventLoop 扩展了 ScheduledExecutorService，所以 JDK 实现的方法，EventLoop 亦有，包括在前面的示例中使用到的 schedule() 和 scheduleAtFixedRate() 方法。</p>
<p>若要想取消或者检查（被调度任务的）执行状态，可以使用每个异步操作所返回的 ScheduledFuture。下面的代码展示了一个简单的取消操作：</p>
<p><img src="/" alt="使用 ScheduledFuture 取消任务" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E4%BD%BF%E7%94%A8%20ScheduledFuture%20%E5%8F%96%E6%B6%88%E4%BB%BB%E5%8A%A1.png"></p>
<h4 id="e、EventLoop-的任务调度实现细节"><a href="#e、EventLoop-的任务调度实现细节" class="headerlink" title="e、EventLoop 的任务调度实现细节"></a>e、EventLoop 的任务调度实现细节</h4><h5 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h5><p>如果（当前）调用线程正是支撑 EventLoop 的线程，那么所提交的代码块将会被（直接） 执行。否则，EventLoop 将调度该任务以便稍后执行，并将它放入到内部队列中。当 EventLoop 下次处理它的事件时，它会执行队列中的那些任务/事件。这也就解释了任何的 Thread 是如何 与Channel 直接交互而无需在 ChannelHandler 中进行额外同步的。</p>
<p>注意，每个 EventLoop 都有它自已的任务队列，独立于任何其他的 EventLoop。下图展示了 EventLoop 用于调度任务的执行逻辑。这是 Netty 线程模型的关键组成部分。</p>
<p><img src="/" alt="EventLoop 的执行逻辑" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/EventLoop%20%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png"></p>
<p>之前已经阐明了不要阻塞当前 I/O 线程的重要性。我们再以另一种方式重申一次：“永远不要将一个长时间运行的任务放入到执行队列中，因为它将阻塞需要在同一线程上执行的任何其他任务。” 如果必须要进行阻塞调用或者执行长时间运行的任务，我们建议使用一个专门的 EventExecutor。（ 可以看 ChannelHandler 的 ChannelHandler 的执行与阻塞 ）</p>
<h5 id="EventLoop-线程的分配"><a href="#EventLoop-线程的分配" class="headerlink" title="EventLoop/线程的分配"></a>EventLoop/线程的分配</h5><blockquote>
<p>服务于 Channel 的 I/O 和事件的 EventLoop 包含在 EventLoopGroup 中。根据不同的传输实现，EventLoop 的创建和分配方式也不同。 </p>
</blockquote>
<p><strong>1、异步传输</strong></p>
<p>异步传输实现只使用了少量的 EventLoop（以及和它们相关联的Thread），而且在 Netty 的线程模型中，EventLoop 可能会被多个 Channel 所共享。这使得可以通过尽可能少量的 Thread 来支撑大量的 Channel，而不是每个 Channel 分配一个 Thread 。</p>
<p><img src="/" alt="用于非阻塞传输（ 如 NIO 和 AIO ）的 EventLoop 分配方式" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E7%94%A8%E4%BA%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E4%BC%A0%E8%BE%93%EF%BC%88%20%E5%A6%82%20NIO%20%E5%92%8C%20AIO%20%EF%BC%89%E7%9A%84%20EventLoop%20%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F.png"></p>
<p>EventLoopGroup 负责为每个新创建的 Channel 分配一个 EventLoop。在当前实现中，使用顺序循环（ round-robin ）的方式进行分配以获取一个均衡的分布，并且相同的 EventLoop 可能会被分配给多个 Channel 。（这一点在将来的版本中可能会改变。）</p>
<p>注意：EventLoop 的分配方式对 ThreadLocal 的使用的影响。因为一个 EventLoop 通常会被用于支撑多个 Channel，所以对于所有相关联的 Channel 来说， ThreadLocal 都将是一样的。这使得它对于实现状态追踪等功能来说是个糟糕的选择。然而，在一些无状态的上下文中，它仍然可以被用于在多个 Channel 之间共享一些重度的或者代价昂贵的对象，甚至是事件。</p>
<p><strong>2、阻塞传输</strong></p>
<p>用于像 OIO（旧的阻塞 I/O）这样的其他传输的设计略有不同，阻塞传输中每一个 Channel 都将被分配给一个 EventLoop 并且独占（以及它的 Thread）。</p>
<p><img src="/" alt="阻塞传输（如 OIO）的 EventLoop 分配方式" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E9%98%BB%E5%A1%9E%E4%BC%A0%E8%BE%93%EF%BC%88%E5%A6%82%20OIO%EF%BC%89%E7%9A%84%20EventLoop%20%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F.png"></p>
<p>但是，如同异步传输一样，得到的保证是：每个 Channel 的 I/O 事件都将只会被一个 Thread （用于支撑该 Channel 的 EventLoop 的那个 Thread）处理。</p>
<h4 id="f、EventLoop-与-Channel-的绑定"><a href="#f、EventLoop-与-Channel-的绑定" class="headerlink" title="f、EventLoop 与 Channel 的绑定"></a>f、EventLoop 与 Channel 的绑定</h4><ul>
<li><p>一个 Channel 在生命周期中只注册于一个 EventLoop</p>
</li>
<li><p>一个 EventLoop 可能负责多个 Channel</p>
</li>
<li><p>一个 EventLoop 在生命周期中只和一个 Thread 绑定</p>
</li>
<li><p>所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理</p>
</li>
</ul>
<h4 id="g、API"><a href="#g、API" class="headerlink" title="g、API"></a>g、API</h4><ul>
<li><p>Future&lt;?&gt;  <strong>shutdownGracefully</strong> ( )</p>
<p>断开连接，关闭线程</p>
</li>
</ul>
<h3 id="6、引导"><a href="#6、引导" class="headerlink" title="6、引导"></a>6、引导</h3><p><img src="/" alt="引导类的层次结构" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E5%BC%95%E5%AF%BC%E7%B1%BB%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png"></p>
<p><img src="/" alt="相互兼容的 EventLoopGroup 和 Channel" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E7%9B%B8%E4%BA%92%E5%85%BC%E5%AE%B9%E7%9A%84%20EventLoopGroup%20%E5%92%8C%20Channel.png"></p>
<h4 id="a、引导客户端"><a href="#a、引导客户端" class="headerlink" title="a、引导客户端"></a>a、引导客户端</h4><blockquote>
<p>Bootstrap 类负责为客户端和使用无连接协议的应用程序创建 Channel 。</p>
</blockquote>
<p><img src="/" alt="客户端的引导过程" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%BC%95%E5%AF%BC%E8%BF%87%E7%A8%8B.png"></p>
<blockquote>
<p><img src="/" alt="引导一个客户端" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E5%BC%95%E5%AF%BC%E4%B8%80%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF.png"></p>
</blockquote>
<p><img src="/" alt="Bootstrap 类的 API" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/Bootstrap%20%E7%B1%BB%E7%9A%84%20API.png"></p>
<h4 id="b、引导服务器"><a href="#b、引导服务器" class="headerlink" title="b、引导服务器"></a>b、引导服务器</h4><blockquote>
<p>ServerBootstrap 类负责引导服务端 。</p>
</blockquote>
<p><img src="/" alt="ServerBootstrap 和 ServerChannel" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ServerBootstrap%20%E5%92%8C%20ServerChannel.png"></p>
<blockquote>
<p><img src="/" alt="引导服务器" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E5%BC%95%E5%AF%BC%E6%9C%8D%E5%8A%A1%E5%99%A8.png"></p>
</blockquote>
<p><img src="/" alt="ServerBootstrap 类的方法" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ServerBootstrap%20%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95.png"></p>
<h4 id="c、引导-DatagramChannel"><a href="#c、引导-DatagramChannel" class="headerlink" title="c、引导 DatagramChannel"></a>c、引导 DatagramChannel</h4><blockquote>
<p>前面的引导代码示例使用的都是基于 TCP 协议的 SocketChannel，但是 Bootstrap 类也可以被用于无连接的协议。</p>
<p>为此，Netty 提供了各种 DatagramChannel 的实现。</p>
<p><strong>唯一区别就是，不再调用 connect() 方法，而是只调用 bind() 方法。</strong></p>
</blockquote>
<p><img src="/" alt="使用 Bootstrap 和 DatagramChannel" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E4%BD%BF%E7%94%A8%20Bootstrap%20%E5%92%8C%20DatagramChannel.png"></p>
<h4 id="d、从-Channel-引导客户端"><a href="#d、从-Channel-引导客户端" class="headerlink" title="d、从 Channel 引导客户端"></a>d、从 Channel 引导客户端</h4><blockquote>
<p>假设你的服务器正在处理一个客户端的请求，这个请求需要它充当第三方系统的客户端。当一个应用程序（如一个代理服务器）必须要和组织现有的系统（如：Web 服务或者数据库）集成时，就可能发生这种情况。在这种情况下，将需要从已经被接受的子 Channel 中引导一个客户端 Channel。</p>
<p>你可以按照前面讲解的“引导客户端”中所描述的方式创建新的 Bootstrap 实例，但是这并不是最高效的解 决方案，因为它将要求你为每个新创建的客户端 Channel 定义另一个 EventLoop。这会产生额外的线程，以及在已被接受的子 Channel 和客户端 Channel 之间交换数据时不可避免的上下文切换。 </p>
<p>一个更好的解决方案是：通过将已被接受的子 Channel 的 EventLoop 传递给 Bootstrap 的 group() 方法来共享该 EventLoop。因为分配给 EventLoop 的所有 Channel 都使用同一个线程，所以这避免了额外的线程创建，以及前面所提到的相关的上下文切换。这个共享的解决方案如下图所示。</p>
</blockquote>
<p><img src="/" alt="在两个 Channel 之间共享 EventLoop" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E5%9C%A8%E4%B8%A4%E4%B8%AA%20Channel%20%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%20EventLoop.png"></p>
<p><img src="/" alt="引导服务器并从 Channel 引导客户端" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E5%BC%95%E5%AF%BC%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E4%BB%8E%20Channel%20%E5%BC%95%E5%AF%BC%E5%AE%A2%E6%88%B7%E7%AB%AF.png"></p>
<h4 id="e、在引导过程中添加多个-ChannelHandler"><a href="#e、在引导过程中添加多个-ChannelHandler" class="headerlink" title="e、在引导过程中添加多个 ChannelHandler"></a>e、在引导过程中添加多个 ChannelHandler</h4><p>Netty 提供了一个特殊的 ChannelInboundHandlerAdapter 子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInitializer</span>&lt; <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span> &gt; <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span></span><br></pre></td></tr></table></figure>

<p>它定义了下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(C ch)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法提供了一种将多个 ChannelHandler 添加到一个 ChannelPipeline 中的简便方法。你只需要简单地向 Bootstrap 或 ServerBootstrap 的实例提供你的 ChannelInitializer实现即可，并且一旦 Channel 被注册到了它的 EventLoop 之后，就会调用你的 initChannel() 版本。在该方法返回之后，ChannelInitializer 的实例将会从 ChannelPipeline 中移除它自己。</p>
<h4 id="f、ChannelOption-和-属性"><a href="#f、ChannelOption-和-属性" class="headerlink" title="f、ChannelOption 和 属性"></a>f、ChannelOption 和 属性</h4><blockquote>
<p>Netty 应用程序通常与组织的专有软件集成在一起，而像 Channel 这样的组件可能甚至会在正常的 Netty 生命周期之外被使用。在某些常用的属性和数据不可用时，Netty 提供了 AttributeMap 抽象（一个由 Channel 和引导类提供的集合）以及 AttributeKey<T>（一 个用于插入和获取属性值的泛型类）。使用这些工具，便可以安全地将任何类型的数据项与客户端和服务器 Channel（包含ServerChannel的子Channel）相关联了。</p>
<p>例如，考虑一个用于跟踪用户和 Channel 之间的关系的服务器应用程序。这可以通过将用户的 ID 存储为 Channel 的一个属性来完成。类似的技术可以被用来基于用户的 ID 将消息路由给用户，或者关闭活动较少的 Channel。</p>
</blockquote>
<p><img src="/" alt="使用属性值" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E4%BD%BF%E7%94%A8%E5%B1%9E%E6%80%A7%E5%80%BC.png"></p>
<h4 id="g、关闭"><a href="#g、关闭" class="headerlink" title="g、关闭"></a>g、关闭</h4><blockquote>
<p>引导使你的应用程序启动并且运行起来，但是迟早你都需要优雅地将它关闭。当然，你也可以让 JVM 在退出时处理好一切，但是这不符合优雅的定义，优雅是指干净地释放资源。关闭 Netty 应用程序并没有太多的魔法，但是还是有些事情需要记在心上。</p>
<p>最重要的是，你需要关闭 EventLoopGroup，它将处理任何挂起的事件和任务，并且随后释放所有活动的线程。这就是调用 <code>EventLoopGroup.shutdownGracefully()</code> 方法的作用。 这个方法调用将会返回一个 Future，这个Future将在关闭完成时接收到通知。需要注意的是，<code>shutdownGracefully()</code> 方法也是一个异步的操作，所以你需要阻塞等待直到它完成，或者向所返回的 Future 注册一个监听器以在关闭完成时获得通知。</p>
</blockquote>
<p><img src="/" alt="优雅的关闭" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E4%BC%98%E9%9B%85%E7%9A%84%E5%85%B3%E9%97%AD.png"></p>
<p>或者，你也可以在调用 <code>EventLoopGroup.shutdownGracefully()</code> 方法之前，显式地在所有活动的 Channel  上调用 <code>Channel.close()</code> 方法。<strong>但是在任何情况下，都请记得关闭 EventLoopGroup 本身。</strong></p>
<h2 id="五、ByteBuf"><a href="#五、ByteBuf" class="headerlink" title="五、ByteBuf"></a>五、<code>ByteBuf</code></h2><blockquote>
<p><a href="https://my.oschina.net/7001/blog/742236" target="_blank" rel="noopener">参考文章</a></p>
<p>ByteBuf 是一个 byte 数组的缓冲区，<strong>通过两个位置指针完成缓冲区的读写操作</strong>，读操作为 readerIndex 指针，写操作为 writeIndex 指针 。</p>
<p>调用 <code>clear()</code> 可重置 readerIndex 和 writeIndex 为 0，<strong>但该操作不会清理 buffer 中的内容</strong>。</p>
</blockquote>
<h3 id="1、ByteBuf-的使用模式"><a href="#1、ByteBuf-的使用模式" class="headerlink" title="1、ByteBuf 的使用模式"></a>1、ByteBuf 的使用模式</h3><h4 id="堆缓冲区"><a href="#堆缓冲区" class="headerlink" title="堆缓冲区"></a>堆缓冲区</h4><blockquote>
<p>将数据存储在 JVM 的堆空间中，这种模式又被称为：支撑数组 。</p>
<p>它可以在没有使用池化的情况下提供快速的分配和释放。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf heapBuf = ...;</span><br><span class="line"><span class="keyword">if</span> (heapBuf.hasArray())&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] array = heapBuf.array();         </span><br><span class="line">    <span class="keyword">int</span> offset = heapBuf.arrayOffset() + heapBuf.readerIndex();</span><br><span class="line">    <span class="keyword">int</span> length = heapBuf.readableBytes();</span><br><span class="line">    handleArray(array, offset, length); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><blockquote>
<p>将数据存储在本地内存。</p>
<ul>
<li><p><strong>作用：</strong></p>
<p>这主要是为了避免在每次调用本地 I/O 操作之前（或者之后）将缓冲区的内容复制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。</p>
</li>
<li><p><strong>直接缓冲区对于网络数据传输是理想的选择：</strong></p>
<p>因为，当你的数据是在一个在堆缓冲区中时，在通过套接字发送它之前，JVM 将会在内部把你的缓冲区复制到一个直接缓冲区中。</p>
</li>
<li><p><strong>缺点：</strong></p>
<p>相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf directBuf = ...;  </span><br><span class="line"><span class="keyword">if</span> (!directBuf.hasArray()) &#123;      </span><br><span class="line">    <span class="keyword">int</span> length = directBuf.readableBytes();      </span><br><span class="line">    <span class="keyword">byte</span>[] array = <span class="keyword">new</span> <span class="keyword">byte</span>[length];               </span><br><span class="line">    directBuf.getBytes(directBuf.readerIndex(), array);      </span><br><span class="line">    handleArray(array, <span class="number">0</span>, length);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复合缓冲区-CompositeByteBuf"><a href="#复合缓冲区-CompositeByteBuf" class="headerlink" title="复合缓冲区    CompositeByteBuf"></a>复合缓冲区    <code>CompositeByteBuf</code></h4><blockquote>
<p>复合缓冲区为多个 ByteBuf 提供一个聚合视图。使用复合缓冲区可以根据需要添加或者删除 ByteBuf 实例。</p>
<p>Netty 通过一个 ByteBuf 子类 —— CompositeByteBuf —— 实现了这个模式，它提供了一 个将多个缓冲区表示为单个合并缓冲区的虚拟表示。</p>
<p>注意：CompositeByteBuf 中的 ByteBuf 实例可能同时包含直接内存分配和非直接内存分配。 如果其中只有一个实例，那么对 CompositeByteBuf 上的 hasArray() 方法的调用将返回该组件上的 hasArray() 方法的值；否则它将返回 false 。 </p>
</blockquote>
<h3 id="2、API"><a href="#2、API" class="headerlink" title="2、API"></a>2、API</h3><h4 id="a、查找操作-ByteProcessor"><a href="#a、查找操作-ByteProcessor" class="headerlink" title="a、查找操作    ByteProcessor"></a>a、查找操作    <code>ByteProcessor</code></h4><p><strong>简单的：</strong></p>
<ul>
<li>使用 indexOf 方法</li>
</ul>
<p><strong>复杂的：</strong></p>
<ul>
<li><p>使用 ByteProcessor 接口，该接口定义了一个方法：<code>boolean process(byte value)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 ByteProcessor 来寻找以 NULL 结尾的</span></span><br><span class="line">forEachByte(ByteBufProcessor.FIND_NUL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 ByteProcessor 来寻找 \r</span></span><br><span class="line">ByteBuf buffer = ...;</span><br><span class="line"><span class="keyword">int</span> index = buffer.forEachByte(ByteBufProcessor.FIND_CR);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="b、派生缓冲区"><a href="#b、派生缓冲区" class="headerlink" title="b、派生缓冲区"></a>b、派生缓冲区</h4><blockquote>
<p>对派生缓冲区的修改相当于修改源缓冲区。</p>
</blockquote>
<p><strong>派生缓冲区的创建：</strong></p>
<ul>
<li><p>duplicate ( )</p>
</li>
<li><p>slice ( )</p>
</li>
<li><p>slice ( int , int )</p>
</li>
<li><p>Unpooled.unmodifiableBuffer ( … )</p>
</li>
<li><p>order ( ByteOrder )</p>
</li>
<li><p>readSlice ( int )</p>
</li>
</ul>
<p><strong>ByteBuf 复制：</strong></p>
<p>如果需要一个现有缓冲区的真实副本，请使用 copy() 或者 copy(int, int) 方 法。不同于派生缓冲区，由这个调用所返回的 ByteBuf 拥有独立的数据副本。</p>
<h4 id="c、读-写操作"><a href="#c、读-写操作" class="headerlink" title="c、读/写操作"></a>c、读/写操作</h4><blockquote>
<p>有两类读/写操作：</p>
<ul>
<li>get() 和 set() 操作，从给定的索引开始，并且保持索引不变；</li>
<li>read() 和 write() 操作，从给定的索引开始，并且会根据已经访问过的字节数对索引进行调整。 </li>
</ul>
</blockquote>
<p><img src="/" alt="get 操作" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/get%20%E6%93%8D%E4%BD%9C.png"></p>
<p><img src="/" alt="set 操作" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/set%20%E6%93%8D%E4%BD%9C.png"></p>
<p><img src="/" alt="read 操作" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/read%20%E6%93%8D%E4%BD%9C.png"></p>
<p><img src="/" alt="write 操作" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/write%20%E6%93%8D%E4%BD%9C.png"></p>
<h4 id="d、其它操作"><a href="#d、其它操作" class="headerlink" title="d、其它操作"></a>d、其它操作</h4><p><img src="/" alt="其它操作" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E5%85%B6%E5%AE%83%E6%93%8D%E4%BD%9C.png"></p>
<h5 id="释放空间："><a href="#释放空间：" class="headerlink" title="释放空间："></a>释放空间：</h5><table>
<thead>
<tr>
<th>方法名称</th>
<th>返回值</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>discardReadBytes ( )</td>
<td>ByteBuf</td>
<td>将可读数据整体向前移动到下标为 0 处。该操作会发生字节数据的内存复制，频繁调用会导致性能下降。</td>
</tr>
<tr>
<td>discardSomeReadBytes ( )</td>
<td>ByteBuf</td>
<td>功能和 discardReadBytes() 相似，不同之处在于可定制要释放的空间，依赖于具体实现</td>
</tr>
</tbody></table>
<h5 id="索引操作："><a href="#索引操作：" class="headerlink" title="索引操作："></a>索引操作：</h5><table>
<thead>
<tr>
<th>方法名称</th>
<th>返回值</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>markReaderIndex ( )<br />markWriterIndex ( )<br />resetWriterIndex ( )<br />resetReaderIndex ( )</td>
<td></td>
<td>标记和重置 ByteBuf 的 readerIndex 和 writerIndex</td>
</tr>
<tr>
<td>readerIndex ( int )<br />writerIndex ( int )</td>
<td></td>
<td>将索引移动到指定位置</td>
</tr>
<tr>
<td>clear ( )</td>
<td></td>
<td>将 readerIndex 和 writerIndex 都设置为 0。但，这并不会清除内存中的内容</td>
</tr>
</tbody></table>
<h5 id="引用计数："><a href="#引用计数：" class="headerlink" title="引用计数："></a>引用计数：</h5><table>
<thead>
<tr>
<th>方法名称</th>
<th>返回值</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>retain ( )</td>
<td>ByteBuf</td>
<td>将引用计数增加1，或指定数</td>
</tr>
<tr>
<td>release ( )</td>
<td>ByteBuf</td>
<td>将引用计数减1，或指定数</td>
</tr>
</tbody></table>
<h3 id="3、ByteBufHoler"><a href="#3、ByteBufHoler" class="headerlink" title="3、ByteBufHoler"></a>3、ByteBufHoler</h3><blockquote>
<p>ByteBufHolder 也为 Netty 的高级特性提供了支持，如：缓冲区池化 ( 可以从池中借用 ByteBuf，并且在需要时自动释放 ) 。</p>
</blockquote>
<p>ByteBufHolder 只有几种用于访问底层数据和引用计数的方法：</p>
<p><img src="/" alt="ByteBufHoler 操作" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ByteBufHoler%20%E6%93%8D%E4%BD%9C.png"></p>
<h3 id="4、ByteBuf-分配"><a href="#4、ByteBuf-分配" class="headerlink" title="4、ByteBuf 分配"></a>4、ByteBuf 分配</h3><h4 id="a、按需分配：ByteBufAllocator-接口"><a href="#a、按需分配：ByteBufAllocator-接口" class="headerlink" title="a、按需分配：ByteBufAllocator 接口"></a>a、按需分配：<code>ByteBufAllocator</code> 接口</h4><blockquote>
<p>为了降低分配和释放内存的开销，Netty 通过 <code>interface ByteBufAllocator</code> 实现了（ ByteBuf 的 ） 池化，它可以用来分配我们所描述过的任意类型的ByteBuf实例 。</p>
<p>使用池化是特定于应用程序的决定，其并不会以任何方式改变 ByteBuf API（的语义）。</p>
<p><strong>Netty 提供了两种 ByteBufAllocator 的实现：</strong></p>
<ul>
<li>PooledByteBufAllocator</li>
<li>UnpooledByteBufAllocator</li>
</ul>
<p>前者池化了 ByteBuf 的实例以提高性能并最大限度地减少内存碎片。</p>
<p>后者的实现不池化 ByteBuf 实例，并且在每次它被调用时都会返回一个新的实例。 </p>
</blockquote>
<p><strong>获取 ByteBufAllocator ：</strong></p>
<p>可以通过 Channel（ 每个 Channel 都可以有一个不同的 ByteBufAllocator 实例 ）或者绑定到 ChannelHandler 的 ChannelHandlerContext 获取一个到 ByteBufAllocator 的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...; </span><br><span class="line">ByteBufAllocator allocator = channel.alloc();  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ChannelHandlerContext ctx = ...; </span><br><span class="line">ByteBufAllocator allocator2 = ctx.alloc();</span><br></pre></td></tr></table></figure>

<p><strong>ByteBufAllocator 常用方法：</strong></p>
<p><img src="/" alt="ByteBufAllocator" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ByteBufAllocator.png"></p>
<h4 id="b、Unpooled-缓冲区"><a href="#b、Unpooled-缓冲区" class="headerlink" title="b、Unpooled 缓冲区"></a>b、<code>Unpooled</code> 缓冲区</h4><blockquote>
<p>可能在某些情况下，无法获取一个到 <code>ByteBufAllocator</code> 的引用。对于这种情况，Netty 提供了一个简单的称为 Unpooled 的工具类，它提供了静态的辅助方法来创建<strong>未池化</strong>的 ByteBuf 实例。</p>
</blockquote>
<p><img src="/" alt="Unpooled 常用方法" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/Unpooled%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png"></p>
<h4 id="c、ByteBufUtil-类"><a href="#c、ByteBufUtil-类" class="headerlink" title="c、ByteBufUtil 类"></a>c、<code>ByteBufUtil</code> 类</h4><blockquote>
<p>ByteBufUtil 提供了用于操作 ByteBuf 的静态的辅助方法。且该 API 是通用的，和池化无关。</p>
</blockquote>
<p>这些静态方法中最有价值的可能就是 <code>hexdump()</code> 方法，它以十六进制的表示形式打印 ByteBuf的内容。</p>
<p>另一个有用的方法是 <code>boolean equals(ByteBuf, ByteBuf)</code>，它被用来判断两个 ByteBuf 实例的相等性。</p>
<h3 id="5、引用计数"><a href="#5、引用计数" class="headerlink" title="5、引用计数"></a>5、引用计数</h3><blockquote>
<p>Netty 使用引用计数来处理池化的 ByteBuf。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.refCnt(); <span class="comment">// 获取引用数</span></span><br><span class="line">buffer.release(); <span class="comment">// 释放本引用</span></span><br></pre></td></tr></table></figure>

<h4 id="资源泄露问题："><a href="#资源泄露问题：" class="headerlink" title="资源泄露问题："></a>资源泄露问题：</h4><blockquote>
<p>Netty 使用引用计数来处理池化的 ByteBuf。所以在完全使用完某个 ByteBuf 后，调整其引用计数是很重要的。</p>
<p>为了帮助你诊断潜在的（资源泄漏）问题，Netty 提供了 <code>class ResourceLeakDetector</code> ，它将对你应用程序的缓冲区分配做大约 1% 的采样来检测内存泄露。相关的开销是非常小的。 </p>
</blockquote>
<p>Netty目前定义了 4 种泄漏检测级别：</p>
<p><img src="/" alt="泄漏检测级别" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E7%BA%A7%E5%88%AB.png"></p>
<p>泄露检测级别可以通过将下面的 Java 系统属性设置为表中的一个值来定义： </p>
<p>java -Dio.netty.leakDetectionLevel=ADVANCED </p>
<p>如果带着该 JVM 选项重新启动你的应用程序，你将看到自己的应用程序最近被泄漏的缓冲区被访问的位置。</p>
<p><strong>正确操作：</strong></p>
<p><img src="/" alt="丢弃所有写入数据的实现" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E4%B8%A2%E5%BC%83%E6%89%80%E6%9C%89%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9E%E7%8E%B0.png"></p>
<p>重要的是，不仅要释放资源，还要通知 ChannelPromise。否则可能会出现 ChannelFutureListener 收不到某个消息已经被处理了的通知的情况。</p>
<p>总之，如果一个消息被消费或者丢弃了，并且没有传递给 ChannelPipeline 中的下一个 ChannelOutboundHandler，那么用户就有责任调用 ReferenceCountUtil.release() 。</p>
<p>如果消息到达了实际的传输层，那么当它被写入时或者 Channel 关闭时，都将被自动释放。</p>
<h2 id="六、单元测试"><a href="#六、单元测试" class="headerlink" title="六、单元测试"></a>六、单元测试</h2><h3 id="1、EmbeddedChannel-概述"><a href="#1、EmbeddedChannel-概述" class="headerlink" title="1、EmbeddedChannel 概述"></a>1、EmbeddedChannel 概述</h3><blockquote>
<p>Netty 提供了它所谓的 Embedded 传输，用于测试 ChannelHandler。这个传输是一种特殊的 Channel 实现 ( EmbeddedChannel ) 的功能，这个实现提供了通过 ChannelPipeline 传播事件的简便方法。</p>
<p>这个想法是直截了当的：将入站数据或者出站数据写入到 EmbeddedChannel 中，然后检查是否有任何东西到达了 ChannelPipeline 的尾端。以这种方式，你便可以确定消息是否已经被编码或者被解码过了，以及是否触发了任何的 ChannelHandler 动作。</p>
</blockquote>
<p><img src="/" alt="特殊的 EmbeddedChannel 方法" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E7%89%B9%E6%AE%8A%E7%9A%84%20EmbeddedChannel%20%E6%96%B9%E6%B3%95.png"></p>
<p>如下图所示，可以通过调用 EmbeddedChannel 的 writeOutbound() 方法向 ChannelPipelind 中写入数据，数据会在 ChannelPipelind 中沿着出站方向传递，随后可以通过 readOutbound() 方法读取出站处理器处理后的数据，并测试出站处理器的处理是否符合预期。</p>
<p>同样，也可以通过调用 EmbeddedChannel 的 writeInbound() 方法向 ChannelPipelind 中写入数据，数据会在 ChannelPipelind 中沿着入站方向传递，随后可以通过 readInbound() 方法读取入站处理器处理后的数据，并测试入站处理器的处理是否符合预期。</p>
<p><img src="/" alt="EmbeddedChannel 的数据流" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/EmbeddedChannel%20%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81.png"></p>
<h3 id="2、使用-EmbeddedChannel-测试-ChannelHandler"><a href="#2、使用-EmbeddedChannel-测试-ChannelHandler" class="headerlink" title="2、使用 EmbeddedChannel 测试 ChannelHandler"></a>2、使用 EmbeddedChannel 测试 ChannelHandler</h3><h4 id="a、测试入站消息"><a href="#a、测试入站消息" class="headerlink" title="a、测试入站消息"></a>a、测试入站消息</h4><blockquote>
<p>示例：有一个解码器，它用来将接收到的消息解析为固定长度的帧（该帧大小为 3 字节）</p>
</blockquote>
<p>解码器 ( ChannelHandler ) 代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定帧的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyByteToMessageDecoder</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 当入站数据长度大于规定的帧长度，就将该帧添加到已被解码的消息列表中</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &gt;= length) &#123;</span><br><span class="line">            out.add(in.readBytes(length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuf buffer = Unpooled.buffer(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            buffer.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteBuf copyBuf = buffer.duplicate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 EmbeddedChannel ，并将要测试的 ChannelHandler 作为参数传入</span></span><br><span class="line">        EmbeddedChannel embeddedChannel = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> MyByteToMessageDecoder(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// retain : 将引用计数加1</span></span><br><span class="line">        <span class="comment">// 将数据写入 EmbeddedChannel</span></span><br><span class="line">        Assert.assertTrue(embeddedChannel.writeInbound(copyBuf.retain()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记 EmbeddedChannel 为已完成状态</span></span><br><span class="line">        Assert.assertTrue(embeddedChannel.finish());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取所生成的消息，并验证是否有3帧</span></span><br><span class="line">        ByteBuf read = embeddedChannel.readInbound();</span><br><span class="line">        Assert.assertEquals(buffer.readSlice(<span class="number">3</span>), read);</span><br><span class="line">        read.release();</span><br><span class="line"></span><br><span class="line">        ByteBuf read2 = embeddedChannel.readInbound();</span><br><span class="line">        Assert.assertEquals(buffer.readSlice(<span class="number">3</span>), read2);</span><br><span class="line">        read2.release();</span><br><span class="line"></span><br><span class="line">        ByteBuf read3 = embeddedChannel.readInbound();</span><br><span class="line">        Assert.assertEquals(buffer.readSlice(<span class="number">3</span>), read3);</span><br><span class="line">        read3.release();</span><br><span class="line"></span><br><span class="line">        Assert.assertNull(embeddedChannel.readInbound());</span><br><span class="line">        buffer.release();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuf buffer = Unpooled.buffer(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            buffer.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteBuf copyBuf = buffer.duplicate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 EmbeddedChannel ，并将要测试的 ChannelHandler 作为参数传入</span></span><br><span class="line">        EmbeddedChannel embeddedChannel = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> MyByteToMessageDecoder(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// retain : 将引用计数加1</span></span><br><span class="line">        <span class="comment">// 将数据写入 EmbeddedChannel</span></span><br><span class="line">        Assert.assertTrue(embeddedChannel.writeInbound(copyBuf.readBytes(<span class="number">2</span>))); <span class="comment">// 返回false，因为不够组成一个帧，无法读取到数据</span></span><br><span class="line">        Assert.assertTrue(embeddedChannel.writeInbound(copyBuf.readBytes(<span class="number">7</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记 EmbeddedChannel 为已完成状态</span></span><br><span class="line">        Assert.assertTrue(embeddedChannel.finish());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取所生成的消息，并验证是否有3帧</span></span><br><span class="line">        ByteBuf read = embeddedChannel.readInbound();</span><br><span class="line">        Assert.assertEquals(buffer.readSlice(<span class="number">3</span>), read);</span><br><span class="line">        read.release();</span><br><span class="line"></span><br><span class="line">        ByteBuf read2 = embeddedChannel.readInbound();</span><br><span class="line">        Assert.assertEquals(buffer.readSlice(<span class="number">3</span>), read2);</span><br><span class="line">        read2.release();</span><br><span class="line"></span><br><span class="line">        ByteBuf read3 = embeddedChannel.readInbound();</span><br><span class="line">        Assert.assertEquals(buffer.readSlice(<span class="number">3</span>), read3);</span><br><span class="line">        read3.release();</span><br><span class="line"></span><br><span class="line">        Assert.assertNull(embeddedChannel.readInbound());</span><br><span class="line">        buffer.release();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="b、测试出站消息"><a href="#b、测试出站消息" class="headerlink" title="b、测试出站消息"></a>b、测试出站消息</h4><blockquote>
<p>示例：有一个编码器，它用来将接收到的 int 整数，转换为其绝对值</p>
</blockquote>
<p>编码器 ( ChannelHandler ) 代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageToMessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (msg.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            out.add(Math.abs(msg.readInt()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuf buffer = Unpooled.buffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            buffer.writeInt(i * (-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EmbeddedChannel embeddedChannel = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> MyMessageToMessageEncoder());</span><br><span class="line"></span><br><span class="line">        Assert.assertTrue(embeddedChannel.writeOutbound(buffer));</span><br><span class="line"></span><br><span class="line">        Assert.assertTrue(embeddedChannel.finish());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            Assert.assertEquals(Integer.valueOf(i), embeddedChannel.readOutbound());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Assert.assertNull(embeddedChannel.readOutbound());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="c、测试异常处理"><a href="#c、测试异常处理" class="headerlink" title="c、测试异常处理"></a>c、测试异常处理</h4><blockquote>
<p>示例：有一个 ChannelHandler ，当其读取的字节数超出某个特定的限制，就会抛出一个 TooLongFrameException</p>
</blockquote>
<p>解码器 ( ChannelHandler ) 代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置要产生帧最大允许的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyByteToMessageDecoder</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> canRead = in.readableBytes();</span><br><span class="line">        <span class="comment">// 如果消息过长，则丢弃并抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (canRead &gt; maxSize) &#123;</span><br><span class="line">            in.clear();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TooLongFrameException();</span><br><span class="line">        &#125;</span><br><span class="line">        out.add(in.readBytes(canRead));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuf buffer = Unpooled.buffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            buffer.writeByte(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteBuf duplicate = buffer.duplicate();</span><br><span class="line"></span><br><span class="line">        EmbeddedChannel embeddedChannel = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> MyByteToMessageDecoder(<span class="number">3</span>));</span><br><span class="line">        Assert.assertTrue(embeddedChannel.writeInbound(duplicate.readBytes(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            embeddedChannel.writeInbound(duplicate.readBytes(<span class="number">4</span>));</span><br><span class="line">            Assert.fail();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TooLongFrameException e) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Assert.assertTrue(embeddedChannel.writeInbound(duplicate.readBytes(<span class="number">3</span>)));</span><br><span class="line">        Assert.assertTrue(embeddedChannel.finish());</span><br><span class="line"></span><br><span class="line">        ByteBuf read = (ByteBuf) embeddedChannel.readInbound();</span><br><span class="line">        Assert.assertEquals(buffer.readSlice(<span class="number">2</span>), read);</span><br><span class="line">        read.release();</span><br><span class="line"></span><br><span class="line">        ByteBuf read2 = embeddedChannel.readInbound();</span><br><span class="line">        Assert.assertEquals(buffer.skipBytes(<span class="number">4</span>).readSlice(<span class="number">3</span>), read2);</span><br><span class="line">        read2.release();</span><br><span class="line"></span><br><span class="line">        buffer.release();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、编解码器"><a href="#七、编解码器" class="headerlink" title="七、编解码器"></a>七、编解码器</h2><blockquote>
<p>编解码器：即，编码器、解码器。</p>
<ul>
<li><p>编码器：</p>
<p>用于处理出站数据，将出站数据转换为适合传输的格式（最有可能是字节流）。</p>
</li>
<li><p>解码器：</p>
<p>用于处理入站数据，将入站网络字节流转换为应用程序能处理的数据格式。</p>
</li>
</ul>
</blockquote>
<h3 id="1、解码器"><a href="#1、解码器" class="headerlink" title="1、解码器"></a>1、解码器</h3><blockquote>
<p>常用实现类：</p>
<ul>
<li><p>将字节解码为消息：</p>
<p>ByteToMessageDecoder</p>
<p>ReplayingDecoder</p>
</li>
<li><p>将一种消息类型解码为另一种：</p>
<p>MessageToMessageDecoder</p>
</li>
</ul>
</blockquote>
<h4 id="a、ByteToMessageDecoder"><a href="#a、ByteToMessageDecoder" class="headerlink" title="a、ByteToMessageDecoder"></a>a、ByteToMessageDecoder</h4><blockquote>
<p>该类会对入站数据进行缓冲，直到入站的数据可以被处理，因为，Netty 并不知道远程节点是否会一次性地发送一个完整的消息。</p>
</blockquote>
<p><img src="/" alt="ByteToMessageDecoder API" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ByteToMessageDecoder%20API.png"></p>
<p>示例：</p>
<p>远端发送了一串数字过来，现需要一个解码器将字节流解码为原始的数字，并传递给后续的 ChannelHandler 。</p>
<p><img src="/" alt="示例流程" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E7%A4%BA%E4%BE%8B%E6%B5%81%E7%A8%8B.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            list.add(byteBuf.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="b、ReplayingDecoder"><a href="#b、ReplayingDecoder" class="headerlink" title="b、ReplayingDecoder"></a>b、ReplayingDecoder</h4><blockquote>
<p>在使用 ByteToMessageDecoder 的例子中，代码在调用 <code>readInt()</code> 方法前不得不验证所输入的 ByteBuf 是否具有足够的数据，这个操作是有点繁琐的。</p>
<p>这时，可以使用 ReplayingDecoder，它扩展了 ByteToMessageDecoder 类，使得我们不必调用 <code>readableBytes()</code> 方法。它是通过使用一个自定义的 ByteBuf 实现 ( ReplayingDecoderByteBuf ) 包装传入的 ByteBuf 从而实现了这一点，其将在内部执行 <code>readInt()</code> 方法。</p>
<p>该类的完整声明是：</p>
<ul>
<li><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</code></li>
<li>类型参数 S 指定了用于状态管理的类型，当取值为 Void 代表不需要状态管理。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>ReplayingDecoderByteBuf 并不支持所有的 ByteBuf 操作，如果调用了一个不被支持的方法，将会抛出一个 UnsupportedOperationException ；</li>
<li>ReplayingDecoder 稍慢于 ByteToMessageDecoder 。</li>
</ul>
</blockquote>
<p>重写 ByteToMessageDecoder 中的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        list.add(byteBuf.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="c、MessageToMessageDecoder"><a href="#c、MessageToMessageDecoder" class="headerlink" title="c、MessageToMessageDecoder"></a>c、MessageToMessageDecoder</h4><blockquote>
<p><code>public abstract class MessageToMessageDecoder&lt;I&gt; extends ChannelInboundHandlerAdapter</code></p>
<p>类型参数 I 指定了 <code>decode()</code> 方法的输入参数 msg 的类型。</p>
</blockquote>
<p><img src="/" alt="MessageToMessageDecoder API" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/MessageToMessageDecoder%20API.png"></p>
<p>示例：</p>
<p>将 Integer 解码为 String 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Integer integer, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        list.add(String.valueOf(integer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="d、更多的解码器"><a href="#d、更多的解码器" class="headerlink" title="d、更多的解码器"></a>d、更多的解码器</h4><ul>
<li><p><code>io.netty.handler.codec.LineBasedFrameDecoder</code></p>
<p>这个类在 Netty 内部也有使用，它使用了行尾控制字符（ \n 或者 \r\n ）来解析消息数据；</p>
</li>
<li><p><code>io.netty.handler.codec.http.HttpObjectDecoder</code></p>
<p>一个 HTTP 数据的解码器。</p>
</li>
<li><p><code>io.netty.handler.codec.http.HttpObjectAggregator</code></p>
<p>它拓展了 MessageToMessageDecoder</p>
</li>
<li><p>在 <code>io.netty.handler.codec</code> 子包下面，有更多用于特定用例的编码器和解码器实现。</p>
</li>
</ul>
<h3 id="2、编码器"><a href="#2、编码器" class="headerlink" title="2、编码器"></a>2、编码器</h3><h4 id="a、MessageToByteEncoder"><a href="#a、MessageToByteEncoder" class="headerlink" title="a、MessageToByteEncoder"></a>a、MessageToByteEncoder</h4><p><img src="/" alt="MessageToByteEncoder API" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/MessageToByteEncoder%20API.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Short</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Short msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeShort(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="b、MessageToMessageEncoder"><a href="#b、MessageToMessageEncoder" class="headerlink" title="b、MessageToMessageEncoder"></a>b、MessageToMessageEncoder</h4><p><img src="/" alt="MessageToMessageEncoder API" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/MessageToMessageEncoder%20API.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.add(String.valueOf(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、抽象的编解码器类"><a href="#3、抽象的编解码器类" class="headerlink" title="3、抽象的编解码器类"></a>3、抽象的编解码器类</h3><blockquote>
<p>抽象编解码器类将捆绑一个解码器/编码器对，以处理编码/解码两种类型的操作。这些类同时实现了 <code>ChannelInboundHandler</code> 和 <code>ChannelOutboundHandler</code> 接口。</p>
</blockquote>
<h4 id="抽象类-ByteToMessageCodec"><a href="#抽象类-ByteToMessageCodec" class="headerlink" title="抽象类 ByteToMessageCodec"></a>抽象类 ByteToMessageCodec</h4><p><img src="/" alt="ByteToMessageCodec API" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/ByteToMessageCodec%20API.png"></p>
<h4 id="抽象类-MessageToMessageCodec"><a href="#抽象类-MessageToMessageCodec" class="headerlink" title="抽象类 MessageToMessageCodec"></a>抽象类 MessageToMessageCodec</h4><p><img src="/" alt="MessageToMessageCodec 的方法" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/MessageToMessageCodec%20%E7%9A%84%E6%96%B9%E6%B3%95.png"></p>
<p><code>decode()</code> 方法是将 INBOUND_IN 类型的消息转换为 OUTBOUND_IN 类型的消息，而 <code>encode()</code> 方法则进行它的逆向操作。</p>
<p>可以将 INBOUND_IN 类型的消息看作是通过网络发送的类型， 而将 OUTBOUND_IN 类型的消息看作是应用程序所处理的类型。</p>
<h4 id="CombinedChannelDuplexHandler-类"><a href="#CombinedChannelDuplexHandler-类" class="headerlink" title="CombinedChannelDuplexHandler 类"></a>CombinedChannelDuplexHandler 类</h4><blockquote>
<p>结合一个解码器和编码器可能会对可重用性造成影响。但是，有一种方法既能够避免这种惩罚，又不会牺牲将一个解码器和一个编码器作为一个单独的单元部署所带来的便利性。</p>
<p>CombinedChannelDuplexHandler 提供了这个解决方案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedChannelDuplexHandler</span> &lt;<span class="title">I</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandler</span>, <span class="title">O</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandler</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个类充当了 ChannelInboundHandler 和 ChannelOutboundHandler（ 该类的类型参数 I 和 O ）的容器。通过提供分别继承了解码器类和编码器类的类型，我们可以实现一个编解码器，而又不必直接扩展抽象的编解码器类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToCharDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (in.readableBytes() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            out.add(in.readChar());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Character</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Character msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeChar(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedByteCharCodec</span> <span class="keyword">extends</span> <span class="title">CombinedChannelDuplexHandler</span>&lt;<span class="title">ByteToCharDecoder</span>, <span class="title">CharToByteEncoder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CombinedByteCharCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> ByteToCharDecoder(), <span class="keyword">new</span> CharToByteEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、注意"><a href="#4、注意" class="headerlink" title="4、注意"></a>4、注意</h3><h4 id="a、关于编解码器中的引用计数"><a href="#a、关于编解码器中的引用计数" class="headerlink" title="a、关于编解码器中的引用计数"></a>a、关于编解码器中的引用计数</h4><blockquote>
<p>对于编解码器来说，一旦消息被编码或者解码，ByteBuf 的引用就会被 ReferenceCountUtil.release(message) 调用而自动释放。</p>
<p>若需要保留引用计数以便稍后使用，可以调用 ReferenceCountUtil.release(message) 方法，来增加该引用计数，从而防止该消息被释放。</p>
</blockquote>
<h4 id="b、TooLongFrameException"><a href="#b、TooLongFrameException" class="headerlink" title="b、TooLongFrameException"></a>b、TooLongFrameException</h4><blockquote>
<p>由于 Netty 是一个异步框架，所以需要在字节可以解码之前在内存中缓冲它们。因此，不能让解码器缓冲大量的数据以至于耗尽可用的内存。为了解除这个常见的顾虑，Netty 提供了 TooLongFrameException 类，其将由解码器在帧超出指定的大小限制时抛出。</p>
<p>为了避免这种情况，你可以设置一个最大字节数的阈值，如果超出该阈值，则会导致抛出一 个 TooLongFrameException（随后会被 <code>ChannelHandler.exceptionCaught()</code> 方法捕获）。然后，如何处理该异常则完全取决于该解码器的用户。</p>
<p>某些协议（如 HTTP）可能允许你返回一个特殊的响应。而在其他的情况下，唯一的选择可能就是关闭对应的连接。</p>
<p>如果你正在使用一个可变帧大小的协议，那么这种保护措施将是尤为重要的。</p>
</blockquote>
<p>示例：</p>
<p>展示 ByteToMessageDecoder 是如何使用 TooLongFrameException 来通知 ChannelPipeline 中的其他 ChannelHandler 发生了帧大小溢出的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeByteToMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FRAME_SIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> readable = in.readableBytes();</span><br><span class="line">        <span class="keyword">if</span> (readable &gt; MAX_FRAME_SIZE) &#123;</span><br><span class="line">            <span class="comment">// 跳过所有的可读字节， 抛出 TooLongFrameException 并通知 ChannelHandler</span></span><br><span class="line">            in.skipBytes(readable);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TooLongFrameException(<span class="string">"Frame too big!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、Netty-预置的-ChannelHandler-和-编解码器"><a href="#八、Netty-预置的-ChannelHandler-和-编解码器" class="headerlink" title="八、Netty 预置的 ChannelHandler 和 编解码器"></a>八、Netty 预置的 ChannelHandler 和 编解码器</h2><h3 id="1、通过-SSL-TLS-保护-Netty-应用程序"><a href="#1、通过-SSL-TLS-保护-Netty-应用程序" class="headerlink" title="1、通过 SSL/TLS 保护 Netty 应用程序"></a>1、通过 SSL/TLS 保护 Netty 应用程序</h3><blockquote>
<p>为了支持 SSL/TLS，Java 提供了 <code>javax.net.ssl</code> 包，它的 <code>SSLContext</code> 和 <code>SSLEngine</code> 类使得实现解密和加密相当简单直接。Netty 通过一个名为 <code>SslHandler</code> 的 <code>ChannelHandler</code> 利用了这个 API，其中 <code>SslHandler</code> 在内部使用 <code>SSLEngine</code> 来完成实际的工作。</p>
</blockquote>
<h4 id="a、Netty-的-OpenSSL-SSLEngine-实现"><a href="#a、Netty-的-OpenSSL-SSLEngine-实现" class="headerlink" title="a、Netty 的 OpenSSL/SSLEngine 实现"></a>a、Netty 的 OpenSSL/SSLEngine 实现</h4><p>Netty 还提供了使用 OpenSSL 工具包实现的 SSLEngine 。使用 OpenSSL 工具包实现的 OpenSslEngine 类比 JDK 提供的 SSLEngine 有更好的性能。</p>
<p>如果 OpenSSL 库可用，可以将 Netty 应用程序（客户端和服务器）配置为：默认使用 OpenSSL 实现的 SSLEngine；如果不可用，Netty 会回退到 JDK 实现。</p>
<p>无论使用 JDK 的 SSLEngine 还是使用 Netty 的 OpenSslEngine，SSL 的 API 和数据流都是一致的。</p>
<p><img src="/" alt="通过 SslHandler 进行解密和加密的数据流" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E9%80%9A%E8%BF%87%20SslHandler%20%E8%BF%9B%E8%A1%8C%E8%A7%A3%E5%AF%86%E5%92%8C%E5%8A%A0%E5%AF%86%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81.png"></p>
<h4 id="b、示例"><a href="#b、示例" class="headerlink" title="b、示例"></a>b、示例</h4><blockquote>
<p>在大多数情况下，SslHandler 将是 ChannelPipeline 中的第一个 ChannelHandler。这确保了只有在所有其他的 ChannelHandler 将它们的逻辑应用到数据之后，才会进行加密。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SslChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SslContext context;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> startTls;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果设置为 true，第一个写入的消息将不会被加密（客户端应该设置为 true）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SslChannelInitializer</span><span class="params">(SslContext context, <span class="keyword">boolean</span> startTls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.startTls = startTls;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 对于每个 SslHandler 实例，</span></span><br><span class="line">        <span class="comment">// 都使用 Channel 的 ByteBufAllocator 从 SslContext 获取一个新的 SSLEngine </span></span><br><span class="line">        SSLEngine engine = context.newEngine(ch.alloc());</span><br><span class="line">        <span class="comment">// 将 SslHandler 作为第一个 ChannelHandler 添加到 ChannelPipeline 中</span></span><br><span class="line">        ch.pipeline().addFirst(<span class="string">"ssl"</span>, <span class="keyword">new</span> SslHandler(engine, startTls));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="c、SslHandler-API"><a href="#c、SslHandler-API" class="headerlink" title="c、SslHandler API"></a>c、SslHandler API</h4><p><img src="/" alt="SslHandler API" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/SslHandler%20API.png"></p>
<h3 id="2、构建基于-Netty-的-HTTP-HTTPS-应用程序"><a href="#2、构建基于-Netty-的-HTTP-HTTPS-应用程序" class="headerlink" title="2、构建基于 Netty 的 HTTP/HTTPS 应用程序"></a>2、构建基于 Netty 的 HTTP/HTTPS 应用程序</h3><h4 id="a、HTTP-解码器、编码器、编解码器"><a href="#a、HTTP-解码器、编码器、编解码器" class="headerlink" title="a、HTTP 解码器、编码器、编解码器"></a>a、HTTP 解码器、编码器、编解码器</h4><blockquote>
<p>HTTP 是基于请求/响应模式的：客户端向服务器发送一个 HTTP 请求，然后服务器将会返回一个 HTTP 响应。</p>
<p>Netty 提供了多种编码器和解码器以简化对这个协议的使用。</p>
<p>下图分别展示了生产和消费 HTTP 请求和 HTTP 响应的方法。</p>
</blockquote>
<p><img src="/" alt="HTTP 请求的组成部分" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/HTTP%20%E8%AF%B7%E6%B1%82%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png"></p>
<p><img src="/" alt="HTTP 响应的组成部分" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/HTTP%20%E5%93%8D%E5%BA%94%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png"></p>
<p>如上图所示，一个 HTTP 请求/响应可能由多个数据部分组成，并且它总是以一 个 LastHttpContent 部分作为结束。</p>
<h5 id="①、表示-HTTP-消息的类"><a href="#①、表示-HTTP-消息的类" class="headerlink" title="①、表示 HTTP 消息的类"></a>①、表示 HTTP 消息的类</h5><p>FullHttpRequest 和 FullHttpResponse 消息是特殊的子类型，分别代表了完整的请求和响应。</p>
<p>所有类型的 HTTP 消息（FullHttpRequest、 LastHttpContent 以及下面示例代码中的）都实现了 HttpObject 接口。</p>
<h5 id="②、HTTP-解码器、编码器"><a href="#②、HTTP-解码器、编码器" class="headerlink" title="②、HTTP 解码器、编码器"></a>②、HTTP 解码器、编码器</h5><p><img src="/" alt="HTTP 解码器和编码器" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/HTTP%20%E8%A7%A3%E7%A0%81%E5%99%A8%E5%92%8C%E7%BC%96%E7%A0%81%E5%99%A8.png"></p>
<h5 id="③、示例"><a href="#③、示例" class="headerlink" title="③、示例"></a>③、示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpPipelineInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> client; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpPipelineInitializer</span><span class="params">(<span class="keyword">boolean</span> client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="keyword">if</span> (client) &#123;</span><br><span class="line">            <span class="comment">// 如果是客户端，则添加 HttpResponseDecoder 以处理来自服务器的响应（Response解码）</span></span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> HttpResponseDecoder());</span><br><span class="line">            <span class="comment">// 如果是客户端，则添加 HttpRequestEncoder 以向服务器发送请求（Request编码）</span></span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> HttpRequestEncoder());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是服务器，则添加 HttpRequestDecoder 以接收来自客户端的请求（Request解码）</span></span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> HttpRequestDecoder());</span><br><span class="line">            <span class="comment">// 如果是服务端，则添加 HttpResponseEncoder 以向客户端发送响应（Response编码）</span></span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> HttpResponseEncoder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="b、聚合-HTTP-消息"><a href="#b、聚合-HTTP-消息" class="headerlink" title="b、聚合 HTTP 消息"></a>b、聚合 HTTP 消息</h4><blockquote>
<p>在 ChannelInitializer 将 ChannelHandler 安装到 ChannelPipeline 中之后，便可以处理不同类型的 HttpObject 消息了。但是由于 HTTP 的请求和响应可能由许多部分组成，因此需要聚合它们以形成完整的消息。为了消除这项繁琐的任务，Netty 提供了一个聚合器，它可以将多个消息部分合并为 FullHttpRequest 或者 FullHttpResponse 消息。通过这样的方式，将总是看到完整的消息内容。</p>
<p>由于消息分段需要被缓冲，直到可以转发一个完整的消息给下一个 ChannelInboundHandler，所以这个操作有轻微的开销。其所带来的好处便是不必关心消息碎片了。</p>
<p>引入这种自动聚合机制只不过是向 ChannelPipeline 中添加另外一个 ChannelHandler 罢了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpAggregatorInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isClient;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpAggregatorInitializer</span><span class="params">(<span class="keyword">boolean</span> isClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isClient = isClient;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="keyword">if</span> (isClient) &#123;</span><br><span class="line">            <span class="comment">// 如果是客户端，则添加 HttpClientCodec</span></span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpClientCodec());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是服务器，则添加 HttpServerCodec </span></span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将最大的消息大小为 512KB 的 HttpObjectAggregator（http聚合器）添加到 ChannelPipeline</span></span><br><span class="line">        pipeline.addLast(<span class="string">"aggregator"</span>, <span class="keyword">new</span> HttpObjectAggregator(<span class="number">512</span> * <span class="number">1024</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="c、HTTP-压缩"><a href="#c、HTTP-压缩" class="headerlink" title="c、HTTP 压缩"></a>c、HTTP 压缩</h4><blockquote>
<p>当使用 HTTP 时，建议开启压缩功能以尽可能多地减小传输数据的大小。虽然压缩会带来一些 CPU 时钟周期上的开销，但是通常来说它都是一个好主意，特别是对于文本数据来说。</p>
<p>Netty 为压缩和解压缩提供了 ChannelHandler 实现，它们同时支持 gzip 和 deflate 编码。</p>
<blockquote>
<p>HTTP 请求的头部信息</p>
<p>客户端可以通过提供以下头部信息来告知服务器它所支持的压缩格式：</p>
<p><code>GET /encrypted-area HTTP/1.1</code></p>
<p><code>Host: www.example.com</code></p>
<p><code>Accept-Encoding: gzip, deflate</code></p>
<p>然而，需要注意的是，服务器没有义务压缩它所发送的数据。</p>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpCompressionInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isClient; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpCompressionInitializer</span><span class="params">(<span class="keyword">boolean</span> isClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isClient = isClient;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="keyword">if</span> (isClient) &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpClientCodec());</span><br><span class="line">            <span class="comment">// 如果是客户端，则添加 HttpContentDecompressor（Http内容解压器）以处理来自服务器的压缩内容</span></span><br><span class="line">            pipeline.addLast(<span class="string">"decompressor"</span>, <span class="keyword">new</span> HttpContentDecompressor());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pipeline.addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">            <span class="comment">// 如果是服务器，则添加 HttpContentCompressor（Http内容压缩机）来压缩数据（如果客户端支持它） </span></span><br><span class="line">            pipeline.addLast(<span class="string">"compressor"</span>, <span class="keyword">new</span> HttpContentCompressor());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>压缩的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果你正在使用的是 JDK 6 或者更早的版本：</span><br><span class="line">需要将 JZlib（www.jcraft.com/jzlib/）添加到 CLASSPATH 中以支持压缩功能；</span><br><span class="line">对于 Maven，请添加以下依赖项：  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jcraft<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jzlib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="d、使用-HTTPS"><a href="#d、使用-HTTPS" class="headerlink" title="d、使用 HTTPS"></a>d、使用 HTTPS</h4><blockquote>
<p>启用 HTTPS 只需要将 SslHandler 添加到 ChannelPipeline 的 ChannelHandler 组合中。</p>
<p>代码参考：<code>a、Netty 的 OpenSSL/SSLEngine 实现</code> 中的示例。</p>
</blockquote>
<h4 id="d、WebSocket"><a href="#d、WebSocket" class="headerlink" title="d、WebSocket"></a>d、WebSocket</h4><blockquote>
<p>WebSocket 提供了 “ 在一个单个的 TCP 连接上提供双向的通信 · · · · · · 结合 WebSocket API · · · · · · 它为网页和远程服务器之间的双向通信提供了一种替代 HTTP 轮询的方案。</p>
<p>也就是说，WebSocket 在客户端和服务器之间提供了真正的双向数据交换。</p>
<p>尽管最早的 WebSocket 实现仅限于文本数据，但是现在已经不是问题了；WebSocket 现在可以用于传输任意类型的数据，很像普通的套接字。</p>
</blockquote>
<p>WebSocket 协议的一般概念。在这个场景下，通信将作为普通的 HTTP 协议开始，随后升级到双向的 WebSocket 协议。</p>
<p><img src="/" alt="WebSocket 协议" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/WebSocket%20%E5%8D%8F%E8%AE%AE.png"></p>
<p>可以通过将客户端或服务器 WebSocket ChannelHandler 添加到 ChannelPipeline 中，来为程序添加对于 WebSocket 的支持。</p>
<p>这个 ChannelHandler 将处理由 WebSocket 定义的称为帧的特殊消息类型。如下图所示：</p>
<p>WebSocketFrame 可以被归类为<strong>数据帧</strong>或者<strong>控制帧</strong>。</p>
<p><img src="/" alt="WebSocketFrame 类型" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/WebSocketFrame%20%E7%B1%BB%E5%9E%8B.png"></p>
<p><strong>示例：</strong></p>
<p>下列代码展示了一个使用 WebSocketServerProtocolHandler 的服务端简单示例，这个类处理协议升级握手，以及 3 种控制帧 —— Close、Ping 和 Pong。Text 和 Binary 数据帧将会被传递给下一个（由你实现的）ChannelHandler 进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(</span><br><span class="line">            <span class="keyword">new</span> HttpServerCodec(),</span><br><span class="line">            <span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>),</span><br><span class="line">            <span class="comment">// 如果被请求的端点是 "/websocket"， 则处理该升级</span></span><br><span class="line">            <span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">"/websocket"</span>),</span><br><span class="line">            <span class="comment">// TextFrameHandler 处理 TextWebSocketFrame</span></span><br><span class="line">            <span class="keyword">new</span> TextFrameHandler(),</span><br><span class="line">            <span class="comment">// BinaryFrameHandler 处理 BinaryWebSocketFrame</span></span><br><span class="line">            <span class="keyword">new</span> BinaryFrameHandler(),</span><br><span class="line">            <span class="comment">// ContinuationFrameHandler 处理 ContinuationWebSocketFrame</span></span><br><span class="line">            <span class="keyword">new</span> ContinuationFrameHandler());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        	<span class="comment">// Handle text frame</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">BinaryWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, BinaryWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// Handle binary frame</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ContinuationFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ContinuationWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ContinuationWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// Handle continuation frame</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>保护 WebSocket ：</strong></p>
<p>要想为 WebSocket 添加安全性，只需要将 SslHandler 作为第一个 ChannelHandler 添加到 ChannelPipeline 中。</p>
<h3 id="3、空闲的连接和超时"><a href="#3、空闲的连接和超时" class="headerlink" title="3、空闲的连接和超时"></a>3、空闲的连接和超时</h3><p><img src="/" alt="用于空闲连接以及超时的 ChannelHandler" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E7%94%A8%E4%BA%8E%E7%A9%BA%E9%97%B2%E8%BF%9E%E6%8E%A5%E4%BB%A5%E5%8F%8A%E8%B6%85%E6%97%B6%E7%9A%84%20ChannelHandler.png"></p>
<p>实践中使用得最多的是：IdleStateHandler 。</p>
<p><strong>示例：</strong></p>
<p>下列代码展示了当使用通常的发送心跳消息到远程节点的方法时，如果在 60 秒之内没有接收或者发送任何的数据，我们将如何得到通知；如果没有响应，则连接会被关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送心跳</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdleStateHandlerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="comment">// IdleStateHandler 将在被触发时发送一个 IdleStateEvent 事件</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line">        <span class="comment">// 将一个 HeartbeatHandler（心跳Handler）添加到 ChannelPipeline 中</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HeartbeatHandler());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ByteBuf HEARTBEAT_SEQUENCE = Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(<span class="string">"HEARTBEAT"</span>, CharsetUtil.ISO_8859_1));</span><br><span class="line">        <span class="comment">// 实现 userEventTriggered() 方法以发送心跳消息</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 发送心跳消息，并在发送失败时关闭该连接</span></span><br><span class="line">            <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">                ctx.writeAndFlush(HEARTBEAT_SEQUENCE.duplicate()).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不是 IdleStateEvent 事件，所以将它传递给下一个 ChannelInboundHandler</span></span><br><span class="line">                <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 IdleStateHandler 来测试远程节点是否仍然还活着，并且在它失活时通过关闭连接来释放资源。 如果连接超过 60 秒没有接收或者发送任何的数据，那么 IdleStateHandler 将会使用一个 IdleStateEvent 事件来调用 fireUserEventTriggered() 方法。HeartbeatHandler 实现了 userEventTriggered() 方法，如果这个方法检测到 IdleStateEvent 事件，它将会发送心跳消息，并且添加一个将在发送操作失败时关闭该连接的 ChannelFutureListener 。</p>
<h3 id="4、解码基于分隔符的协议"><a href="#4、解码基于分隔符的协议" class="headerlink" title="4、解码基于分隔符的协议"></a>4、解码基于分隔符的协议</h3><blockquote>
<p>如：SMTP、POP3、IMAP 以及 Telnet</p>
</blockquote>
<p><img src="/" alt="用于处理基于分隔符的协议和基于长度的协议的解码器" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E7%94%A8%E4%BA%8E%E5%A4%84%E7%90%86%E5%9F%BA%E4%BA%8E%E5%88%86%E9%9A%94%E7%AC%A6%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%9F%BA%E4%BA%8E%E9%95%BF%E5%BA%A6%E7%9A%84%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%A7%A3%E7%A0%81%E5%99%A8.png"></p>
<p>下图展示了当帧由行尾序列 <code>\r\n</code>（回车符+换行符）分隔时是如何被处理的：</p>
<p><img src="/" alt="解码基于分隔符的协议和基于长度的协议" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E8%A7%A3%E7%A0%81%E5%9F%BA%E4%BA%8E%E5%88%86%E9%9A%94%E7%AC%A6%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%9F%BA%E4%BA%8E%E9%95%BF%E5%BA%A6%E7%9A%84%E5%8D%8F%E8%AE%AE.png"></p>
<p>下列代码展示了如何使用 LineBasedFrameDecoder 来处理上图所示的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理由行尾符分隔的帧</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineBasedHandlerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="comment">// 该 LineBasedFrameDecoder 将提取的帧转发给下一个 ChannelInboundHandler</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LineBasedFrameDecoder(<span class="number">64</span> * <span class="number">1024</span>));</span><br><span class="line">        <span class="comment">// 添加 MyDemoHandler 以接收帧</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyDemoHandler());</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 传入了单个帧的内容</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// Do something with the data extracted from the frame</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例：使用自定义帧结构传输数据"><a href="#示例：使用自定义帧结构传输数据" class="headerlink" title="示例：使用自定义帧结构传输数据"></a>示例：使用自定义帧结构传输数据</h4><blockquote>
<p>实现目标：</p>
<ul>
<li>传入数据流是一系列的帧，每个帧都由换行符（\n）分隔；</li>
<li>每个帧都由一系列的元素组成，每个元素都由单个空格字符分隔；</li>
<li>一个帧的内容代表一个命令，定义为一个命令名称后跟着数目可变的参数。</li>
</ul>
<p>实现步骤：</p>
<ul>
<li>Cmd — 将帧（命令）的内容存储在 ByteBuf 中，一个 ByteBuf 用于名称，另一个用于参数；</li>
<li>CmdDecoder — 从被重写了的 decode() 方法中获取一行字符串，并从它的内容构建一个 Cmd 的实例； </li>
<li>CmdHandler — 从 CmdDecoder 获取解码的 Cmd 对象，并对它进行一些处理；</li>
<li>CmdHandlerInitializer — 为了简便起见，我们将会把前面的这些类定义为专门的 ChannelInitializer 的嵌套类，其将会把这些 ChannelInboundHandler 安装到 ChannelPipeline 中。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CmdHandlerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span> SPACE = (<span class="keyword">byte</span>)<span class="string">' '</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="comment">// 添加 CmdDecoder 以提取 Cmd 对象，并将它转发给下一个 ChannelInboundHandler</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> CmdDecoder(<span class="number">64</span> * <span class="number">1024</span>));</span><br><span class="line">        <span class="comment">// 添加 CmdHandler 以接收和处理 Cmd 对象</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> CmdHandler());</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Cmd POJO</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cmd</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ByteBuf name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ByteBuf args;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Cmd</span><span class="params">(ByteBuf name, ByteBuf args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.args = args;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CmdDecoder</span> <span class="keyword">extends</span> <span class="title">LineBasedFrameDecoder</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CmdDecoder</span><span class="params">(<span class="keyword">int</span> maxLength)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(maxLength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 ByteBuf 中提取由行尾符序列分隔的帧</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf buffer)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ByteBuf frame = (ByteBuf) <span class="keyword">super</span>.decode(ctx, buffer);</span><br><span class="line">            <span class="keyword">if</span> (frame == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果输入中没有帧，则返回 null </span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查找第一个空格字符的索引。前面是命令名称，接着是参数</span></span><br><span class="line">            <span class="keyword">int</span> index = frame.indexOf(frame.readerIndex(), frame.writerIndex(), SPACE);</span><br><span class="line">            <span class="comment">// 使用包含有命令名 称和参数的切片创 建新的Cmd对象 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Cmd(frame.slice(frame.readerIndex(), index), frame.slice(index + <span class="number">1</span>, frame.writerIndex()));</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CmdHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Cmd</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 处理传经 ChannelPipeline 的 Cmd 对象</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Cmd msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// Do something with the command</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、解码基于长度的协议"><a href="#5、解码基于长度的协议" class="headerlink" title="5、解码基于长度的协议"></a>5、解码基于长度的协议</h3><p><img src="/" alt="用于基于长度的协议的解码器" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E7%94%A8%E4%BA%8E%E5%9F%BA%E4%BA%8E%E9%95%BF%E5%BA%A6%E7%9A%84%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%A7%A3%E7%A0%81%E5%99%A8.png"></p>
<p>下图展示了 FixedLengthFrameDecoder 的功能，其在构造时已经指定了帧长度为 8 字节：</p>
<p><img src="/" alt="解码长度为 8 字节的帧" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E8%A7%A3%E7%A0%81%E9%95%BF%E5%BA%A6%E4%B8%BA%208%20%E5%AD%97%E8%8A%82%E7%9A%84%E5%B8%A7.png"></p>
<p>我们经常会遇到被编码到消息头部的帧大小不是固定值的协议。为了处理这种变长帧，你可以使用LengthFieldBasedFrameDecoder，它将从头部字段确定帧长，然后从数据流中提取指定的字节数。</p>
<p>下图展示了一个示例，其中长度字段在帧中的偏移量为 0，并且长度为 2 字节。</p>
<p><img src="/" alt="将变长帧大小编码进头部的消息" class="lazyload" data-src="%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/%E5%B0%86%E5%8F%98%E9%95%BF%E5%B8%A7%E5%A4%A7%E5%B0%8F%E7%BC%96%E7%A0%81%E8%BF%9B%E5%A4%B4%E9%83%A8%E7%9A%84%E6%B6%88%E6%81%AF.png"></p>
<h4 id="LengthFieldBasedFrameDecoder"><a href="#LengthFieldBasedFrameDecoder" class="headerlink" title="LengthFieldBasedFrameDecoder"></a>LengthFieldBasedFrameDecoder</h4><blockquote>
<p>LengthFieldBasedFrameDecoder 提供了几个构造函数来支持各种各样的头部配置情 况。下列代码展示了如何使用其 3 个构造参数分别为 maxFrameLength、lengthFieldOffset 和 lengthFieldLength 的构造函数。在这个场景中，帧的长度被编码到了帧起始的前 8 个字节中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthBasedInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="comment">// 使用 LengthFieldBasedFrameDecoder 解码将帧长度编码到帧起始的前 8 个字节中的消息</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">64</span> * <span class="number">1024</span>, <span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">    	<span class="comment">// 添加 MyDemoHandler 以处理每个帧</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyDemoHandler());</span><br><span class="line">   	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 处理帧的数据</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// Do something with the frame</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、写大型数据"><a href="#6、写大型数据" class="headerlink" title="6、写大型数据"></a>6、写大型数据</h3><h3 id="7、序列化数据"><a href="#7、序列化数据" class="headerlink" title="7、序列化数据"></a>7、序列化数据</h3><h4 id="a、JDK-序列化"><a href="#a、JDK-序列化" class="headerlink" title="a、JDK 序列化"></a>a、JDK 序列化</h4><h4 id="b、使用-JBoss-Marshalling-进行序列化"><a href="#b、使用-JBoss-Marshalling-进行序列化" class="headerlink" title="b、使用 JBoss Marshalling 进行序列化"></a>b、使用 JBoss Marshalling 进行序列化</h4><h4 id="c、通过-Protocol-Buffers-序列化"><a href="#c、通过-Protocol-Buffers-序列化" class="headerlink" title="c、通过 Protocol Buffers 序列化"></a>c、通过 Protocol Buffers 序列化</h4><h2 id="九、部分网络协议"><a href="#九、部分网络协议" class="headerlink" title="九、部分网络协议"></a>九、部分网络协议</h2><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><blockquote>
<p>WebSocket 以帧的方式传输数据，每一帧代表消息的一部分。一个完整的消息可能会包含许多帧。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">帧 类 型</th>
<th align="center">描　述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>BinaryWebSocketFrame</code></td>
<td align="center">包含了二进制数据</td>
</tr>
<tr>
<td align="center"><code>TextWebSocketFrame</code></td>
<td align="center">包含了文本数据</td>
</tr>
<tr>
<td align="center"><code>ContinuationWebSocketFrame</code></td>
<td align="center">包含属于上一个<code>BinaryWebSocketFrame</code>或<code>TextWebSocketFrame</code>的文本数据或者二进制数据</td>
</tr>
<tr>
<td align="center"><code>CloseWebSocketFrame</code></td>
<td align="center">表示一个<code>CLOSE</code>请求，包含一个关闭的状态码和关闭的原因</td>
</tr>
<tr>
<td align="center"><code>PingWebSocketFrame</code></td>
<td align="center">请求传输一个<code>PongWebSocketFrame</code></td>
</tr>
<tr>
<td align="center"><code>PongWebSocketFrame</code></td>
<td align="center">作为一个对于<code>PingWebSocketFrame</code>的响应被发送</td>
</tr>
</tbody></table>
<h3 id="使用-UDP-广播事件"><a href="#使用-UDP-广播事件" class="headerlink" title="使用 UDP 广播事件"></a>使用 UDP 广播事件</h3><h2 id="N、实战"><a href="#N、实战" class="headerlink" title="N、实战"></a>N、实战</h2><ol>
<li><p>阻塞/非阻塞，框架</p>
</li>
<li></li>
<li><p>核心组件：Channel、EventLoop、ChannelHandler、ChannelPipeline</p>
</li>
<li><p>网络传输</p>
</li>
<li><p>ByteBuf</p>
</li>
<li><p>ChannelHandler、ChannelPipeline</p>
<p>负责调度应用程序的处理逻辑，并驱动数据和事件经过网络层</p>
<p>其它：</p>
<ul>
<li><p>ChannelHandlerContext</p>
</li>
<li><p>多个 ChannelPipeline 之间共享 ChannelHandler 的缘由</p>
</li>
<li><p>异常处理</p>
</li>
</ul>
</li>
<li><p>Netty 的线程模型，EventLoop</p>
</li>
<li><p>BootStrap</p>
</li>
<li><p>对 ChannelHandler 进行单元测试（ 使用 EmbeddedChannel ）</p>
</li>
</ol>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://yoursite.com" rel="external nofollow noreferrer">愆凡</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://yoursite.com/2019/11/09/%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/">http://yoursite.com/2019/11/09/%E3%80%90%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2004%20%E3%80%91%EF%BC%9ANetty/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="http://yoursite.com" target="_blank">愆凡</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/11/10/%E3%80%90%20%E5%88%86%E5%B8%83%E5%BC%8F%2002%20-%20MQ%20%E3%80%91%EF%BC%9A%E6%80%BB%E7%BB%93/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.png" class="responsive-img" alt="【 分布式 02 - MQ 】：总结">
                        
                        <span class="card-title">【 分布式 02 - MQ 】：总结</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            一、为什么使用消息中间件？
其实就是问问你消息队列都有哪些使用场景，然后你项目里具体是什么场景，说说你在这个场景里用消息队列是什么？
 面试官问你这个问题，期望的一个回答是说，你们公司有个什么业务场景，这个业务场景有个什么技术挑战，如果不用
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-11-10
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" class="post-category">
                                    分布式
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/MQ/">
                        <span class="chip bg-color">MQ</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/11/08/%E3%80%90%20%E5%88%86%E5%B8%83%E5%BC%8F%2002%20-%20MQ%20%E3%80%91%EF%BC%9ARocketMQ/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/8.png" class="responsive-img" alt="【 分布式 02 - MQ 】：RocketMQ">
                        
                        <span class="card-title">【 分布式 02 - MQ 】：RocketMQ</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            一、概念1、核心概念四个组成部分：

Broker：
暂存与传输消息 。

Broker Master ( 主从复制 )
Broker Slave ( 主从复制 )


NameServer：
协调与管理 Broker 。

生产者：
也称
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-11-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" class="post-category">
                                    分布式
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/MQ/">
                        <span class="chip bg-color">MQ</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4, h5, h6'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5, h6').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="http://yoursite.com" target="_blank">愆凡</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">160.8k</span>&nbsp;字
            


            <br>
            <span id="sitetime"></span>

            <div class="BbeiAn-info">
                <a target="_blank" href="http://www.beian.miit.gov.cn/" style="color:#dbdbdb" rel="nofollow">豫ICP备19032957号</a>
                <!--a标签中增加nofollow属性，避免爬虫出站。-->
                &nbsp;|&nbsp;
                <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41012202000302"
                    style="color:#dbdbdb;text-decoration:none;padding-left:30px;background:url(https://blog.notuptoyou.site/medias/icp.png) no-repeat left center"
                    rel="nofollow">豫公网安备41012202000302号</a>
                <!--这里将图标作为了背景，以使得能和后面的文字在同一行-->
            </div>


            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                &nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <!-- <span id="sitetime">载入运行时间...</span> -->
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "6";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/ZGW-GitHub" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:zgwmail@icloud.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=864127700" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 864127700" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
