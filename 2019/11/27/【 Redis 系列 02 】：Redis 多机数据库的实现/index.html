<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【 Redis 系列 02 】：Redis 多机数据库的实现 | 愆凡の博客</title><meta name="description" content="【 Redis 系列 02 】：Redis 多机数据库的实现"><meta name="keywords" content="Redis"><meta name="author" content="愆凡"><meta name="copyright" content="愆凡"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="【 Redis 系列 02 】：Redis 多机数据库的实现"><meta name="twitter:description" content="【 Redis 系列 02 】：Redis 多机数据库的实现"><meta name="twitter:image" content="http://yoursite.com/img/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="【 Redis 系列 02 】：Redis 多机数据库的实现"><meta property="og:url" content="http://yoursite.com/2019/11/27/%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"><meta property="og:site_name" content="愆凡の博客"><meta property="og:description" content="【 Redis 系列 02 】：Redis 多机数据库的实现"><meta property="og:image" content="http://yoursite.com/img/avatar.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      now = new Date();
      hour = now.getHours();
      isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2019/11/27/%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"><link rel="prev" title="【 分布式 01 】：Zookeeper" href="http://yoursite.com/2019/12/04/%E3%80%90%20%E5%88%86%E5%B8%83%E5%BC%8F%2001%20%E3%80%91%EF%BC%9AZookeeper/"><link rel="next" title="【 MySQL 系列 01 】：SQL" href="http://yoursite.com/2019/11/18/%E3%80%90%20MySQL%20%E7%B3%BB%E5%88%97%2001%20%E3%80%91%EF%BC%9ASQL/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://blog.notuptoyou.site","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: false,
  isFontAwesomeV5: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">50</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、复制"><span class="toc-number">1.</span> <span class="toc-text">一、复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、基础"><span class="toc-number">1.1.</span> <span class="toc-text">1、基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a、复制的拓扑"><span class="toc-number">1.1.1.</span> <span class="toc-text">a、复制的拓扑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b、复制的建立"><span class="toc-number">1.1.2.</span> <span class="toc-text">b、复制的建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c、断开复制"><span class="toc-number">1.1.3.</span> <span class="toc-text">c、断开复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d、切换主节点"><span class="toc-number">1.1.4.</span> <span class="toc-text">d、切换主节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e、从节点默认只读"><span class="toc-number">1.1.5.</span> <span class="toc-text">e、从节点默认只读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f、传输延迟"><span class="toc-number">1.1.6.</span> <span class="toc-text">f、传输延迟</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、原理"><span class="toc-number">1.2.</span> <span class="toc-text">2、原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a、复制过程"><span class="toc-number">1.2.1.</span> <span class="toc-text">a、复制过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b、数据同步"><span class="toc-number">1.2.2.</span> <span class="toc-text">b、数据同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#①、psync-命令原理"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">①、psync 命令原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#②、psync-运行流程"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">②、psync 运行流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c、全量复制"><span class="toc-number">1.2.3.</span> <span class="toc-text">c、全量复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d、部分复制"><span class="toc-number">1.2.4.</span> <span class="toc-text">d、部分复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e、心跳"><span class="toc-number">1.2.5.</span> <span class="toc-text">e、心跳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f、异步复制"><span class="toc-number">1.2.6.</span> <span class="toc-text">f、异步复制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、问题"><span class="toc-number">1.3.</span> <span class="toc-text">3、问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a、读写分离"><span class="toc-number">1.3.1.</span> <span class="toc-text">a、读写分离</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#①、数据延迟"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">①、数据延迟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#②、读到过期数据"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">②、读到过期数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#③、从节点故障问题"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">③、从节点故障问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b、主从配置不一致"><span class="toc-number">1.3.2.</span> <span class="toc-text">b、主从配置不一致</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c、规避全量复制"><span class="toc-number">1.3.3.</span> <span class="toc-text">c、规避全量复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d、规避复制风暴"><span class="toc-number">1.3.4.</span> <span class="toc-text">d、规避复制风暴</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Sentinel（-哨兵-）"><span class="toc-number">2.</span> <span class="toc-text">二、Sentinel（ 哨兵 ）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、Redis-Sentinel-的高可用"><span class="toc-number">2.1.</span> <span class="toc-text">1、Redis Sentinel 的高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a、Redis-Sentinel-的架构"><span class="toc-number">2.1.1.</span> <span class="toc-text">a、Redis Sentinel 的架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b、Redis-Sentinel-的功能"><span class="toc-number">2.1.2.</span> <span class="toc-text">b、Redis Sentinel 的功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Cluster（-集群-）"><span class="toc-number">3.</span> <span class="toc-text">三、Cluster（ 集群 ）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、数据分布"><span class="toc-number">3.1.</span> <span class="toc-text">1、数据分布</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a、节点取余分区"><span class="toc-number">3.1.1.</span> <span class="toc-text">a、节点取余分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b、一致性哈希分区"><span class="toc-number">3.1.2.</span> <span class="toc-text">b、一致性哈希分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c、虚拟槽分区"><span class="toc-number">3.1.3.</span> <span class="toc-text">c、虚拟槽分区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、集群功能限制"><span class="toc-number">3.2.</span> <span class="toc-text">2、集群功能限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、搭建集群"><span class="toc-number">3.3.</span> <span class="toc-text">3、搭建集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a、准备节点"><span class="toc-number">3.3.1.</span> <span class="toc-text">a、准备节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b、节点握手"><span class="toc-number">3.3.2.</span> <span class="toc-text">b、节点握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、分配槽"><span class="toc-number">3.3.3.</span> <span class="toc-text">3、分配槽</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、节点通信"><span class="toc-number">3.4.</span> <span class="toc-text">4、节点通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、集群伸缩"><span class="toc-number">3.5.</span> <span class="toc-text">5、集群伸缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、请求路由"><span class="toc-number">3.6.</span> <span class="toc-text">6、请求路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、故障转移"><span class="toc-number">3.7.</span> <span class="toc-text">7、故障转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、集群运维"><span class="toc-number">3.8.</span> <span class="toc-text">8、集群运维</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#"><span class="toc-number">3.9.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">3.10.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-2"><span class="toc-number">3.11.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-3"><span class="toc-number">3.12.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-4"><span class="toc-number">3.13.</span> <span class="toc-text"></span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">愆凡の博客</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div><div id="post-info"><div id="post-title"><div class="posttitle">【 Redis 系列 02 】：Redis 多机数据库的实现</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2019-11-27<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-03-21</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="一、复制"><a href="#一、复制" class="headerlink" title="一、复制"></a>一、复制</h2><h3 id="1、基础"><a href="#1、基础" class="headerlink" title="1、基础"></a>1、基础</h3><h4 id="a、复制的拓扑"><a href="#a、复制的拓扑" class="headerlink" title="a、复制的拓扑"></a>a、复制的拓扑</h4><ul>
<li><p>一主一从</p>
</li>
<li><p>一主多从</p>
</li>
<li><p>树状主从</p>
<p><img src="/" alt="树状主从" class="lazyload" data-src="%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E6%A0%91%E7%8A%B6%E4%B8%BB%E4%BB%8E.png"></p>
</li>
</ul>
<h4 id="b、复制的建立"><a href="#b、复制的建立" class="headerlink" title="b、复制的建立"></a>b、复制的建立</h4><blockquote>
<ol>
<li>在配置文件中加入 <code>slaveof{masterHost}{masterPort}</code> 随 Redis 启动生<br>效。</li>
<li>在 <code>redis-server</code> 启动命令后加入 <code>--slaveof{masterHost}{masterPort}</code> 生<br>效。</li>
<li>直接使用命令：<code>slaveof{masterHost}{masterPort}</code> 生效。</li>
</ol>
<p>可以使用：<code>info replication</code> 命令查看复制状态。</p>
</blockquote>
<p>其中：</p>
<ul>
<li><p>被复制的服务器为主服务器（master）</p>
</li>
<li><p>对主服务器进行复制的服务器称为从服务器（slave） </p>
</li>
</ul>
<p>每个 slave 只能有一个 master ，而 master 可以有多个 slave 。</p>
<p>复制功能于 2.8 版本，进行了改进。 通过部分重同步解决了旧版复制功能的低效问题。 </p>
<h4 id="c、断开复制"><a href="#c、断开复制" class="headerlink" title="c、断开复制"></a>c、断开复制</h4><blockquote>
<p>使用 <code>slaveof no one</code> 来断开复制 。</p>
</blockquote>
<p>从节点断开复制后并不会抛弃原有数据，只是无法再获取主节点上的数据变化。</p>
<h4 id="d、切换主节点"><a href="#d、切换主节点" class="headerlink" title="d、切换主节点"></a>d、切换主节点</h4><blockquote>
<p>执行 <code>slaveof{newMasterIp} {newMasterPort}</code></p>
<p>切换主节点是指把当前从节点对主节点的复制切换到另一个主节点。</p>
</blockquote>
<p>切换主节点操作流程如下：</p>
<ol>
<li>断开与旧主节点复制关系。</li>
<li>与新主节点建立复制关系。</li>
<li><strong>删除从节点当前所有数据。</strong></li>
<li>对新主节点进行复制操作。</li>
</ol>
<h4 id="e、从节点默认只读"><a href="#e、从节点默认只读" class="headerlink" title="e、从节点默认只读"></a>e、从节点默认只读</h4><blockquote>
<p>默认情况下，从节点使用 <code>slave-read-only=yes</code>v配置为只读模式。</p>
</blockquote>
<h4 id="f、传输延迟"><a href="#f、传输延迟" class="headerlink" title="f、传输延迟"></a>f、传输延迟</h4><blockquote>
<p>主从节点一般部署在不同机器上，复制时的网络延迟就成为需要考虑的问题，Redis 为我们提供了 <code>repl-disable-tcp-nodelay</code> 参数用于控制是否关闭 TCP_NODELAY，默认关闭，说明如下：</p>
</blockquote>
<ul>
<li>当关闭时，主节点产生的命令数据无论大小都会及时地发送给从节点，这样主从之间延迟会变小，但增加了网络带宽的消耗。</li>
<li>当开启时，主节点会合并较小的TCP数据包从而节省带宽。默认发送 时间间隔取决于Linux的内核，一般默认为40毫秒。这种配置节省了带宽但增大主从之间的延迟。</li>
</ul>
<h3 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h3><h4 id="a、复制过程"><a href="#a、复制过程" class="headerlink" title="a、复制过程"></a>a、复制过程</h4><p><img src="/" alt="主从节点建立复制流程图" class="lazyload" data-src="%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9%E5%BB%BA%E7%AB%8B%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<h4 id="b、数据同步"><a href="#b、数据同步" class="headerlink" title="b、数据同步"></a>b、数据同步</h4><blockquote>
<p>Redis 在 2.8 及以上版本使用 psync 命令完成主从数据同步，同步过程分为：</p>
<ul>
<li><p><strong>全量复制</strong></p>
<p>一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。</p>
</li>
<li><p><strong>部分复制</strong></p>
<p>用于处理在主从复制中因网络闪断等原因造成的数据丢失场景，当从节点再次连上主节点后，如果条件允许，主节点会补发丢失数据给从节点。因为补发的数据远远小于全量数据，可以有效避免全量复制的过高开销。</p>
</li>
</ul>
<p>从节点使用 psync 命令完成部分复制和全量复制功能，命令格式：<code>psync{runId}{offset}</code> ，参数含义如下：</p>
<ul>
<li>runId：从节点所复制主节点的运行 id</li>
<li>offset：当前从节点已复制的数据偏移量</li>
</ul>
</blockquote>
<h5 id="①、psync-命令原理"><a href="#①、psync-命令原理" class="headerlink" title="①、psync 命令原理"></a>①、psync 命令原理</h5><p>psync 命令运行需要以下组件支持：</p>
<ul>
<li><p>主从节点各自复制偏移量</p>
<p>参与复制的主从节点都会维护自身复制偏移量。主节点（master）在处理完写入命令后，会把命令的字节长度做累加记录，统计信息在 <code>info relication</code> 中的 <code>master_repl_offset</code> 指标中。</p>
<p>从节点（slave）每秒钟上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。</p>
<p>从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量。统计信息在 <code>info relication</code> 中的 <code>slave_repl_offset</code> 指标中。</p>
</li>
<li><p>主节点复制积压缓冲区</p>
<p>复制积压缓冲区是保存在主节点上的一个固定长度的队列，默认大小为 1MB，当主节点有连接的从节点（slave）时被创建，这时主节点（master）响应写命令时，不但会把命令发送给从节点，还会写入复制积压缓冲区。</p>
</li>
<li><p>主节点运行 id</p>
<p>每个 Redis 节点启动后都会动态分配一个 40 位的十六进制字符串作为运行 ID。</p>
<p>当运行ID变化后从节点将 做全量复制。</p>
<p>需要注意的是Redis关闭再启动后，运行ID会随之改变。</p>
<p>当需要调优一些内存相关配置，这些配置需要 Redis 重新加载才能优化已存在的数据，这时可以使用 <code>debug reload</code> 命令重新加载 RDB 并保持运行 ID 不变，从而有效避免不必要的全量复制。（<code>debug reload</code> 命令会阻塞当前 Redis 节点主线程，阻塞期间会生成本地 RDB 快照并清空数据之后再加载 RDB 文件。因此对于大数据量的主节点和无法容忍阻塞的应用场景，谨慎使用。）</p>
</li>
</ul>
<h5 id="②、psync-运行流程"><a href="#②、psync-运行流程" class="headerlink" title="②、psync 运行流程"></a>②、psync 运行流程</h5><p><img src="/" alt="psync 运行流程" class="lazyload" data-src="%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/psync%20%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p>
<p><strong>流程说明：</strong></p>
<p>①、从节点（slave）发送 psync 命令给主节点，若第一次参与复制，则参数 <code>offset</code> 默认值为 -1。</p>
<p>②、主节点（master）根据 psync 参数和自身数据情况决定响应结果：</p>
<ul>
<li>如果回复 <code>+FULLRESYNC{runId}{offset}</code>，那么从节点将触发全量复制流程。</li>
<li>如果回复 <code>+CONTINUE</code>，从节点将触发部分复制流程。</li>
<li>如果回复 <code>+ERR</code>，说明主节点版本低于 Redis2.8，无法识别 psync 命令，从节点将发送旧版的 sync 命令触发全量复制流程。</li>
</ul>
<h4 id="c、全量复制"><a href="#c、全量复制" class="headerlink" title="c、全量复制"></a>c、全量复制</h4><blockquote>
<p>对于线上做读写分离的场景，从节点也负责响应读命令。如果此时从节点正出于全量复制阶段或者复制中断，那么从节点在响应读命令可能拿到过期或错误的数据。对于这种场景，Redis 复制提供了 <code>slave-serve-stale-data</code> 参数，默认开启状态。如果开启则从节点依然响应所有命令。对于无法容忍不一致的应用场景可以设置 no 来关闭命令执行，此时从节点除了 info 和 slaveof 命令之外所有的命令只返回 <code>SYNC with master in progress</code> 信息。</p>
</blockquote>
<p><img src="/" alt="全量复制流程" class="lazyload" data-src="%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B.png"></p>
<p><strong>流程说明：</strong></p>
<ol>
<li><p>发送 psync 命令进行数据同步。</p>
</li>
<li><p>主节点根据 <code>psync-1</code> 解析出当前为全量复制，回复 <code>+FULLRESYNC</code> 响应。</p>
</li>
<li><p>从节点接收主节点的响应数据保存运行 ID 和偏移量 offset 。</p>
</li>
<li><p>主节点执行 bgsave 保存 RDB 文件到本地。</p>
</li>
<li><p>主节点发送 RDB 文件给从节点，从节点把接收的 RDB 文件保存在本地并直接作为从节点的数据文件，接收完 RDB 后从节点打印相关日志，可以在日志中查看主节点发送的数据量。（若 RDB 文件从创建到传输完毕消耗的总时间超过 <code>repl-timeout</code> 所配置的值(默认60秒)，从节点将放弃接受 RDB 文件并清理已经下载的临时文件，导致全量复制失败。）</p>
<p><strong>关于无盘复制：</strong>为了降低主节点磁盘开销，Redis 支持无盘复制，生成的 RDB 文件不保存到硬盘而是直接通过网络发送给从节点，通过 <code>repldiskless-sync</code> 参数控制，默认关闭。无盘复制适用于主节点所在机器磁盘性能较差但网络带宽较充裕的场景。注意无盘复制目前依然处于试验阶段，线上使用需要做好充分测试。</p>
</li>
<li><p>对于从节点开始接收 RDB 快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完 RDB 文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。（如果主节点创建和传输RDB的时间过长，对于高流量写入场景非常容易造成主节点复制客户端缓冲区溢出。此时，主节点将直接关闭复制客户端连接，造成全量同步失败。可以根据主节点数据量和写命令并发量调整 <code>clientoutput-buffer-limit slave</code> 配置，避免全量复制期间客户端缓冲区溢出。）</p>
</li>
<li><p>从节点接收完主节点传送来的全部数据后会清空自身旧数据。</p>
</li>
<li><p>从节点清空数据后开始加载 RDB 文件，对于较大的 RDB 文件，这一步操作依然比较耗时。</p>
</li>
<li><p>从节点成功加载完 RDB 后，如果当前节点开启了 AOF 持久化功能， 它会立刻 <code>bgrewriteaof</code> 操作，为了保证全量复制后 AOF 持久化文件立刻可用。</p>
</li>
</ol>
<h4 id="d、部分复制"><a href="#d、部分复制" class="headerlink" title="d、部分复制"></a>d、部分复制</h4><p><img src="/" alt="部分复制过程" class="lazyload" data-src="%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E9%83%A8%E5%88%86%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.png"></p>
<p><strong>流程说明：</strong></p>
<ol>
<li>当主从节点之间网络出现中断时，如果超过 <code>repl-timeout</code> 时间，主节点会认为从节点故障并中断复制连接。如果此时从节点没有宕机，也会打印与主节点连接丢失日志。</li>
<li>主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最近一段时间的写命令数据，默认最大缓存 1MB。</li>
<li>当主从节点网络恢复后，从节点会再次连上主节点。</li>
<li>当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和 主节点的运行ID。因此会把它们当作 psync 参数发送给主节点，要求进行部分复制操作。</li>
<li>主节点接到 psync 命令后首先核对参数 runId 是否与自身一致，如果一致，说明之前复制的是当前主节点；之后根据参数 offset 在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送 <code>+CONTINUE</code> 响应，表示可以进行部分复制。</li>
<li>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</li>
</ol>
<h4 id="e、心跳"><a href="#e、心跳" class="headerlink" title="e、心跳"></a>e、心跳</h4><p><img src="/" alt="主从心跳检测" class="lazyload" data-src="%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E4%B8%BB%E4%BB%8E%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B.png"></p>
<p>主节点默认每隔10秒对从节点发送 ping 命令，判断从节点的存活性和连接状态。可通过参数 <code>repl-ping-slave-period</code> 控制发送频率。</p>
<p>从节点在主线程中每隔1秒发送 <code>replconf ack{offset}</code> 命令，给主节点上报自身当前的复制偏移量。<code>replconf</code> 命令主要作用如下：</p>
<ul>
<li>实时监测主从节点网络状态。</li>
<li>上报自身复制偏移量，检查复制数据是否丢失，如果从节点数据丢失，再从主节点的复制缓冲区中拉取丢失数据。</li>
<li>实现保证从节点的数量和延迟性功能，通过 <code>min-slaves-to-write</code>、<code>minslaves-max-lag</code>参数配置定义。</li>
</ul>
<h4 id="f、异步复制"><a href="#f、异步复制" class="headerlink" title="f、异步复制"></a>f、异步复制</h4><p>主节点不但负责数据读写，还负责把写命令同步给从节点。写命令的发送过程是异步完成，也就是说主节点自身处理完写命令后直接返回给客户端，并不等待从节点复制完成。</p>
<h3 id="3、问题"><a href="#3、问题" class="headerlink" title="3、问题"></a>3、问题</h3><h4 id="a、读写分离"><a href="#a、读写分离" class="headerlink" title="a、读写分离"></a>a、读写分离</h4><h5 id="①、数据延迟"><a href="#①、数据延迟" class="headerlink" title="①、数据延迟"></a>①、数据延迟</h5><blockquote>
<p>对于无法容忍大量延迟场景，可以编写外部监控程序监听主从节点的复制偏移量，当延迟较大时触发报警或者通知客户端避免读取延迟过高的从节点。</p>
</blockquote>
<h5 id="②、读到过期数据"><a href="#②、读到过期数据" class="headerlink" title="②、读到过期数据"></a>②、读到过期数据</h5><blockquote>
<p>当主节点采取惰性删除，主节点每次处理读取命令时，都会检查键是否超时，如果超时则执行 del 命令删除键对象，之后 del 命令也会异步发送给从节点。若主节点没有读取过期键的操作，那么从节点将会读取到已经超时的数据。</p>
<p>当主节点采取定时删除，主节点在内部定时任务会循环采样一定数量的键，当发现采样的键过期时执行 del 命令，之后再同步给从节点。如果此时数据大量超时，主节点采样速度跟不上过期速度且主节点没有读取过期键的操作，那么从节点将无法收到 del 命令。这时在从节点上可以读取到已经超时的数据。</p>
</blockquote>
<h5 id="③、从节点故障问题"><a href="#③、从节点故障问题" class="headerlink" title="③、从节点故障问题"></a>③、从节点故障问题</h5><blockquote>
<p>对于从节点的故障问题，需要在客户端维护可用从节点列表，当从节点故障时立刻切换到其他从节点或主节点上。这个过程类似上文提到的针对延迟过高的监控处理，需要开发人员改造客户端类库。</p>
</blockquote>
<h4 id="b、主从配置不一致"><a href="#b、主从配置不一致" class="headerlink" title="b、主从配置不一致"></a>b、主从配置不一致</h4><h4 id="c、规避全量复制"><a href="#c、规避全量复制" class="headerlink" title="c、规避全量复制"></a>c、规避全量复制</h4><p>需要进行全量复制的场景：</p>
<ul>
<li>第一次建立复制</li>
<li>节点运行 ID 不匹配</li>
<li>复制积压缓冲区不足</li>
</ul>
<h4 id="d、规避复制风暴"><a href="#d、规避复制风暴" class="headerlink" title="d、规避复制风暴"></a>d、规避复制风暴</h4><blockquote>
<p>复制风暴是指大量从节点对同一主节点或者对同一台机器的多个主节点短时间内发起全量复制的过程。</p>
</blockquote>
<p>复制风暴的场景与规避方式：</p>
<ul>
<li><p>单主节点复制风暴</p>
<p>多个主节点同时发起全量复制，主节点会为从节点创建 RDB 快照，从节点们将共享此快照，但同时向多个从节点发送 RDB 快照，可能使主节点的网络带宽消耗严重，造成主节点的延迟变大，极端情况会发生主从节点连接断开，导致复制失败。</p>
<p><strong>解决：</strong>减少从节点数量，或采用树状复制结构（增大了运维的复杂性，增加了手动和自动处理故障转移的难度）。</p>
</li>
<li><p>单机器复制风暴</p>
<p>当一台机器上同时部署多个主节点时，如果这台机器出现故障或网络长时间中断，当它重启恢复后，会有大量从节点针对这台机器的主节点进行全量复制，会造成当前机器网络带宽耗尽。</p>
<p><strong>解决：</strong>将主节点分散到多台机器，或当主节点故障后提供故障转移机制（提升一个从节点为主节点）。</p>
</li>
</ul>
<h2 id="二、Sentinel（-哨兵-）"><a href="#二、Sentinel（-哨兵-）" class="headerlink" title="二、Sentinel（ 哨兵 ）"></a>二、Sentinel（ 哨兵 ）</h2><blockquote>
<p>Redis2.6 版本提供 Redis Sentinel v1 版本，但是功能性和健壮性都有一些问题，如果想使用Redis Sentinel 的话，建议使用 2.8 以上版本，也就是 v2 版本的 Redis Sentinel 。</p>
</blockquote>
<h3 id="1、Redis-Sentinel-的高可用"><a href="#1、Redis-Sentinel-的高可用" class="headerlink" title="1、Redis Sentinel 的高可用"></a>1、Redis Sentinel 的高可用</h3><blockquote>
<p>Redis Sentinel 是一个分布式架构，其中包含若干个 Sentinel 节点和 Redis 数据节点，每个 Sentinel 节点会对数据节点和其余 Sentinel 节点进行定期监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他 Sentinel 节点进行“协商”，当大多数 Sentinel 节点都认为主节点不可达时，它们会选举出一个 Sentinel 节点来完成自动故障转移的工作，同时会将这个变化实时通知给 Redis 应用方。整个过程完全是自动的，不需要人工来介入，所以这套方案很有效地解决了 Redis 的高可用问题。</p>
<p>Sentinel 节点本身就是独立的 Redis 节点，只不过它们有一些特殊， 它们不存储数据，只支持部分命令。</p>
<p><strong>注意：</strong></p>
<p>这里的分布式是指：Redis 数据节点、Sentinel 节点集合、客户端分布在多个物理节点的架构，不要与<code>Redis 集群(Cluster)</code> 分布式混淆。</p>
<p>Redis Sentinel 与 Redis 主从复制模式只是多了若干 Sentinel 节点，所以 Redis Sentinel 并没有针对 Redis 节点做特殊处理。</p>
</blockquote>
<p><img src="/" alt="Redis Sentinel 相关名词解释" class="lazyload" data-src="%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/Redis%20Sentinel%20%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A.png"></p>
<h4 id="a、Redis-Sentinel-的架构"><a href="#a、Redis-Sentinel-的架构" class="headerlink" title="a、Redis Sentinel 的架构"></a>a、Redis Sentinel 的架构</h4><p><img src="/" alt="Redis 主从复制与 Redis Sentinel 架构的区别" class="lazyload" data-src="%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/Redis%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%20Redis%20Sentinel%20%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB.png"></p>
<h4 id="b、Redis-Sentinel-的功能"><a href="#b、Redis-Sentinel-的功能" class="headerlink" title="b、Redis Sentinel 的功能"></a>b、Redis Sentinel 的功能</h4><ul>
<li><p>监控：</p>
<p>Sentinel 节点会定期检测 Redis 数据节点、其余 Sentinel 节点是否可达。</p>
</li>
<li><p>通知：</p>
<p>Sentinel 节点会将故障转移的结果通知给应用方。</p>
</li>
<li><p>主节点故障转移：</p>
<p>实现从节点晋升为主节点并维护后续正确的主从关系。</p>
</li>
<li><p>配置提供者：</p>
<p>在 Redis Sentinel 结构中，客户端在初始化的时候连接的是 Sentinel 节点集合，从中获取主节点信息。</p>
</li>
</ul>
<h2 id="三、Cluster（-集群-）"><a href="#三、Cluster（-集群-）" class="headerlink" title="三、Cluster（ 集群 ）"></a>三、Cluster（ 集群 ）</h2><blockquote>
<p>Redis Cluster 是 Redis 的分布式解决方案，在 3.0 版本正式推出。</p>
</blockquote>
<h3 id="1、数据分布"><a href="#1、数据分布" class="headerlink" title="1、数据分布"></a>1、数据分布</h3><blockquote>
<p><strong>数据分区规则：</strong></p>
<ul>
<li>哈希分区<ul>
<li>节点取余分区</li>
<li>一致性哈希分区</li>
<li>虚拟槽分区</li>
</ul>
</li>
<li>顺序分区</li>
</ul>
<p><img src="/" alt="哈希分区和顺序分区对比" class="lazyload" data-src="%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA%E5%92%8C%E9%A1%BA%E5%BA%8F%E5%88%86%E5%8C%BA%E5%AF%B9%E6%AF%94.png"></p>
</blockquote>
<h4 id="a、节点取余分区"><a href="#a、节点取余分区" class="headerlink" title="a、节点取余分区"></a>a、节点取余分区</h4><p><img src="/" alt="节点取余分区" class="lazyload" data-src="%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E8%8A%82%E7%82%B9%E5%8F%96%E4%BD%99%E5%88%86%E5%8C%BA.png"></p>
<h4 id="b、一致性哈希分区"><a href="#b、一致性哈希分区" class="headerlink" title="b、一致性哈希分区"></a>b、一致性哈希分区</h4><blockquote>
<p>一致性哈希分区（Distributed Hash Table）实现思路是为系统中每个节点分配一个 token，范围一般在 0~2^32，这些 token 构成一个哈希环。数据读写执行节点查找操作时，先根据 key 计算 hash 值，然后顺时针找到第一个大于等于该哈希值的 token 节点。</p>
</blockquote>
<p><img src="/" alt="一致性哈希分区" class="lazyload" data-src="%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA.png"></p>
<p><strong>优点：</strong></p>
<p>这种方式相比节点取余最大的好处在于加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>加减节点会造成哈希环中部分数据无法命中，需要手动处理或者忽略这部分数据，因此一致性哈希常用于缓存场景。</li>
<li>当使用少量节点时，节点变化将大范围影响哈希环中数据映射，因此这种方式不适合少量数据节点的分布式方案。</li>
<li>普通的一致性哈希分区在增减节点时需要增加一倍或减去一半节点才能保证数据和负载的均衡。</li>
</ul>
<h4 id="c、虚拟槽分区"><a href="#c、虚拟槽分区" class="headerlink" title="c、虚拟槽分区"></a>c、虚拟槽分区</h4><blockquote>
<p>虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot）。这个范围一般远远大于节点数，比如 Redis Cluster 槽范围是 0~16383。槽是集群内数据管理和迁移的基本单位。采用大范围槽的主要目的是为了方便数据拆分和集群扩展。每个节点会负责一定数量的槽。</p>
</blockquote>
<p>例如，当前集群有5个节点，每个节点平均大约负责3276个槽，如下图所示：</p>
<p><img src="/" alt="槽集合与节点关系" class="lazyload" data-src="%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E6%A7%BD%E9%9B%86%E5%90%88%E4%B8%8E%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB.png"></p>
<p><img src="/" alt="使用 CRC16（key）&amp;16383 将键映射到槽上" class="lazyload" data-src="%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E4%BD%BF%E7%94%A8%20CRC16%EF%BC%88key%EF%BC%89&16383%20%E5%B0%86%E9%94%AE%E6%98%A0%E5%B0%84%E5%88%B0%E6%A7%BD%E4%B8%8A.png"></p>
<p><strong>优点：</strong></p>
<ul>
<li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度。</li>
<li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据。</li>
<li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</li>
</ul>
<h3 id="2、集群功能限制"><a href="#2、集群功能限制" class="headerlink" title="2、集群功能限制"></a>2、集群功能限制</h3><blockquote>
<p>Redis 集群相对单机在功能上存在一些限制。</p>
</blockquote>
<ul>
<li>key 批量操作支持有限。如：mset、mget，目前只支持具有相同 slot 值的 key 执行批量操作。对于映射为不同 slot 值的 key 由于执行 mget、mget 等操作可能存在于多个节点上因此不被支持。</li>
<li>key 事务操作支持有限。同理只支持多 key 在同一节点上的事务操作，当多个 key 分布在不同的节点上时无法使用事务功能。</li>
<li>key 作为数据分区的最小粒度，因此不能将一个大的键值对象如 hash、list 等映射到不同的节点。</li>
<li>不支持多数据库空间。单机下的 Redis 可以支持16个数据库，集群模式下只能使用一个数据库空间，即 db0。</li>
<li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</li>
</ul>
<h3 id="3、搭建集群"><a href="#3、搭建集群" class="headerlink" title="3、搭建集群"></a>3、搭建集群</h3><blockquote>
<p>Redis 集群一般由多个节点组成，节点数量至少为 6 个才能保证组成完整 高可用的集群。每个节点需要开启配置 <code>cluster-enabled yes</code>，让 Redis 运行在集群模式下。</p>
<p>建议为集群内所有节点统一目录，一般划分三个目录：conf、 data、log，分别存放配置、数据和日志相关文件。</p>
</blockquote>
<h4 id="a、准备节点"><a href="#a、准备节点" class="headerlink" title="a、准备节点"></a>a、准备节点</h4><p>把节点配置统一放在 conf 目录下，集群相关配置如下：（其他配置和单机模式一致即可）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 节点端口 </span></span><br><span class="line">port 6379 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启集群模式 </span></span><br><span class="line">cluster-enabled yes </span><br><span class="line"><span class="meta">#</span><span class="bash"> 节点超时时间，单位毫秒 </span></span><br><span class="line">cluster-node-timeout 15000 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群内部配置文件 </span></span><br><span class="line">cluster-config-file "nodes-6379.conf"</span><br></pre></td></tr></table></figure>

<p>当启动节点时，如果没有集群配置文件，它会自动创建一份，文件名称采用 <code>cluster-config-file</code> 参数项控制，建议采用 <code>node{port}.conf</code> 格式定义，通过使用端口号区分不同节点，防止同一机器下多个节点彼此覆盖，造成集群信息异常。如果启动时存在集群配置文件，节点会使用配置文件内容初始化集群信息。如下图所示：</p>
<p><img src="/" alt="Redis 集群模式启动过程" class="lazyload" data-src="%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/Redis%20%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png"></p>
<h4 id="b、节点握手"><a href="#b、节点握手" class="headerlink" title="b、节点握手"></a>b、节点握手</h4><h4 id="3、分配槽"><a href="#3、分配槽" class="headerlink" title="3、分配槽"></a>3、分配槽</h4><h3 id="4、节点通信"><a href="#4、节点通信" class="headerlink" title="4、节点通信"></a>4、节点通信</h3><h3 id="5、集群伸缩"><a href="#5、集群伸缩" class="headerlink" title="5、集群伸缩"></a>5、集群伸缩</h3><h3 id="6、请求路由"><a href="#6、请求路由" class="headerlink" title="6、请求路由"></a>6、请求路由</h3><h3 id="7、故障转移"><a href="#7、故障转移" class="headerlink" title="7、故障转移"></a>7、故障转移</h3><h3 id="8、集群运维"><a href="#8、集群运维" class="headerlink" title="8、集群运维"></a>8、集群运维</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">愆凡</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/11/27/%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/">http://yoursite.com/2019/11/27/%E3%80%90%20Redis%20%E7%B3%BB%E5%88%97%2002%20%E3%80%91%EF%BC%9ARedis%20%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">愆凡の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis    </a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/12/04/%E3%80%90%20%E5%88%86%E5%B8%83%E5%BC%8F%2001%20%E3%80%91%EF%BC%9AZookeeper/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【 分布式 01 】：Zookeeper</div></div></a></div><div class="next-post pull_right"><a href="/2019/11/18/%E3%80%90%20MySQL%20%E7%B3%BB%E5%88%97%2001%20%E3%80%91%EF%BC%9ASQL/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【 MySQL 系列 01 】：SQL</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/09/21/【 Redis 系列 01 】：Redis/" title="【 Redis 系列 01 】：Redis"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-09-21</div><div class="relatedPosts_title">【 Redis 系列 01 】：Redis</div></div></a></div><div class="relatedPosts_item"><a href="/2019/12/13/【 Redis 系列 03 】：Redis 缓存/" title="【 Redis 系列 03 】：Redis 缓存"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-12-13</div><div class="relatedPosts_title">【 Redis 系列 03 】：Redis 缓存</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 愆凡</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">簡</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>